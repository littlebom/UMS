
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Personnel
 * 
 */
export type Personnel = $Result.DefaultSelection<Prisma.$PersonnelPayload>
/**
 * Model Faculty
 * 
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model ProgramCourse
 * 
 */
export type ProgramCourse = $Result.DefaultSelection<Prisma.$ProgramCoursePayload>
/**
 * Model AcademicTerm
 * 
 */
export type AcademicTerm = $Result.DefaultSelection<Prisma.$AcademicTermPayload>
/**
 * Model Applicant
 * 
 */
export type Applicant = $Result.DefaultSelection<Prisma.$ApplicantPayload>
/**
 * Model EducationHistory
 * 
 */
export type EducationHistory = $Result.DefaultSelection<Prisma.$EducationHistoryPayload>
/**
 * Model AdmissionTrackType
 * 
 */
export type AdmissionTrackType = $Result.DefaultSelection<Prisma.$AdmissionTrackTypePayload>
/**
 * Model AdmissionTrack
 * 
 */
export type AdmissionTrack = $Result.DefaultSelection<Prisma.$AdmissionTrackPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model InterviewSlot
 * 
 */
export type InterviewSlot = $Result.DefaultSelection<Prisma.$InterviewSlotPayload>
/**
 * Model InterviewSlotInterviewer
 * 
 */
export type InterviewSlotInterviewer = $Result.DefaultSelection<Prisma.$InterviewSlotInterviewerPayload>
/**
 * Model InterviewResult
 * 
 */
export type InterviewResult = $Result.DefaultSelection<Prisma.$InterviewResultPayload>
/**
 * Model InterviewFeedback
 * 
 */
export type InterviewFeedback = $Result.DefaultSelection<Prisma.$InterviewFeedbackPayload>
/**
 * Model StudentGroup
 * 
 */
export type StudentGroup = $Result.DefaultSelection<Prisma.$StudentGroupPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model ClassSection
 * 
 */
export type ClassSection = $Result.DefaultSelection<Prisma.$ClassSectionPayload>
/**
 * Model ClassSchedule
 * 
 */
export type ClassSchedule = $Result.DefaultSelection<Prisma.$ClassSchedulePayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model AiSettings
 * 
 */
export type AiSettings = $Result.DefaultSelection<Prisma.$AiSettingsPayload>
/**
 * Model AiKnowledgeBase
 * 
 */
export type AiKnowledgeBase = $Result.DefaultSelection<Prisma.$AiKnowledgeBasePayload>
/**
 * Model AiConversation
 * 
 */
export type AiConversation = $Result.DefaultSelection<Prisma.$AiConversationPayload>
/**
 * Model AiMessage
 * 
 */
export type AiMessage = $Result.DefaultSelection<Prisma.$AiMessagePayload>
/**
 * Model HelpCategory
 * 
 */
export type HelpCategory = $Result.DefaultSelection<Prisma.$HelpCategoryPayload>
/**
 * Model HelpArticle
 * 
 */
export type HelpArticle = $Result.DefaultSelection<Prisma.$HelpArticlePayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>
/**
 * Model Translation
 * 
 */
export type Translation = $Result.DefaultSelection<Prisma.$TranslationPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model ExamSchedule
 * 
 */
export type ExamSchedule = $Result.DefaultSelection<Prisma.$ExamSchedulePayload>
/**
 * Model ExamSlot
 * 
 */
export type ExamSlot = $Result.DefaultSelection<Prisma.$ExamSlotPayload>
/**
 * Model ExamProctor
 * 
 */
export type ExamProctor = $Result.DefaultSelection<Prisma.$ExamProctorPayload>
/**
 * Model TeachingLoad
 * 
 */
export type TeachingLoad = $Result.DefaultSelection<Prisma.$TeachingLoadPayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  STAFF: 'STAFF',
  INSTRUCTOR: 'INSTRUCTOR',
  STUDENT: 'STUDENT',
  APPLICANT: 'APPLICANT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const DegreeLevel: {
  BACHELOR: 'BACHELOR',
  MASTER: 'MASTER',
  DOCTORATE: 'DOCTORATE'
};

export type DegreeLevel = (typeof DegreeLevel)[keyof typeof DegreeLevel]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ApplicationStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  DOCUMENT_VERIFIED: 'DOCUMENT_VERIFIED',
  INTERVIEW_READY: 'INTERVIEW_READY',
  INTERVIEW_COMPLETED: 'INTERVIEW_COMPLETED',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  ENROLLED: 'ENROLLED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const StudentType: {
  REGULAR: 'REGULAR',
  EXCHANGE: 'EXCHANGE',
  SCHOLARSHIP: 'SCHOLARSHIP',
  SPECIAL: 'SPECIAL',
  TRANSFER: 'TRANSFER',
  INTERNATIONAL: 'INTERNATIONAL'
};

export type StudentType = (typeof StudentType)[keyof typeof StudentType]


export const StudentStatus: {
  STUDYING: 'STUDYING',
  ON_LEAVE: 'ON_LEAVE',
  GRADUATED: 'GRADUATED',
  WITHDRAWN: 'WITHDRAWN',
  DISMISSED: 'DISMISSED'
};

export type StudentStatus = (typeof StudentStatus)[keyof typeof StudentStatus]


export const DayOfWeek: {
  MON: 'MON',
  TUE: 'TUE',
  WED: 'WED',
  THU: 'THU',
  FRI: 'FRI',
  SAT: 'SAT',
  SUN: 'SUN'
};

export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  OVERDUE: 'OVERDUE'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const AnnouncementTarget: {
  ALL: 'ALL',
  STUDENTS: 'STUDENTS',
  INSTRUCTORS: 'INSTRUCTORS',
  STAFF: 'STAFF'
};

export type AnnouncementTarget = (typeof AnnouncementTarget)[keyof typeof AnnouncementTarget]


export const HelpArticleVisibility: {
  PUBLIC: 'PUBLIC',
  STUDENT: 'STUDENT',
  INSTRUCTOR: 'INSTRUCTOR',
  STAFF: 'STAFF',
  ADMIN: 'ADMIN'
};

export type HelpArticleVisibility = (typeof HelpArticleVisibility)[keyof typeof HelpArticleVisibility]


export const RoomType: {
  LECTURE_ROOM: 'LECTURE_ROOM',
  LABORATORY: 'LABORATORY',
  COMPUTER_LAB: 'COMPUTER_LAB',
  STUDIO: 'STUDIO',
  SEMINAR_ROOM: 'SEMINAR_ROOM',
  AUDITORIUM: 'AUDITORIUM',
  SPORTS_FACILITY: 'SPORTS_FACILITY',
  OTHER: 'OTHER'
};

export type RoomType = (typeof RoomType)[keyof typeof RoomType]


export const ExamType: {
  MIDTERM: 'MIDTERM',
  FINAL: 'FINAL',
  QUIZ: 'QUIZ',
  MAKEUP: 'MAKEUP'
};

export type ExamType = (typeof ExamType)[keyof typeof ExamType]


export const ExamFormat: {
  CLOSED_BOOK: 'CLOSED_BOOK',
  OPEN_BOOK: 'OPEN_BOOK',
  TAKE_HOME: 'TAKE_HOME',
  ONLINE: 'ONLINE',
  PRACTICAL: 'PRACTICAL'
};

export type ExamFormat = (typeof ExamFormat)[keyof typeof ExamFormat]


export const ProctorRole: {
  CHIEF: 'CHIEF',
  ASSISTANT: 'ASSISTANT'
};

export type ProctorRole = (typeof ProctorRole)[keyof typeof ProctorRole]


export const LeaveRequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type LeaveRequestStatus = (typeof LeaveRequestStatus)[keyof typeof LeaveRequestStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type DegreeLevel = $Enums.DegreeLevel

export const DegreeLevel: typeof $Enums.DegreeLevel

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type StudentType = $Enums.StudentType

export const StudentType: typeof $Enums.StudentType

export type StudentStatus = $Enums.StudentStatus

export const StudentStatus: typeof $Enums.StudentStatus

export type DayOfWeek = $Enums.DayOfWeek

export const DayOfWeek: typeof $Enums.DayOfWeek

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type AnnouncementTarget = $Enums.AnnouncementTarget

export const AnnouncementTarget: typeof $Enums.AnnouncementTarget

export type HelpArticleVisibility = $Enums.HelpArticleVisibility

export const HelpArticleVisibility: typeof $Enums.HelpArticleVisibility

export type RoomType = $Enums.RoomType

export const RoomType: typeof $Enums.RoomType

export type ExamType = $Enums.ExamType

export const ExamType: typeof $Enums.ExamType

export type ExamFormat = $Enums.ExamFormat

export const ExamFormat: typeof $Enums.ExamFormat

export type ProctorRole = $Enums.ProctorRole

export const ProctorRole: typeof $Enums.ProctorRole

export type LeaveRequestStatus = $Enums.LeaveRequestStatus

export const LeaveRequestStatus: typeof $Enums.LeaveRequestStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.personnel`: Exposes CRUD operations for the **Personnel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personnel
    * const personnel = await prisma.personnel.findMany()
    * ```
    */
  get personnel(): Prisma.PersonnelDelegate<ExtArgs>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.programCourse`: Exposes CRUD operations for the **ProgramCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramCourses
    * const programCourses = await prisma.programCourse.findMany()
    * ```
    */
  get programCourse(): Prisma.ProgramCourseDelegate<ExtArgs>;

  /**
   * `prisma.academicTerm`: Exposes CRUD operations for the **AcademicTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicTerms
    * const academicTerms = await prisma.academicTerm.findMany()
    * ```
    */
  get academicTerm(): Prisma.AcademicTermDelegate<ExtArgs>;

  /**
   * `prisma.applicant`: Exposes CRUD operations for the **Applicant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicants
    * const applicants = await prisma.applicant.findMany()
    * ```
    */
  get applicant(): Prisma.ApplicantDelegate<ExtArgs>;

  /**
   * `prisma.educationHistory`: Exposes CRUD operations for the **EducationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationHistories
    * const educationHistories = await prisma.educationHistory.findMany()
    * ```
    */
  get educationHistory(): Prisma.EducationHistoryDelegate<ExtArgs>;

  /**
   * `prisma.admissionTrackType`: Exposes CRUD operations for the **AdmissionTrackType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmissionTrackTypes
    * const admissionTrackTypes = await prisma.admissionTrackType.findMany()
    * ```
    */
  get admissionTrackType(): Prisma.AdmissionTrackTypeDelegate<ExtArgs>;

  /**
   * `prisma.admissionTrack`: Exposes CRUD operations for the **AdmissionTrack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmissionTracks
    * const admissionTracks = await prisma.admissionTrack.findMany()
    * ```
    */
  get admissionTrack(): Prisma.AdmissionTrackDelegate<ExtArgs>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.interviewSlot`: Exposes CRUD operations for the **InterviewSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewSlots
    * const interviewSlots = await prisma.interviewSlot.findMany()
    * ```
    */
  get interviewSlot(): Prisma.InterviewSlotDelegate<ExtArgs>;

  /**
   * `prisma.interviewSlotInterviewer`: Exposes CRUD operations for the **InterviewSlotInterviewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewSlotInterviewers
    * const interviewSlotInterviewers = await prisma.interviewSlotInterviewer.findMany()
    * ```
    */
  get interviewSlotInterviewer(): Prisma.InterviewSlotInterviewerDelegate<ExtArgs>;

  /**
   * `prisma.interviewResult`: Exposes CRUD operations for the **InterviewResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewResults
    * const interviewResults = await prisma.interviewResult.findMany()
    * ```
    */
  get interviewResult(): Prisma.InterviewResultDelegate<ExtArgs>;

  /**
   * `prisma.interviewFeedback`: Exposes CRUD operations for the **InterviewFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewFeedbacks
    * const interviewFeedbacks = await prisma.interviewFeedback.findMany()
    * ```
    */
  get interviewFeedback(): Prisma.InterviewFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.studentGroup`: Exposes CRUD operations for the **StudentGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentGroups
    * const studentGroups = await prisma.studentGroup.findMany()
    * ```
    */
  get studentGroup(): Prisma.StudentGroupDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.classSection`: Exposes CRUD operations for the **ClassSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSections
    * const classSections = await prisma.classSection.findMany()
    * ```
    */
  get classSection(): Prisma.ClassSectionDelegate<ExtArgs>;

  /**
   * `prisma.classSchedule`: Exposes CRUD operations for the **ClassSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSchedules
    * const classSchedules = await prisma.classSchedule.findMany()
    * ```
    */
  get classSchedule(): Prisma.ClassScheduleDelegate<ExtArgs>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs>;

  /**
   * `prisma.aiSettings`: Exposes CRUD operations for the **AiSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiSettings
    * const aiSettings = await prisma.aiSettings.findMany()
    * ```
    */
  get aiSettings(): Prisma.AiSettingsDelegate<ExtArgs>;

  /**
   * `prisma.aiKnowledgeBase`: Exposes CRUD operations for the **AiKnowledgeBase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiKnowledgeBases
    * const aiKnowledgeBases = await prisma.aiKnowledgeBase.findMany()
    * ```
    */
  get aiKnowledgeBase(): Prisma.AiKnowledgeBaseDelegate<ExtArgs>;

  /**
   * `prisma.aiConversation`: Exposes CRUD operations for the **AiConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiConversations
    * const aiConversations = await prisma.aiConversation.findMany()
    * ```
    */
  get aiConversation(): Prisma.AiConversationDelegate<ExtArgs>;

  /**
   * `prisma.aiMessage`: Exposes CRUD operations for the **AiMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiMessages
    * const aiMessages = await prisma.aiMessage.findMany()
    * ```
    */
  get aiMessage(): Prisma.AiMessageDelegate<ExtArgs>;

  /**
   * `prisma.helpCategory`: Exposes CRUD operations for the **HelpCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpCategories
    * const helpCategories = await prisma.helpCategory.findMany()
    * ```
    */
  get helpCategory(): Prisma.HelpCategoryDelegate<ExtArgs>;

  /**
   * `prisma.helpArticle`: Exposes CRUD operations for the **HelpArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpArticles
    * const helpArticles = await prisma.helpArticle.findMany()
    * ```
    */
  get helpArticle(): Prisma.HelpArticleDelegate<ExtArgs>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs>;

  /**
   * `prisma.translation`: Exposes CRUD operations for the **Translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Translations
    * const translations = await prisma.translation.findMany()
    * ```
    */
  get translation(): Prisma.TranslationDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.examSchedule`: Exposes CRUD operations for the **ExamSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamSchedules
    * const examSchedules = await prisma.examSchedule.findMany()
    * ```
    */
  get examSchedule(): Prisma.ExamScheduleDelegate<ExtArgs>;

  /**
   * `prisma.examSlot`: Exposes CRUD operations for the **ExamSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamSlots
    * const examSlots = await prisma.examSlot.findMany()
    * ```
    */
  get examSlot(): Prisma.ExamSlotDelegate<ExtArgs>;

  /**
   * `prisma.examProctor`: Exposes CRUD operations for the **ExamProctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamProctors
    * const examProctors = await prisma.examProctor.findMany()
    * ```
    */
  get examProctor(): Prisma.ExamProctorDelegate<ExtArgs>;

  /**
   * `prisma.teachingLoad`: Exposes CRUD operations for the **TeachingLoad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeachingLoads
    * const teachingLoads = await prisma.teachingLoad.findMany()
    * ```
    */
  get teachingLoad(): Prisma.TeachingLoadDelegate<ExtArgs>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Personnel: 'Personnel',
    Faculty: 'Faculty',
    Department: 'Department',
    Program: 'Program',
    Course: 'Course',
    ProgramCourse: 'ProgramCourse',
    AcademicTerm: 'AcademicTerm',
    Applicant: 'Applicant',
    EducationHistory: 'EducationHistory',
    AdmissionTrackType: 'AdmissionTrackType',
    AdmissionTrack: 'AdmissionTrack',
    Application: 'Application',
    Document: 'Document',
    InterviewSlot: 'InterviewSlot',
    InterviewSlotInterviewer: 'InterviewSlotInterviewer',
    InterviewResult: 'InterviewResult',
    InterviewFeedback: 'InterviewFeedback',
    StudentGroup: 'StudentGroup',
    Student: 'Student',
    ClassSection: 'ClassSection',
    ClassSchedule: 'ClassSchedule',
    Enrollment: 'Enrollment',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    Announcement: 'Announcement',
    Banner: 'Banner',
    AiSettings: 'AiSettings',
    AiKnowledgeBase: 'AiKnowledgeBase',
    AiConversation: 'AiConversation',
    AiMessage: 'AiMessage',
    HelpCategory: 'HelpCategory',
    HelpArticle: 'HelpArticle',
    SystemSettings: 'SystemSettings',
    SystemLog: 'SystemLog',
    Translation: 'Translation',
    Room: 'Room',
    ExamSchedule: 'ExamSchedule',
    ExamSlot: 'ExamSlot',
    ExamProctor: 'ExamProctor',
    TeachingLoad: 'TeachingLoad',
    LeaveRequest: 'LeaveRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "personnel" | "faculty" | "department" | "program" | "course" | "programCourse" | "academicTerm" | "applicant" | "educationHistory" | "admissionTrackType" | "admissionTrack" | "application" | "document" | "interviewSlot" | "interviewSlotInterviewer" | "interviewResult" | "interviewFeedback" | "studentGroup" | "student" | "classSection" | "classSchedule" | "enrollment" | "invoice" | "invoiceItem" | "payment" | "announcement" | "banner" | "aiSettings" | "aiKnowledgeBase" | "aiConversation" | "aiMessage" | "helpCategory" | "helpArticle" | "systemSettings" | "systemLog" | "translation" | "room" | "examSchedule" | "examSlot" | "examProctor" | "teachingLoad" | "leaveRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Personnel: {
        payload: Prisma.$PersonnelPayload<ExtArgs>
        fields: Prisma.PersonnelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          findFirst: {
            args: Prisma.PersonnelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          findMany: {
            args: Prisma.PersonnelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>[]
          }
          create: {
            args: Prisma.PersonnelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          createMany: {
            args: Prisma.PersonnelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PersonnelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          update: {
            args: Prisma.PersonnelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          deleteMany: {
            args: Prisma.PersonnelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          aggregate: {
            args: Prisma.PersonnelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnel>
          }
          groupBy: {
            args: Prisma.PersonnelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnelCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnelCountAggregateOutputType> | number
          }
        }
      }
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>
        fields: Prisma.FacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      ProgramCourse: {
        payload: Prisma.$ProgramCoursePayload<ExtArgs>
        fields: Prisma.ProgramCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload>
          }
          findFirst: {
            args: Prisma.ProgramCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload>
          }
          findMany: {
            args: Prisma.ProgramCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload>[]
          }
          create: {
            args: Prisma.ProgramCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload>
          }
          createMany: {
            args: Prisma.ProgramCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProgramCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload>
          }
          update: {
            args: Prisma.ProgramCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload>
          }
          deleteMany: {
            args: Prisma.ProgramCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCoursePayload>
          }
          aggregate: {
            args: Prisma.ProgramCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramCourse>
          }
          groupBy: {
            args: Prisma.ProgramCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCourseCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCourseCountAggregateOutputType> | number
          }
        }
      }
      AcademicTerm: {
        payload: Prisma.$AcademicTermPayload<ExtArgs>
        fields: Prisma.AcademicTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload>
          }
          findFirst: {
            args: Prisma.AcademicTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload>
          }
          findMany: {
            args: Prisma.AcademicTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload>[]
          }
          create: {
            args: Prisma.AcademicTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload>
          }
          createMany: {
            args: Prisma.AcademicTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcademicTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload>
          }
          update: {
            args: Prisma.AcademicTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload>
          }
          deleteMany: {
            args: Prisma.AcademicTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicTermPayload>
          }
          aggregate: {
            args: Prisma.AcademicTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicTerm>
          }
          groupBy: {
            args: Prisma.AcademicTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicTermCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicTermCountAggregateOutputType> | number
          }
        }
      }
      Applicant: {
        payload: Prisma.$ApplicantPayload<ExtArgs>
        fields: Prisma.ApplicantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          findFirst: {
            args: Prisma.ApplicantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          findMany: {
            args: Prisma.ApplicantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
          }
          create: {
            args: Prisma.ApplicantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          createMany: {
            args: Prisma.ApplicantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApplicantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          update: {
            args: Prisma.ApplicantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          deleteMany: {
            args: Prisma.ApplicantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          aggregate: {
            args: Prisma.ApplicantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicant>
          }
          groupBy: {
            args: Prisma.ApplicantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicantCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicantCountAggregateOutputType> | number
          }
        }
      }
      EducationHistory: {
        payload: Prisma.$EducationHistoryPayload<ExtArgs>
        fields: Prisma.EducationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload>
          }
          findFirst: {
            args: Prisma.EducationHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload>
          }
          findMany: {
            args: Prisma.EducationHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload>[]
          }
          create: {
            args: Prisma.EducationHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload>
          }
          createMany: {
            args: Prisma.EducationHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EducationHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload>
          }
          update: {
            args: Prisma.EducationHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.EducationHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationHistoryPayload>
          }
          aggregate: {
            args: Prisma.EducationHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationHistory>
          }
          groupBy: {
            args: Prisma.EducationHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<EducationHistoryCountAggregateOutputType> | number
          }
        }
      }
      AdmissionTrackType: {
        payload: Prisma.$AdmissionTrackTypePayload<ExtArgs>
        fields: Prisma.AdmissionTrackTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionTrackTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionTrackTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload>
          }
          findFirst: {
            args: Prisma.AdmissionTrackTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionTrackTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload>
          }
          findMany: {
            args: Prisma.AdmissionTrackTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload>[]
          }
          create: {
            args: Prisma.AdmissionTrackTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload>
          }
          createMany: {
            args: Prisma.AdmissionTrackTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdmissionTrackTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload>
          }
          update: {
            args: Prisma.AdmissionTrackTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload>
          }
          deleteMany: {
            args: Prisma.AdmissionTrackTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionTrackTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionTrackTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackTypePayload>
          }
          aggregate: {
            args: Prisma.AdmissionTrackTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissionTrackType>
          }
          groupBy: {
            args: Prisma.AdmissionTrackTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionTrackTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionTrackTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionTrackTypeCountAggregateOutputType> | number
          }
        }
      }
      AdmissionTrack: {
        payload: Prisma.$AdmissionTrackPayload<ExtArgs>
        fields: Prisma.AdmissionTrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionTrackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionTrackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload>
          }
          findFirst: {
            args: Prisma.AdmissionTrackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionTrackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload>
          }
          findMany: {
            args: Prisma.AdmissionTrackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload>[]
          }
          create: {
            args: Prisma.AdmissionTrackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload>
          }
          createMany: {
            args: Prisma.AdmissionTrackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdmissionTrackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload>
          }
          update: {
            args: Prisma.AdmissionTrackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionTrackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionTrackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionTrackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTrackPayload>
          }
          aggregate: {
            args: Prisma.AdmissionTrackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissionTrack>
          }
          groupBy: {
            args: Prisma.AdmissionTrackGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionTrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionTrackCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionTrackCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      InterviewSlot: {
        payload: Prisma.$InterviewSlotPayload<ExtArgs>
        fields: Prisma.InterviewSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload>
          }
          findFirst: {
            args: Prisma.InterviewSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload>
          }
          findMany: {
            args: Prisma.InterviewSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload>[]
          }
          create: {
            args: Prisma.InterviewSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload>
          }
          createMany: {
            args: Prisma.InterviewSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InterviewSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload>
          }
          update: {
            args: Prisma.InterviewSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload>
          }
          deleteMany: {
            args: Prisma.InterviewSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotPayload>
          }
          aggregate: {
            args: Prisma.InterviewSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewSlot>
          }
          groupBy: {
            args: Prisma.InterviewSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewSlotCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewSlotCountAggregateOutputType> | number
          }
        }
      }
      InterviewSlotInterviewer: {
        payload: Prisma.$InterviewSlotInterviewerPayload<ExtArgs>
        fields: Prisma.InterviewSlotInterviewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewSlotInterviewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewSlotInterviewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload>
          }
          findFirst: {
            args: Prisma.InterviewSlotInterviewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewSlotInterviewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload>
          }
          findMany: {
            args: Prisma.InterviewSlotInterviewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload>[]
          }
          create: {
            args: Prisma.InterviewSlotInterviewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload>
          }
          createMany: {
            args: Prisma.InterviewSlotInterviewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InterviewSlotInterviewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload>
          }
          update: {
            args: Prisma.InterviewSlotInterviewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload>
          }
          deleteMany: {
            args: Prisma.InterviewSlotInterviewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewSlotInterviewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewSlotInterviewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSlotInterviewerPayload>
          }
          aggregate: {
            args: Prisma.InterviewSlotInterviewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewSlotInterviewer>
          }
          groupBy: {
            args: Prisma.InterviewSlotInterviewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewSlotInterviewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewSlotInterviewerCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewSlotInterviewerCountAggregateOutputType> | number
          }
        }
      }
      InterviewResult: {
        payload: Prisma.$InterviewResultPayload<ExtArgs>
        fields: Prisma.InterviewResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload>
          }
          findFirst: {
            args: Prisma.InterviewResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload>
          }
          findMany: {
            args: Prisma.InterviewResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload>[]
          }
          create: {
            args: Prisma.InterviewResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload>
          }
          createMany: {
            args: Prisma.InterviewResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InterviewResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload>
          }
          update: {
            args: Prisma.InterviewResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload>
          }
          deleteMany: {
            args: Prisma.InterviewResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResultPayload>
          }
          aggregate: {
            args: Prisma.InterviewResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewResult>
          }
          groupBy: {
            args: Prisma.InterviewResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewResultCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewResultCountAggregateOutputType> | number
          }
        }
      }
      InterviewFeedback: {
        payload: Prisma.$InterviewFeedbackPayload<ExtArgs>
        fields: Prisma.InterviewFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          findFirst: {
            args: Prisma.InterviewFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          findMany: {
            args: Prisma.InterviewFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>[]
          }
          create: {
            args: Prisma.InterviewFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          createMany: {
            args: Prisma.InterviewFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InterviewFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          update: {
            args: Prisma.InterviewFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.InterviewFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          aggregate: {
            args: Prisma.InterviewFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewFeedback>
          }
          groupBy: {
            args: Prisma.InterviewFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewFeedbackCountAggregateOutputType> | number
          }
        }
      }
      StudentGroup: {
        payload: Prisma.$StudentGroupPayload<ExtArgs>
        fields: Prisma.StudentGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload>
          }
          findFirst: {
            args: Prisma.StudentGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload>
          }
          findMany: {
            args: Prisma.StudentGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload>[]
          }
          create: {
            args: Prisma.StudentGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload>
          }
          createMany: {
            args: Prisma.StudentGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload>
          }
          update: {
            args: Prisma.StudentGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload>
          }
          deleteMany: {
            args: Prisma.StudentGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGroupPayload>
          }
          aggregate: {
            args: Prisma.StudentGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentGroup>
          }
          groupBy: {
            args: Prisma.StudentGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentGroupCountArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      ClassSection: {
        payload: Prisma.$ClassSectionPayload<ExtArgs>
        fields: Prisma.ClassSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          findFirst: {
            args: Prisma.ClassSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          findMany: {
            args: Prisma.ClassSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>[]
          }
          create: {
            args: Prisma.ClassSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          createMany: {
            args: Prisma.ClassSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          update: {
            args: Prisma.ClassSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          deleteMany: {
            args: Prisma.ClassSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          aggregate: {
            args: Prisma.ClassSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSection>
          }
          groupBy: {
            args: Prisma.ClassSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSectionCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSectionCountAggregateOutputType> | number
          }
        }
      }
      ClassSchedule: {
        payload: Prisma.$ClassSchedulePayload<ExtArgs>
        fields: Prisma.ClassScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          findFirst: {
            args: Prisma.ClassScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          findMany: {
            args: Prisma.ClassScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>[]
          }
          create: {
            args: Prisma.ClassScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          createMany: {
            args: Prisma.ClassScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          update: {
            args: Prisma.ClassScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ClassScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          aggregate: {
            args: Prisma.ClassScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSchedule>
          }
          groupBy: {
            args: Prisma.ClassScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ClassScheduleCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      AiSettings: {
        payload: Prisma.$AiSettingsPayload<ExtArgs>
        fields: Prisma.AiSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload>
          }
          findFirst: {
            args: Prisma.AiSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload>
          }
          findMany: {
            args: Prisma.AiSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload>[]
          }
          create: {
            args: Prisma.AiSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload>
          }
          createMany: {
            args: Prisma.AiSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload>
          }
          update: {
            args: Prisma.AiSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload>
          }
          deleteMany: {
            args: Prisma.AiSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSettingsPayload>
          }
          aggregate: {
            args: Prisma.AiSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiSettings>
          }
          groupBy: {
            args: Prisma.AiSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<AiSettingsCountAggregateOutputType> | number
          }
        }
      }
      AiKnowledgeBase: {
        payload: Prisma.$AiKnowledgeBasePayload<ExtArgs>
        fields: Prisma.AiKnowledgeBaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiKnowledgeBaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiKnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload>
          }
          findFirst: {
            args: Prisma.AiKnowledgeBaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiKnowledgeBaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload>
          }
          findMany: {
            args: Prisma.AiKnowledgeBaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload>[]
          }
          create: {
            args: Prisma.AiKnowledgeBaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload>
          }
          createMany: {
            args: Prisma.AiKnowledgeBaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiKnowledgeBaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload>
          }
          update: {
            args: Prisma.AiKnowledgeBaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload>
          }
          deleteMany: {
            args: Prisma.AiKnowledgeBaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiKnowledgeBaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiKnowledgeBaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiKnowledgeBasePayload>
          }
          aggregate: {
            args: Prisma.AiKnowledgeBaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiKnowledgeBase>
          }
          groupBy: {
            args: Prisma.AiKnowledgeBaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiKnowledgeBaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiKnowledgeBaseCountArgs<ExtArgs>
            result: $Utils.Optional<AiKnowledgeBaseCountAggregateOutputType> | number
          }
        }
      }
      AiConversation: {
        payload: Prisma.$AiConversationPayload<ExtArgs>
        fields: Prisma.AiConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          findFirst: {
            args: Prisma.AiConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          findMany: {
            args: Prisma.AiConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
          }
          create: {
            args: Prisma.AiConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          createMany: {
            args: Prisma.AiConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          update: {
            args: Prisma.AiConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          deleteMany: {
            args: Prisma.AiConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          aggregate: {
            args: Prisma.AiConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiConversation>
          }
          groupBy: {
            args: Prisma.AiConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiConversationCountArgs<ExtArgs>
            result: $Utils.Optional<AiConversationCountAggregateOutputType> | number
          }
        }
      }
      AiMessage: {
        payload: Prisma.$AiMessagePayload<ExtArgs>
        fields: Prisma.AiMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          findFirst: {
            args: Prisma.AiMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          findMany: {
            args: Prisma.AiMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>[]
          }
          create: {
            args: Prisma.AiMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          createMany: {
            args: Prisma.AiMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          update: {
            args: Prisma.AiMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          deleteMany: {
            args: Prisma.AiMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          aggregate: {
            args: Prisma.AiMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiMessage>
          }
          groupBy: {
            args: Prisma.AiMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AiMessageCountAggregateOutputType> | number
          }
        }
      }
      HelpCategory: {
        payload: Prisma.$HelpCategoryPayload<ExtArgs>
        fields: Prisma.HelpCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          findFirst: {
            args: Prisma.HelpCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          findMany: {
            args: Prisma.HelpCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>[]
          }
          create: {
            args: Prisma.HelpCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          createMany: {
            args: Prisma.HelpCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HelpCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          update: {
            args: Prisma.HelpCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          deleteMany: {
            args: Prisma.HelpCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          aggregate: {
            args: Prisma.HelpCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpCategory>
          }
          groupBy: {
            args: Prisma.HelpCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryCountAggregateOutputType> | number
          }
        }
      }
      HelpArticle: {
        payload: Prisma.$HelpArticlePayload<ExtArgs>
        fields: Prisma.HelpArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          findFirst: {
            args: Prisma.HelpArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          findMany: {
            args: Prisma.HelpArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>[]
          }
          create: {
            args: Prisma.HelpArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          createMany: {
            args: Prisma.HelpArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HelpArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          update: {
            args: Prisma.HelpArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          deleteMany: {
            args: Prisma.HelpArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          aggregate: {
            args: Prisma.HelpArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpArticle>
          }
          groupBy: {
            args: Prisma.HelpArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpArticleCountArgs<ExtArgs>
            result: $Utils.Optional<HelpArticleCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          createMany: {
            args: Prisma.SystemLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
      Translation: {
        payload: Prisma.$TranslationPayload<ExtArgs>
        fields: Prisma.TranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findFirst: {
            args: Prisma.TranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findMany: {
            args: Prisma.TranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          create: {
            args: Prisma.TranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          createMany: {
            args: Prisma.TranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          update: {
            args: Prisma.TranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          deleteMany: {
            args: Prisma.TranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          aggregate: {
            args: Prisma.TranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslation>
          }
          groupBy: {
            args: Prisma.TranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      ExamSchedule: {
        payload: Prisma.$ExamSchedulePayload<ExtArgs>
        fields: Prisma.ExamScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload>
          }
          findFirst: {
            args: Prisma.ExamScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload>
          }
          findMany: {
            args: Prisma.ExamScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload>[]
          }
          create: {
            args: Prisma.ExamScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload>
          }
          createMany: {
            args: Prisma.ExamScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload>
          }
          update: {
            args: Prisma.ExamScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ExamScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSchedulePayload>
          }
          aggregate: {
            args: Prisma.ExamScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamSchedule>
          }
          groupBy: {
            args: Prisma.ExamScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ExamScheduleCountAggregateOutputType> | number
          }
        }
      }
      ExamSlot: {
        payload: Prisma.$ExamSlotPayload<ExtArgs>
        fields: Prisma.ExamSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload>
          }
          findFirst: {
            args: Prisma.ExamSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload>
          }
          findMany: {
            args: Prisma.ExamSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload>[]
          }
          create: {
            args: Prisma.ExamSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload>
          }
          createMany: {
            args: Prisma.ExamSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload>
          }
          update: {
            args: Prisma.ExamSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload>
          }
          deleteMany: {
            args: Prisma.ExamSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSlotPayload>
          }
          aggregate: {
            args: Prisma.ExamSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamSlot>
          }
          groupBy: {
            args: Prisma.ExamSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamSlotCountArgs<ExtArgs>
            result: $Utils.Optional<ExamSlotCountAggregateOutputType> | number
          }
        }
      }
      ExamProctor: {
        payload: Prisma.$ExamProctorPayload<ExtArgs>
        fields: Prisma.ExamProctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamProctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamProctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload>
          }
          findFirst: {
            args: Prisma.ExamProctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamProctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload>
          }
          findMany: {
            args: Prisma.ExamProctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload>[]
          }
          create: {
            args: Prisma.ExamProctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload>
          }
          createMany: {
            args: Prisma.ExamProctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamProctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload>
          }
          update: {
            args: Prisma.ExamProctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload>
          }
          deleteMany: {
            args: Prisma.ExamProctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamProctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamProctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamProctorPayload>
          }
          aggregate: {
            args: Prisma.ExamProctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamProctor>
          }
          groupBy: {
            args: Prisma.ExamProctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamProctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamProctorCountArgs<ExtArgs>
            result: $Utils.Optional<ExamProctorCountAggregateOutputType> | number
          }
        }
      }
      TeachingLoad: {
        payload: Prisma.$TeachingLoadPayload<ExtArgs>
        fields: Prisma.TeachingLoadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeachingLoadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeachingLoadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload>
          }
          findFirst: {
            args: Prisma.TeachingLoadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeachingLoadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload>
          }
          findMany: {
            args: Prisma.TeachingLoadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload>[]
          }
          create: {
            args: Prisma.TeachingLoadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload>
          }
          createMany: {
            args: Prisma.TeachingLoadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeachingLoadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload>
          }
          update: {
            args: Prisma.TeachingLoadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload>
          }
          deleteMany: {
            args: Prisma.TeachingLoadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeachingLoadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeachingLoadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingLoadPayload>
          }
          aggregate: {
            args: Prisma.TeachingLoadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachingLoad>
          }
          groupBy: {
            args: Prisma.TeachingLoadGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachingLoadGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeachingLoadCountArgs<ExtArgs>
            result: $Utils.Optional<TeachingLoadCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    logs: number
    announcements: number
    helpArticles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    announcements?: boolean | UserCountOutputTypeCountAnnouncementsArgs
    helpArticles?: boolean | UserCountOutputTypeCountHelpArticlesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelpArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpArticleWhereInput
  }


  /**
   * Count Type PersonnelCountOutputType
   */

  export type PersonnelCountOutputType = {
    instructedSections: number
    interviewSlots: number
    teachingSchedules: number
    teachingLoads: number
    proctorDuties: number
    advisorGroups: number
    reviewedLeaveRequests: number
  }

  export type PersonnelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructedSections?: boolean | PersonnelCountOutputTypeCountInstructedSectionsArgs
    interviewSlots?: boolean | PersonnelCountOutputTypeCountInterviewSlotsArgs
    teachingSchedules?: boolean | PersonnelCountOutputTypeCountTeachingSchedulesArgs
    teachingLoads?: boolean | PersonnelCountOutputTypeCountTeachingLoadsArgs
    proctorDuties?: boolean | PersonnelCountOutputTypeCountProctorDutiesArgs
    advisorGroups?: boolean | PersonnelCountOutputTypeCountAdvisorGroupsArgs
    reviewedLeaveRequests?: boolean | PersonnelCountOutputTypeCountReviewedLeaveRequestsArgs
  }

  // Custom InputTypes
  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCountOutputType
     */
    select?: PersonnelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountInstructedSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSectionWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountInterviewSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSlotInterviewerWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountTeachingSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountTeachingLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingLoadWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountProctorDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamProctorWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountAdvisorGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGroupWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountReviewedLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }


  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    departments: number
    programs: number
    personnel: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | FacultyCountOutputTypeCountDepartmentsArgs
    programs?: boolean | FacultyCountOutputTypeCountProgramsArgs
    personnel?: boolean | FacultyCountOutputTypeCountPersonnelArgs
  }

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountPersonnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    programs: number
    personnel: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | DepartmentCountOutputTypeCountProgramsArgs
    personnel?: boolean | DepartmentCountOutputTypeCountPersonnelArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountPersonnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    applications: number
    students: number
    interviewSlots: number
    courses: number
    admissionTracks: number
    studentGroups: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | ProgramCountOutputTypeCountApplicationsArgs
    students?: boolean | ProgramCountOutputTypeCountStudentsArgs
    interviewSlots?: boolean | ProgramCountOutputTypeCountInterviewSlotsArgs
    courses?: boolean | ProgramCountOutputTypeCountCoursesArgs
    admissionTracks?: boolean | ProgramCountOutputTypeCountAdmissionTracksArgs
    studentGroups?: boolean | ProgramCountOutputTypeCountStudentGroupsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountInterviewSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSlotWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramCourseWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountAdmissionTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionTrackWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountStudentGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGroupWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    sections: number
    programs: number
    schedules: number
    examSchedules: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | CourseCountOutputTypeCountSectionsArgs
    programs?: boolean | CourseCountOutputTypeCountProgramsArgs
    schedules?: boolean | CourseCountOutputTypeCountSchedulesArgs
    examSchedules?: boolean | CourseCountOutputTypeCountExamSchedulesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSectionWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountExamSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamScheduleWhereInput
  }


  /**
   * Count Type AcademicTermCountOutputType
   */

  export type AcademicTermCountOutputType = {
    sections: number
    invoices: number
    examSchedules: number
    teachingLoads: number
    schedules: number
  }

  export type AcademicTermCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | AcademicTermCountOutputTypeCountSectionsArgs
    invoices?: boolean | AcademicTermCountOutputTypeCountInvoicesArgs
    examSchedules?: boolean | AcademicTermCountOutputTypeCountExamSchedulesArgs
    teachingLoads?: boolean | AcademicTermCountOutputTypeCountTeachingLoadsArgs
    schedules?: boolean | AcademicTermCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * AcademicTermCountOutputType without action
   */
  export type AcademicTermCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTermCountOutputType
     */
    select?: AcademicTermCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicTermCountOutputType without action
   */
  export type AcademicTermCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSectionWhereInput
  }

  /**
   * AcademicTermCountOutputType without action
   */
  export type AcademicTermCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * AcademicTermCountOutputType without action
   */
  export type AcademicTermCountOutputTypeCountExamSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamScheduleWhereInput
  }

  /**
   * AcademicTermCountOutputType without action
   */
  export type AcademicTermCountOutputTypeCountTeachingLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingLoadWhereInput
  }

  /**
   * AcademicTermCountOutputType without action
   */
  export type AcademicTermCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }


  /**
   * Count Type ApplicantCountOutputType
   */

  export type ApplicantCountOutputType = {
    educationHistory: number
    applications: number
  }

  export type ApplicantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    educationHistory?: boolean | ApplicantCountOutputTypeCountEducationHistoryArgs
    applications?: boolean | ApplicantCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantCountOutputType
     */
    select?: ApplicantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeCountEducationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationHistoryWhereInput
  }

  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type AdmissionTrackTypeCountOutputType
   */

  export type AdmissionTrackTypeCountOutputType = {
    tracks: number
  }

  export type AdmissionTrackTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracks?: boolean | AdmissionTrackTypeCountOutputTypeCountTracksArgs
  }

  // Custom InputTypes
  /**
   * AdmissionTrackTypeCountOutputType without action
   */
  export type AdmissionTrackTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackTypeCountOutputType
     */
    select?: AdmissionTrackTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdmissionTrackTypeCountOutputType without action
   */
  export type AdmissionTrackTypeCountOutputTypeCountTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionTrackWhereInput
  }


  /**
   * Count Type AdmissionTrackCountOutputType
   */

  export type AdmissionTrackCountOutputType = {
    applications: number
  }

  export type AdmissionTrackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | AdmissionTrackCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * AdmissionTrackCountOutputType without action
   */
  export type AdmissionTrackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackCountOutputType
     */
    select?: AdmissionTrackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdmissionTrackCountOutputType without action
   */
  export type AdmissionTrackCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type ApplicationCountOutputType
   */

  export type ApplicationCountOutputType = {
    documents: number
  }

  export type ApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | ApplicationCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationCountOutputType
     */
    select?: ApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type InterviewSlotCountOutputType
   */

  export type InterviewSlotCountOutputType = {
    interviewResults: number
    interviewers: number
  }

  export type InterviewSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interviewResults?: boolean | InterviewSlotCountOutputTypeCountInterviewResultsArgs
    interviewers?: boolean | InterviewSlotCountOutputTypeCountInterviewersArgs
  }

  // Custom InputTypes
  /**
   * InterviewSlotCountOutputType without action
   */
  export type InterviewSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotCountOutputType
     */
    select?: InterviewSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterviewSlotCountOutputType without action
   */
  export type InterviewSlotCountOutputTypeCountInterviewResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewResultWhereInput
  }

  /**
   * InterviewSlotCountOutputType without action
   */
  export type InterviewSlotCountOutputTypeCountInterviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSlotInterviewerWhereInput
  }


  /**
   * Count Type StudentGroupCountOutputType
   */

  export type StudentGroupCountOutputType = {
    students: number
    sections: number
  }

  export type StudentGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | StudentGroupCountOutputTypeCountStudentsArgs
    sections?: boolean | StudentGroupCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * StudentGroupCountOutputType without action
   */
  export type StudentGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroupCountOutputType
     */
    select?: StudentGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentGroupCountOutputType without action
   */
  export type StudentGroupCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * StudentGroupCountOutputType without action
   */
  export type StudentGroupCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSectionWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    enrollments: number
    invoices: number
    leaveRequests: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
    invoices?: boolean | StudentCountOutputTypeCountInvoicesArgs
    leaveRequests?: boolean | StudentCountOutputTypeCountLeaveRequestsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }


  /**
   * Count Type ClassSectionCountOutputType
   */

  export type ClassSectionCountOutputType = {
    schedules: number
    enrollments: number
    studentGroups: number
  }

  export type ClassSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | ClassSectionCountOutputTypeCountSchedulesArgs
    enrollments?: boolean | ClassSectionCountOutputTypeCountEnrollmentsArgs
    studentGroups?: boolean | ClassSectionCountOutputTypeCountStudentGroupsArgs
  }

  // Custom InputTypes
  /**
   * ClassSectionCountOutputType without action
   */
  export type ClassSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSectionCountOutputType
     */
    select?: ClassSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassSectionCountOutputType without action
   */
  export type ClassSectionCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }

  /**
   * ClassSectionCountOutputType without action
   */
  export type ClassSectionCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * ClassSectionCountOutputType without action
   */
  export type ClassSectionCountOutputTypeCountStudentGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGroupWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type AiConversationCountOutputType
   */

  export type AiConversationCountOutputType = {
    messages: number
  }

  export type AiConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AiConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * AiConversationCountOutputType without action
   */
  export type AiConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversationCountOutputType
     */
    select?: AiConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiConversationCountOutputType without action
   */
  export type AiConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMessageWhereInput
  }


  /**
   * Count Type HelpCategoryCountOutputType
   */

  export type HelpCategoryCountOutputType = {
    articles: number
  }

  export type HelpCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | HelpCategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * HelpCategoryCountOutputType without action
   */
  export type HelpCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryCountOutputType
     */
    select?: HelpCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpCategoryCountOutputType without action
   */
  export type HelpCategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpArticleWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    schedules: number
    examSlots: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | RoomCountOutputTypeCountSchedulesArgs
    examSlots?: boolean | RoomCountOutputTypeCountExamSlotsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountExamSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSlotWhereInput
  }


  /**
   * Count Type ExamScheduleCountOutputType
   */

  export type ExamScheduleCountOutputType = {
    examSlots: number
  }

  export type ExamScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examSlots?: boolean | ExamScheduleCountOutputTypeCountExamSlotsArgs
  }

  // Custom InputTypes
  /**
   * ExamScheduleCountOutputType without action
   */
  export type ExamScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScheduleCountOutputType
     */
    select?: ExamScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamScheduleCountOutputType without action
   */
  export type ExamScheduleCountOutputTypeCountExamSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSlotWhereInput
  }


  /**
   * Count Type ExamSlotCountOutputType
   */

  export type ExamSlotCountOutputType = {
    proctors: number
  }

  export type ExamSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proctors?: boolean | ExamSlotCountOutputTypeCountProctorsArgs
  }

  // Custom InputTypes
  /**
   * ExamSlotCountOutputType without action
   */
  export type ExamSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlotCountOutputType
     */
    select?: ExamSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamSlotCountOutputType without action
   */
  export type ExamSlotCountOutputTypeCountProctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamProctorWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    twoFactorBackupCodes: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    twoFactorBackupCodes: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    role: number
    createdAt: number
    updatedAt: number
    twoFactorSecret: number
    twoFactorEnabled: number
    twoFactorBackupCodes: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    twoFactorBackupCodes?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    twoFactorBackupCodes?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    twoFactorBackupCodes?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    twoFactorSecret: string | null
    twoFactorEnabled: boolean
    twoFactorBackupCodes: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: boolean
    personnelProfile?: boolean | User$personnelProfileArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    applicantProfile?: boolean | User$applicantProfileArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    helpArticles?: boolean | User$helpArticlesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnelProfile?: boolean | User$personnelProfileArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    applicantProfile?: boolean | User$applicantProfileArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    helpArticles?: boolean | User$helpArticlesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      personnelProfile: Prisma.$PersonnelPayload<ExtArgs> | null
      studentProfile: Prisma.$StudentPayload<ExtArgs> | null
      applicantProfile: Prisma.$ApplicantPayload<ExtArgs> | null
      logs: Prisma.$SystemLogPayload<ExtArgs>[]
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      helpArticles: Prisma.$HelpArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
      twoFactorSecret: string | null
      twoFactorEnabled: boolean
      twoFactorBackupCodes: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnelProfile<T extends User$personnelProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$personnelProfileArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    studentProfile<T extends User$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$studentProfileArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    applicantProfile<T extends User$applicantProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$applicantProfileArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany"> | Null>
    announcements<T extends User$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany"> | Null>
    helpArticles<T extends User$helpArticlesArgs<ExtArgs> = {}>(args?: Subset<T, User$helpArticlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorBackupCodes: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.personnelProfile
   */
  export type User$personnelProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * User.studentProfile
   */
  export type User$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.applicantProfile
   */
  export type User$applicantProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    where?: ApplicantWhereInput
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    cursor?: SystemLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * User.announcements
   */
  export type User$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.helpArticles
   */
  export type User$helpArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    where?: HelpArticleWhereInput
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    cursor?: HelpArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Personnel
   */

  export type AggregatePersonnel = {
    _count: PersonnelCountAggregateOutputType | null
    _min: PersonnelMinAggregateOutputType | null
    _max: PersonnelMaxAggregateOutputType | null
  }

  export type PersonnelMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    title: string | null
    position: string | null
    phone: string | null
    profileImageUrl: string | null
    facultyId: string | null
    departmentId: string | null
    bio: string | null
    expertise: string | null
    education: string | null
    publications: string | null
    officeHours: string | null
    officeLocation: string | null
    isProfilePublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonnelMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    title: string | null
    position: string | null
    phone: string | null
    profileImageUrl: string | null
    facultyId: string | null
    departmentId: string | null
    bio: string | null
    expertise: string | null
    education: string | null
    publications: string | null
    officeHours: string | null
    officeLocation: string | null
    isProfilePublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonnelCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    title: number
    position: number
    phone: number
    profileImageUrl: number
    facultyId: number
    departmentId: number
    bio: number
    expertise: number
    education: number
    publications: number
    officeHours: number
    officeLocation: number
    isProfilePublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonnelMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    title?: true
    position?: true
    phone?: true
    profileImageUrl?: true
    facultyId?: true
    departmentId?: true
    bio?: true
    expertise?: true
    education?: true
    publications?: true
    officeHours?: true
    officeLocation?: true
    isProfilePublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonnelMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    title?: true
    position?: true
    phone?: true
    profileImageUrl?: true
    facultyId?: true
    departmentId?: true
    bio?: true
    expertise?: true
    education?: true
    publications?: true
    officeHours?: true
    officeLocation?: true
    isProfilePublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonnelCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    title?: true
    position?: true
    phone?: true
    profileImageUrl?: true
    facultyId?: true
    departmentId?: true
    bio?: true
    expertise?: true
    education?: true
    publications?: true
    officeHours?: true
    officeLocation?: true
    isProfilePublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonnelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnel to aggregate.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personnel
    **/
    _count?: true | PersonnelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnelMaxAggregateInputType
  }

  export type GetPersonnelAggregateType<T extends PersonnelAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnel[P]>
      : GetScalarType<T[P], AggregatePersonnel[P]>
  }




  export type PersonnelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelWhereInput
    orderBy?: PersonnelOrderByWithAggregationInput | PersonnelOrderByWithAggregationInput[]
    by: PersonnelScalarFieldEnum[] | PersonnelScalarFieldEnum
    having?: PersonnelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnelCountAggregateInputType | true
    _min?: PersonnelMinAggregateInputType
    _max?: PersonnelMaxAggregateInputType
  }

  export type PersonnelGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    title: string | null
    position: string | null
    phone: string | null
    profileImageUrl: string | null
    facultyId: string | null
    departmentId: string | null
    bio: string | null
    expertise: string | null
    education: string | null
    publications: string | null
    officeHours: string | null
    officeLocation: string | null
    isProfilePublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: PersonnelCountAggregateOutputType | null
    _min: PersonnelMinAggregateOutputType | null
    _max: PersonnelMaxAggregateOutputType | null
  }

  type GetPersonnelGroupByPayload<T extends PersonnelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnelGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnelGroupByOutputType[P]>
        }
      >
    >


  export type PersonnelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    title?: boolean
    position?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    facultyId?: boolean
    departmentId?: boolean
    bio?: boolean
    expertise?: boolean
    education?: boolean
    publications?: boolean
    officeHours?: boolean
    officeLocation?: boolean
    isProfilePublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    faculty?: boolean | Personnel$facultyArgs<ExtArgs>
    department?: boolean | Personnel$departmentArgs<ExtArgs>
    instructedSections?: boolean | Personnel$instructedSectionsArgs<ExtArgs>
    interviewSlots?: boolean | Personnel$interviewSlotsArgs<ExtArgs>
    teachingSchedules?: boolean | Personnel$teachingSchedulesArgs<ExtArgs>
    teachingLoads?: boolean | Personnel$teachingLoadsArgs<ExtArgs>
    proctorDuties?: boolean | Personnel$proctorDutiesArgs<ExtArgs>
    advisorGroups?: boolean | Personnel$advisorGroupsArgs<ExtArgs>
    reviewedLeaveRequests?: boolean | Personnel$reviewedLeaveRequestsArgs<ExtArgs>
    _count?: boolean | PersonnelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnel"]>


  export type PersonnelSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    title?: boolean
    position?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    facultyId?: boolean
    departmentId?: boolean
    bio?: boolean
    expertise?: boolean
    education?: boolean
    publications?: boolean
    officeHours?: boolean
    officeLocation?: boolean
    isProfilePublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonnelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    faculty?: boolean | Personnel$facultyArgs<ExtArgs>
    department?: boolean | Personnel$departmentArgs<ExtArgs>
    instructedSections?: boolean | Personnel$instructedSectionsArgs<ExtArgs>
    interviewSlots?: boolean | Personnel$interviewSlotsArgs<ExtArgs>
    teachingSchedules?: boolean | Personnel$teachingSchedulesArgs<ExtArgs>
    teachingLoads?: boolean | Personnel$teachingLoadsArgs<ExtArgs>
    proctorDuties?: boolean | Personnel$proctorDutiesArgs<ExtArgs>
    advisorGroups?: boolean | Personnel$advisorGroupsArgs<ExtArgs>
    reviewedLeaveRequests?: boolean | Personnel$reviewedLeaveRequestsArgs<ExtArgs>
    _count?: boolean | PersonnelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PersonnelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Personnel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs> | null
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      instructedSections: Prisma.$ClassSectionPayload<ExtArgs>[]
      interviewSlots: Prisma.$InterviewSlotInterviewerPayload<ExtArgs>[]
      teachingSchedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
      teachingLoads: Prisma.$TeachingLoadPayload<ExtArgs>[]
      proctorDuties: Prisma.$ExamProctorPayload<ExtArgs>[]
      advisorGroups: Prisma.$StudentGroupPayload<ExtArgs>[]
      reviewedLeaveRequests: Prisma.$LeaveRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      title: string | null
      position: string | null
      phone: string | null
      profileImageUrl: string | null
      facultyId: string | null
      departmentId: string | null
      bio: string | null
      expertise: string | null
      education: string | null
      publications: string | null
      officeHours: string | null
      officeLocation: string | null
      isProfilePublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["personnel"]>
    composites: {}
  }

  type PersonnelGetPayload<S extends boolean | null | undefined | PersonnelDefaultArgs> = $Result.GetResult<Prisma.$PersonnelPayload, S>

  type PersonnelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnelCountAggregateInputType | true
    }

  export interface PersonnelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Personnel'], meta: { name: 'Personnel' } }
    /**
     * Find zero or one Personnel that matches the filter.
     * @param {PersonnelFindUniqueArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnelFindUniqueArgs>(args: SelectSubset<T, PersonnelFindUniqueArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Personnel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnelFindUniqueOrThrowArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnelFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Personnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelFindFirstArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnelFindFirstArgs>(args?: SelectSubset<T, PersonnelFindFirstArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Personnel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelFindFirstOrThrowArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnelFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Personnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personnel
     * const personnel = await prisma.personnel.findMany()
     * 
     * // Get first 10 Personnel
     * const personnel = await prisma.personnel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personnelWithIdOnly = await prisma.personnel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonnelFindManyArgs>(args?: SelectSubset<T, PersonnelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Personnel.
     * @param {PersonnelCreateArgs} args - Arguments to create a Personnel.
     * @example
     * // Create one Personnel
     * const Personnel = await prisma.personnel.create({
     *   data: {
     *     // ... data to create a Personnel
     *   }
     * })
     * 
     */
    create<T extends PersonnelCreateArgs>(args: SelectSubset<T, PersonnelCreateArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Personnel.
     * @param {PersonnelCreateManyArgs} args - Arguments to create many Personnel.
     * @example
     * // Create many Personnel
     * const personnel = await prisma.personnel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnelCreateManyArgs>(args?: SelectSubset<T, PersonnelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personnel.
     * @param {PersonnelDeleteArgs} args - Arguments to delete one Personnel.
     * @example
     * // Delete one Personnel
     * const Personnel = await prisma.personnel.delete({
     *   where: {
     *     // ... filter to delete one Personnel
     *   }
     * })
     * 
     */
    delete<T extends PersonnelDeleteArgs>(args: SelectSubset<T, PersonnelDeleteArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Personnel.
     * @param {PersonnelUpdateArgs} args - Arguments to update one Personnel.
     * @example
     * // Update one Personnel
     * const personnel = await prisma.personnel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnelUpdateArgs>(args: SelectSubset<T, PersonnelUpdateArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Personnel.
     * @param {PersonnelDeleteManyArgs} args - Arguments to filter Personnel to delete.
     * @example
     * // Delete a few Personnel
     * const { count } = await prisma.personnel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnelDeleteManyArgs>(args?: SelectSubset<T, PersonnelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personnel
     * const personnel = await prisma.personnel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnelUpdateManyArgs>(args: SelectSubset<T, PersonnelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personnel.
     * @param {PersonnelUpsertArgs} args - Arguments to update or create a Personnel.
     * @example
     * // Update or create a Personnel
     * const personnel = await prisma.personnel.upsert({
     *   create: {
     *     // ... data to create a Personnel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personnel we want to update
     *   }
     * })
     */
    upsert<T extends PersonnelUpsertArgs>(args: SelectSubset<T, PersonnelUpsertArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCountArgs} args - Arguments to filter Personnel to count.
     * @example
     * // Count the number of Personnel
     * const count = await prisma.personnel.count({
     *   where: {
     *     // ... the filter for the Personnel we want to count
     *   }
     * })
    **/
    count<T extends PersonnelCountArgs>(
      args?: Subset<T, PersonnelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnelAggregateArgs>(args: Subset<T, PersonnelAggregateArgs>): Prisma.PrismaPromise<GetPersonnelAggregateType<T>>

    /**
     * Group by Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnelGroupByArgs['orderBy'] }
        : { orderBy?: PersonnelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Personnel model
   */
  readonly fields: PersonnelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Personnel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    faculty<T extends Personnel$facultyArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$facultyArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    department<T extends Personnel$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    instructedSections<T extends Personnel$instructedSectionsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$instructedSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findMany"> | Null>
    interviewSlots<T extends Personnel$interviewSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$interviewSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "findMany"> | Null>
    teachingSchedules<T extends Personnel$teachingSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$teachingSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    teachingLoads<T extends Personnel$teachingLoadsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$teachingLoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "findMany"> | Null>
    proctorDuties<T extends Personnel$proctorDutiesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$proctorDutiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "findMany"> | Null>
    advisorGroups<T extends Personnel$advisorGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$advisorGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findMany"> | Null>
    reviewedLeaveRequests<T extends Personnel$reviewedLeaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$reviewedLeaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Personnel model
   */ 
  interface PersonnelFieldRefs {
    readonly id: FieldRef<"Personnel", 'String'>
    readonly userId: FieldRef<"Personnel", 'String'>
    readonly firstName: FieldRef<"Personnel", 'String'>
    readonly lastName: FieldRef<"Personnel", 'String'>
    readonly title: FieldRef<"Personnel", 'String'>
    readonly position: FieldRef<"Personnel", 'String'>
    readonly phone: FieldRef<"Personnel", 'String'>
    readonly profileImageUrl: FieldRef<"Personnel", 'String'>
    readonly facultyId: FieldRef<"Personnel", 'String'>
    readonly departmentId: FieldRef<"Personnel", 'String'>
    readonly bio: FieldRef<"Personnel", 'String'>
    readonly expertise: FieldRef<"Personnel", 'String'>
    readonly education: FieldRef<"Personnel", 'String'>
    readonly publications: FieldRef<"Personnel", 'String'>
    readonly officeHours: FieldRef<"Personnel", 'String'>
    readonly officeLocation: FieldRef<"Personnel", 'String'>
    readonly isProfilePublic: FieldRef<"Personnel", 'Boolean'>
    readonly createdAt: FieldRef<"Personnel", 'DateTime'>
    readonly updatedAt: FieldRef<"Personnel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Personnel findUnique
   */
  export type PersonnelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel findUniqueOrThrow
   */
  export type PersonnelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel findFirst
   */
  export type PersonnelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnel.
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnel.
     */
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Personnel findFirstOrThrow
   */
  export type PersonnelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnel.
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnel.
     */
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Personnel findMany
   */
  export type PersonnelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personnel.
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Personnel create
   */
  export type PersonnelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * The data needed to create a Personnel.
     */
    data: XOR<PersonnelCreateInput, PersonnelUncheckedCreateInput>
  }

  /**
   * Personnel createMany
   */
  export type PersonnelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Personnel.
     */
    data: PersonnelCreateManyInput | PersonnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Personnel update
   */
  export type PersonnelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * The data needed to update a Personnel.
     */
    data: XOR<PersonnelUpdateInput, PersonnelUncheckedUpdateInput>
    /**
     * Choose, which Personnel to update.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel updateMany
   */
  export type PersonnelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Personnel.
     */
    data: XOR<PersonnelUpdateManyMutationInput, PersonnelUncheckedUpdateManyInput>
    /**
     * Filter which Personnel to update
     */
    where?: PersonnelWhereInput
  }

  /**
   * Personnel upsert
   */
  export type PersonnelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * The filter to search for the Personnel to update in case it exists.
     */
    where: PersonnelWhereUniqueInput
    /**
     * In case the Personnel found by the `where` argument doesn't exist, create a new Personnel with this data.
     */
    create: XOR<PersonnelCreateInput, PersonnelUncheckedCreateInput>
    /**
     * In case the Personnel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnelUpdateInput, PersonnelUncheckedUpdateInput>
  }

  /**
   * Personnel delete
   */
  export type PersonnelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter which Personnel to delete.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel deleteMany
   */
  export type PersonnelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnel to delete
     */
    where?: PersonnelWhereInput
  }

  /**
   * Personnel.faculty
   */
  export type Personnel$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
  }

  /**
   * Personnel.department
   */
  export type Personnel$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Personnel.instructedSections
   */
  export type Personnel$instructedSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    where?: ClassSectionWhereInput
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    cursor?: ClassSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * Personnel.interviewSlots
   */
  export type Personnel$interviewSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    where?: InterviewSlotInterviewerWhereInput
    orderBy?: InterviewSlotInterviewerOrderByWithRelationInput | InterviewSlotInterviewerOrderByWithRelationInput[]
    cursor?: InterviewSlotInterviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewSlotInterviewerScalarFieldEnum | InterviewSlotInterviewerScalarFieldEnum[]
  }

  /**
   * Personnel.teachingSchedules
   */
  export type Personnel$teachingSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * Personnel.teachingLoads
   */
  export type Personnel$teachingLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    where?: TeachingLoadWhereInput
    orderBy?: TeachingLoadOrderByWithRelationInput | TeachingLoadOrderByWithRelationInput[]
    cursor?: TeachingLoadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingLoadScalarFieldEnum | TeachingLoadScalarFieldEnum[]
  }

  /**
   * Personnel.proctorDuties
   */
  export type Personnel$proctorDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    where?: ExamProctorWhereInput
    orderBy?: ExamProctorOrderByWithRelationInput | ExamProctorOrderByWithRelationInput[]
    cursor?: ExamProctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamProctorScalarFieldEnum | ExamProctorScalarFieldEnum[]
  }

  /**
   * Personnel.advisorGroups
   */
  export type Personnel$advisorGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    where?: StudentGroupWhereInput
    orderBy?: StudentGroupOrderByWithRelationInput | StudentGroupOrderByWithRelationInput[]
    cursor?: StudentGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentGroupScalarFieldEnum | StudentGroupScalarFieldEnum[]
  }

  /**
   * Personnel.reviewedLeaveRequests
   */
  export type Personnel$reviewedLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Personnel without action
   */
  export type PersonnelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
  }


  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyMinAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    logoUrl: string | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    logoUrl: string | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    code: number
    nameTh: number
    nameEn: number
    description: number
    logoUrl: number
    _all: number
  }


  export type FacultyMinAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    logoUrl?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    logoUrl?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    logoUrl?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    id: string
    code: string
    nameTh: string
    nameEn: string
    description: string | null
    logoUrl: string | null
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    logoUrl?: boolean
    departments?: boolean | Faculty$departmentsArgs<ExtArgs>
    programs?: boolean | Faculty$programsArgs<ExtArgs>
    personnel?: boolean | Faculty$personnelArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>


  export type FacultySelectScalar = {
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    logoUrl?: boolean
  }

  export type FacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Faculty$departmentsArgs<ExtArgs>
    programs?: boolean | Faculty$programsArgs<ExtArgs>
    personnel?: boolean | Faculty$personnelArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faculty"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      personnel: Prisma.$PersonnelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      nameTh: string
      nameEn: string
      description: string | null
      logoUrl: string | null
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }

  type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<Prisma.$FacultyPayload, S>

  type FacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacultyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface FacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty'], meta: { name: 'Faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyFindUniqueArgs>(args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyFindFirstArgs>(args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacultyFindManyArgs>(args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
     */
    create<T extends FacultyCreateArgs>(args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Faculties.
     * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyCreateManyArgs>(args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
     */
    delete<T extends FacultyDeleteArgs>(args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyUpdateArgs>(args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyDeleteManyArgs>(args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyUpdateManyArgs>(args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends FacultyUpsertArgs>(args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faculty model
   */
  readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Faculty$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    programs<T extends Faculty$programsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany"> | Null>
    personnel<T extends Faculty$personnelArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$personnelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faculty model
   */ 
  interface FacultyFieldRefs {
    readonly id: FieldRef<"Faculty", 'String'>
    readonly code: FieldRef<"Faculty", 'String'>
    readonly nameTh: FieldRef<"Faculty", 'String'>
    readonly nameEn: FieldRef<"Faculty", 'String'>
    readonly description: FieldRef<"Faculty", 'String'>
    readonly logoUrl: FieldRef<"Faculty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty create
   */
  export type FacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }

  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
  }

  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }

  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput
  }

  /**
   * Faculty.departments
   */
  export type Faculty$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Faculty.programs
   */
  export type Faculty$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Faculty.personnel
   */
  export type Faculty$personnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    cursor?: PersonnelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    facultyId: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    facultyId: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    nameTh: number
    nameEn: number
    description: number
    facultyId: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    nameTh?: true
    nameEn?: true
    description?: true
    facultyId?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    nameTh?: true
    nameEn?: true
    description?: true
    facultyId?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    nameTh?: true
    nameEn?: true
    description?: true
    facultyId?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    nameTh: string
    nameEn: string
    description: string | null
    facultyId: string
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    facultyId?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    programs?: boolean | Department$programsArgs<ExtArgs>
    personnel?: boolean | Department$personnelArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>


  export type DepartmentSelectScalar = {
    id?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    facultyId?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    programs?: boolean | Department$programsArgs<ExtArgs>
    personnel?: boolean | Department$personnelArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      faculty: Prisma.$FacultyPayload<ExtArgs>
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      personnel: Prisma.$PersonnelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nameTh: string
      nameEn: string
      description: string | null
      facultyId: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    programs<T extends Department$programsArgs<ExtArgs> = {}>(args?: Subset<T, Department$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany"> | Null>
    personnel<T extends Department$personnelArgs<ExtArgs> = {}>(args?: Subset<T, Department$personnelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly nameTh: FieldRef<"Department", 'String'>
    readonly nameEn: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly facultyId: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.programs
   */
  export type Department$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Department.personnel
   */
  export type Department$personnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    cursor?: PersonnelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    credits: number | null
  }

  export type ProgramSumAggregateOutputType = {
    credits: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    nameTh: string | null
    nameEn: string | null
    degreeLevel: $Enums.DegreeLevel | null
    description: string | null
    isAcceptingApplications: boolean | null
    credits: number | null
    duration: string | null
    objectives: string | null
    structure: string | null
    admissionRequirements: string | null
    careerOpportunities: string | null
    facultyId: string | null
    departmentId: string | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    nameTh: string | null
    nameEn: string | null
    degreeLevel: $Enums.DegreeLevel | null
    description: string | null
    isAcceptingApplications: boolean | null
    credits: number | null
    duration: string | null
    objectives: string | null
    structure: string | null
    admissionRequirements: string | null
    careerOpportunities: string | null
    facultyId: string | null
    departmentId: string | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    nameTh: number
    nameEn: number
    degreeLevel: number
    description: number
    isAcceptingApplications: number
    credits: number
    duration: number
    objectives: number
    structure: number
    admissionRequirements: number
    careerOpportunities: number
    facultyId: number
    departmentId: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    credits?: true
  }

  export type ProgramSumAggregateInputType = {
    credits?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    nameTh?: true
    nameEn?: true
    degreeLevel?: true
    description?: true
    isAcceptingApplications?: true
    credits?: true
    duration?: true
    objectives?: true
    structure?: true
    admissionRequirements?: true
    careerOpportunities?: true
    facultyId?: true
    departmentId?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    nameTh?: true
    nameEn?: true
    degreeLevel?: true
    description?: true
    isAcceptingApplications?: true
    credits?: true
    duration?: true
    objectives?: true
    structure?: true
    admissionRequirements?: true
    careerOpportunities?: true
    facultyId?: true
    departmentId?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    nameTh?: true
    nameEn?: true
    degreeLevel?: true
    description?: true
    isAcceptingApplications?: true
    credits?: true
    duration?: true
    objectives?: true
    structure?: true
    admissionRequirements?: true
    careerOpportunities?: true
    facultyId?: true
    departmentId?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description: string | null
    isAcceptingApplications: boolean
    credits: number | null
    duration: string | null
    objectives: string | null
    structure: string | null
    admissionRequirements: string | null
    careerOpportunities: string | null
    facultyId: string
    departmentId: string
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameTh?: boolean
    nameEn?: boolean
    degreeLevel?: boolean
    description?: boolean
    isAcceptingApplications?: boolean
    credits?: boolean
    duration?: boolean
    objectives?: boolean
    structure?: boolean
    admissionRequirements?: boolean
    careerOpportunities?: boolean
    facultyId?: boolean
    departmentId?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    applications?: boolean | Program$applicationsArgs<ExtArgs>
    students?: boolean | Program$studentsArgs<ExtArgs>
    interviewSlots?: boolean | Program$interviewSlotsArgs<ExtArgs>
    courses?: boolean | Program$coursesArgs<ExtArgs>
    admissionTracks?: boolean | Program$admissionTracksArgs<ExtArgs>
    studentGroups?: boolean | Program$studentGroupsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>


  export type ProgramSelectScalar = {
    id?: boolean
    nameTh?: boolean
    nameEn?: boolean
    degreeLevel?: boolean
    description?: boolean
    isAcceptingApplications?: boolean
    credits?: boolean
    duration?: boolean
    objectives?: boolean
    structure?: boolean
    admissionRequirements?: boolean
    careerOpportunities?: boolean
    facultyId?: boolean
    departmentId?: boolean
  }

  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    applications?: boolean | Program$applicationsArgs<ExtArgs>
    students?: boolean | Program$studentsArgs<ExtArgs>
    interviewSlots?: boolean | Program$interviewSlotsArgs<ExtArgs>
    courses?: boolean | Program$coursesArgs<ExtArgs>
    admissionTracks?: boolean | Program$admissionTracksArgs<ExtArgs>
    studentGroups?: boolean | Program$studentGroupsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      faculty: Prisma.$FacultyPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      interviewSlots: Prisma.$InterviewSlotPayload<ExtArgs>[]
      courses: Prisma.$ProgramCoursePayload<ExtArgs>[]
      admissionTracks: Prisma.$AdmissionTrackPayload<ExtArgs>[]
      studentGroups: Prisma.$StudentGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nameTh: string
      nameEn: string
      degreeLevel: $Enums.DegreeLevel
      description: string | null
      isAcceptingApplications: boolean
      credits: number | null
      duration: string | null
      objectives: string | null
      structure: string | null
      admissionRequirements: string | null
      careerOpportunities: string | null
      facultyId: string
      departmentId: string
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    applications<T extends Program$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Program$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends Program$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Program$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    interviewSlots<T extends Program$interviewSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Program$interviewSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findMany"> | Null>
    courses<T extends Program$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Program$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "findMany"> | Null>
    admissionTracks<T extends Program$admissionTracksArgs<ExtArgs> = {}>(args?: Subset<T, Program$admissionTracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findMany"> | Null>
    studentGroups<T extends Program$studentGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Program$studentGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */ 
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly nameTh: FieldRef<"Program", 'String'>
    readonly nameEn: FieldRef<"Program", 'String'>
    readonly degreeLevel: FieldRef<"Program", 'DegreeLevel'>
    readonly description: FieldRef<"Program", 'String'>
    readonly isAcceptingApplications: FieldRef<"Program", 'Boolean'>
    readonly credits: FieldRef<"Program", 'Int'>
    readonly duration: FieldRef<"Program", 'String'>
    readonly objectives: FieldRef<"Program", 'String'>
    readonly structure: FieldRef<"Program", 'String'>
    readonly admissionRequirements: FieldRef<"Program", 'String'>
    readonly careerOpportunities: FieldRef<"Program", 'String'>
    readonly facultyId: FieldRef<"Program", 'String'>
    readonly departmentId: FieldRef<"Program", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
  }

  /**
   * Program.applications
   */
  export type Program$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Program.students
   */
  export type Program$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Program.interviewSlots
   */
  export type Program$interviewSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    where?: InterviewSlotWhereInput
    orderBy?: InterviewSlotOrderByWithRelationInput | InterviewSlotOrderByWithRelationInput[]
    cursor?: InterviewSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewSlotScalarFieldEnum | InterviewSlotScalarFieldEnum[]
  }

  /**
   * Program.courses
   */
  export type Program$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    where?: ProgramCourseWhereInput
    orderBy?: ProgramCourseOrderByWithRelationInput | ProgramCourseOrderByWithRelationInput[]
    cursor?: ProgramCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramCourseScalarFieldEnum | ProgramCourseScalarFieldEnum[]
  }

  /**
   * Program.admissionTracks
   */
  export type Program$admissionTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    where?: AdmissionTrackWhereInput
    orderBy?: AdmissionTrackOrderByWithRelationInput | AdmissionTrackOrderByWithRelationInput[]
    cursor?: AdmissionTrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionTrackScalarFieldEnum | AdmissionTrackScalarFieldEnum[]
  }

  /**
   * Program.studentGroups
   */
  export type Program$studentGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    where?: StudentGroupWhereInput
    orderBy?: StudentGroupOrderByWithRelationInput | StudentGroupOrderByWithRelationInput[]
    cursor?: StudentGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentGroupScalarFieldEnum | StudentGroupScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    credits: number | null
    minYearLevel: number | null
    minGpax: number | null
    maxEnrollment: number | null
  }

  export type CourseSumAggregateOutputType = {
    credits: number | null
    minYearLevel: number | null
    minGpax: number | null
    maxEnrollment: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    credits: number | null
    description: string | null
    learningOutcomes: string | null
    syllabusUrl: string | null
    minYearLevel: number | null
    allowedStudentTypes: string | null
    allowedPrograms: string | null
    minGpax: number | null
    prerequisiteCourses: string | null
    maxEnrollment: number | null
    requiresApproval: boolean | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    credits: number | null
    description: string | null
    learningOutcomes: string | null
    syllabusUrl: string | null
    minYearLevel: number | null
    allowedStudentTypes: string | null
    allowedPrograms: string | null
    minGpax: number | null
    prerequisiteCourses: string | null
    maxEnrollment: number | null
    requiresApproval: boolean | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    code: number
    nameTh: number
    nameEn: number
    credits: number
    description: number
    learningOutcomes: number
    syllabusUrl: number
    minYearLevel: number
    allowedStudentTypes: number
    allowedPrograms: number
    minGpax: number
    prerequisiteCourses: number
    maxEnrollment: number
    requiresApproval: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    credits?: true
    minYearLevel?: true
    minGpax?: true
    maxEnrollment?: true
  }

  export type CourseSumAggregateInputType = {
    credits?: true
    minYearLevel?: true
    minGpax?: true
    maxEnrollment?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    credits?: true
    description?: true
    learningOutcomes?: true
    syllabusUrl?: true
    minYearLevel?: true
    allowedStudentTypes?: true
    allowedPrograms?: true
    minGpax?: true
    prerequisiteCourses?: true
    maxEnrollment?: true
    requiresApproval?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    credits?: true
    description?: true
    learningOutcomes?: true
    syllabusUrl?: true
    minYearLevel?: true
    allowedStudentTypes?: true
    allowedPrograms?: true
    minGpax?: true
    prerequisiteCourses?: true
    maxEnrollment?: true
    requiresApproval?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    credits?: true
    description?: true
    learningOutcomes?: true
    syllabusUrl?: true
    minYearLevel?: true
    allowedStudentTypes?: true
    allowedPrograms?: true
    minGpax?: true
    prerequisiteCourses?: true
    maxEnrollment?: true
    requiresApproval?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description: string | null
    learningOutcomes: string | null
    syllabusUrl: string | null
    minYearLevel: number | null
    allowedStudentTypes: string | null
    allowedPrograms: string | null
    minGpax: number | null
    prerequisiteCourses: string | null
    maxEnrollment: number | null
    requiresApproval: boolean
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    credits?: boolean
    description?: boolean
    learningOutcomes?: boolean
    syllabusUrl?: boolean
    minYearLevel?: boolean
    allowedStudentTypes?: boolean
    allowedPrograms?: boolean
    minGpax?: boolean
    prerequisiteCourses?: boolean
    maxEnrollment?: boolean
    requiresApproval?: boolean
    sections?: boolean | Course$sectionsArgs<ExtArgs>
    programs?: boolean | Course$programsArgs<ExtArgs>
    schedules?: boolean | Course$schedulesArgs<ExtArgs>
    examSchedules?: boolean | Course$examSchedulesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>


  export type CourseSelectScalar = {
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    credits?: boolean
    description?: boolean
    learningOutcomes?: boolean
    syllabusUrl?: boolean
    minYearLevel?: boolean
    allowedStudentTypes?: boolean
    allowedPrograms?: boolean
    minGpax?: boolean
    prerequisiteCourses?: boolean
    maxEnrollment?: boolean
    requiresApproval?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | Course$sectionsArgs<ExtArgs>
    programs?: boolean | Course$programsArgs<ExtArgs>
    schedules?: boolean | Course$schedulesArgs<ExtArgs>
    examSchedules?: boolean | Course$examSchedulesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      sections: Prisma.$ClassSectionPayload<ExtArgs>[]
      programs: Prisma.$ProgramCoursePayload<ExtArgs>[]
      schedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
      examSchedules: Prisma.$ExamSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      nameTh: string
      nameEn: string
      credits: number
      description: string | null
      learningOutcomes: string | null
      syllabusUrl: string | null
      minYearLevel: number | null
      allowedStudentTypes: string | null
      allowedPrograms: string | null
      minGpax: number | null
      prerequisiteCourses: string | null
      maxEnrollment: number | null
      requiresApproval: boolean
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends Course$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Course$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findMany"> | Null>
    programs<T extends Course$programsArgs<ExtArgs> = {}>(args?: Subset<T, Course$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Course$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    examSchedules<T extends Course$examSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$examSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly nameTh: FieldRef<"Course", 'String'>
    readonly nameEn: FieldRef<"Course", 'String'>
    readonly credits: FieldRef<"Course", 'Int'>
    readonly description: FieldRef<"Course", 'String'>
    readonly learningOutcomes: FieldRef<"Course", 'String'>
    readonly syllabusUrl: FieldRef<"Course", 'String'>
    readonly minYearLevel: FieldRef<"Course", 'Int'>
    readonly allowedStudentTypes: FieldRef<"Course", 'String'>
    readonly allowedPrograms: FieldRef<"Course", 'String'>
    readonly minGpax: FieldRef<"Course", 'Float'>
    readonly prerequisiteCourses: FieldRef<"Course", 'String'>
    readonly maxEnrollment: FieldRef<"Course", 'Int'>
    readonly requiresApproval: FieldRef<"Course", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.sections
   */
  export type Course$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    where?: ClassSectionWhereInput
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    cursor?: ClassSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * Course.programs
   */
  export type Course$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    where?: ProgramCourseWhereInput
    orderBy?: ProgramCourseOrderByWithRelationInput | ProgramCourseOrderByWithRelationInput[]
    cursor?: ProgramCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramCourseScalarFieldEnum | ProgramCourseScalarFieldEnum[]
  }

  /**
   * Course.schedules
   */
  export type Course$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * Course.examSchedules
   */
  export type Course$examSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    where?: ExamScheduleWhereInput
    orderBy?: ExamScheduleOrderByWithRelationInput | ExamScheduleOrderByWithRelationInput[]
    cursor?: ExamScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScheduleScalarFieldEnum | ExamScheduleScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model ProgramCourse
   */

  export type AggregateProgramCourse = {
    _count: ProgramCourseCountAggregateOutputType | null
    _avg: ProgramCourseAvgAggregateOutputType | null
    _sum: ProgramCourseSumAggregateOutputType | null
    _min: ProgramCourseMinAggregateOutputType | null
    _max: ProgramCourseMaxAggregateOutputType | null
  }

  export type ProgramCourseAvgAggregateOutputType = {
    semester: number | null
  }

  export type ProgramCourseSumAggregateOutputType = {
    semester: number | null
  }

  export type ProgramCourseMinAggregateOutputType = {
    id: string | null
    programId: string | null
    courseId: string | null
    isRequired: boolean | null
    semester: number | null
  }

  export type ProgramCourseMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    courseId: string | null
    isRequired: boolean | null
    semester: number | null
  }

  export type ProgramCourseCountAggregateOutputType = {
    id: number
    programId: number
    courseId: number
    isRequired: number
    semester: number
    _all: number
  }


  export type ProgramCourseAvgAggregateInputType = {
    semester?: true
  }

  export type ProgramCourseSumAggregateInputType = {
    semester?: true
  }

  export type ProgramCourseMinAggregateInputType = {
    id?: true
    programId?: true
    courseId?: true
    isRequired?: true
    semester?: true
  }

  export type ProgramCourseMaxAggregateInputType = {
    id?: true
    programId?: true
    courseId?: true
    isRequired?: true
    semester?: true
  }

  export type ProgramCourseCountAggregateInputType = {
    id?: true
    programId?: true
    courseId?: true
    isRequired?: true
    semester?: true
    _all?: true
  }

  export type ProgramCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramCourse to aggregate.
     */
    where?: ProgramCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCourses to fetch.
     */
    orderBy?: ProgramCourseOrderByWithRelationInput | ProgramCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramCourses
    **/
    _count?: true | ProgramCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramCourseMaxAggregateInputType
  }

  export type GetProgramCourseAggregateType<T extends ProgramCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramCourse[P]>
      : GetScalarType<T[P], AggregateProgramCourse[P]>
  }




  export type ProgramCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramCourseWhereInput
    orderBy?: ProgramCourseOrderByWithAggregationInput | ProgramCourseOrderByWithAggregationInput[]
    by: ProgramCourseScalarFieldEnum[] | ProgramCourseScalarFieldEnum
    having?: ProgramCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCourseCountAggregateInputType | true
    _avg?: ProgramCourseAvgAggregateInputType
    _sum?: ProgramCourseSumAggregateInputType
    _min?: ProgramCourseMinAggregateInputType
    _max?: ProgramCourseMaxAggregateInputType
  }

  export type ProgramCourseGroupByOutputType = {
    id: string
    programId: string
    courseId: string
    isRequired: boolean
    semester: number | null
    _count: ProgramCourseCountAggregateOutputType | null
    _avg: ProgramCourseAvgAggregateOutputType | null
    _sum: ProgramCourseSumAggregateOutputType | null
    _min: ProgramCourseMinAggregateOutputType | null
    _max: ProgramCourseMaxAggregateOutputType | null
  }

  type GetProgramCourseGroupByPayload<T extends ProgramCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramCourseGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramCourseGroupByOutputType[P]>
        }
      >
    >


  export type ProgramCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    courseId?: boolean
    isRequired?: boolean
    semester?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programCourse"]>


  export type ProgramCourseSelectScalar = {
    id?: boolean
    programId?: boolean
    courseId?: boolean
    isRequired?: boolean
    semester?: boolean
  }

  export type ProgramCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ProgramCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramCourse"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      courseId: string
      isRequired: boolean
      semester: number | null
    }, ExtArgs["result"]["programCourse"]>
    composites: {}
  }

  type ProgramCourseGetPayload<S extends boolean | null | undefined | ProgramCourseDefaultArgs> = $Result.GetResult<Prisma.$ProgramCoursePayload, S>

  type ProgramCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramCourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramCourseCountAggregateInputType | true
    }

  export interface ProgramCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramCourse'], meta: { name: 'ProgramCourse' } }
    /**
     * Find zero or one ProgramCourse that matches the filter.
     * @param {ProgramCourseFindUniqueArgs} args - Arguments to find a ProgramCourse
     * @example
     * // Get one ProgramCourse
     * const programCourse = await prisma.programCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramCourseFindUniqueArgs>(args: SelectSubset<T, ProgramCourseFindUniqueArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramCourse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramCourseFindUniqueOrThrowArgs} args - Arguments to find a ProgramCourse
     * @example
     * // Get one ProgramCourse
     * const programCourse = await prisma.programCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCourseFindFirstArgs} args - Arguments to find a ProgramCourse
     * @example
     * // Get one ProgramCourse
     * const programCourse = await prisma.programCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramCourseFindFirstArgs>(args?: SelectSubset<T, ProgramCourseFindFirstArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCourseFindFirstOrThrowArgs} args - Arguments to find a ProgramCourse
     * @example
     * // Get one ProgramCourse
     * const programCourse = await prisma.programCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramCourses
     * const programCourses = await prisma.programCourse.findMany()
     * 
     * // Get first 10 ProgramCourses
     * const programCourses = await prisma.programCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programCourseWithIdOnly = await prisma.programCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramCourseFindManyArgs>(args?: SelectSubset<T, ProgramCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramCourse.
     * @param {ProgramCourseCreateArgs} args - Arguments to create a ProgramCourse.
     * @example
     * // Create one ProgramCourse
     * const ProgramCourse = await prisma.programCourse.create({
     *   data: {
     *     // ... data to create a ProgramCourse
     *   }
     * })
     * 
     */
    create<T extends ProgramCourseCreateArgs>(args: SelectSubset<T, ProgramCourseCreateArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramCourses.
     * @param {ProgramCourseCreateManyArgs} args - Arguments to create many ProgramCourses.
     * @example
     * // Create many ProgramCourses
     * const programCourse = await prisma.programCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCourseCreateManyArgs>(args?: SelectSubset<T, ProgramCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProgramCourse.
     * @param {ProgramCourseDeleteArgs} args - Arguments to delete one ProgramCourse.
     * @example
     * // Delete one ProgramCourse
     * const ProgramCourse = await prisma.programCourse.delete({
     *   where: {
     *     // ... filter to delete one ProgramCourse
     *   }
     * })
     * 
     */
    delete<T extends ProgramCourseDeleteArgs>(args: SelectSubset<T, ProgramCourseDeleteArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramCourse.
     * @param {ProgramCourseUpdateArgs} args - Arguments to update one ProgramCourse.
     * @example
     * // Update one ProgramCourse
     * const programCourse = await prisma.programCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramCourseUpdateArgs>(args: SelectSubset<T, ProgramCourseUpdateArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramCourses.
     * @param {ProgramCourseDeleteManyArgs} args - Arguments to filter ProgramCourses to delete.
     * @example
     * // Delete a few ProgramCourses
     * const { count } = await prisma.programCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramCourseDeleteManyArgs>(args?: SelectSubset<T, ProgramCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramCourses
     * const programCourse = await prisma.programCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramCourseUpdateManyArgs>(args: SelectSubset<T, ProgramCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramCourse.
     * @param {ProgramCourseUpsertArgs} args - Arguments to update or create a ProgramCourse.
     * @example
     * // Update or create a ProgramCourse
     * const programCourse = await prisma.programCourse.upsert({
     *   create: {
     *     // ... data to create a ProgramCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramCourse we want to update
     *   }
     * })
     */
    upsert<T extends ProgramCourseUpsertArgs>(args: SelectSubset<T, ProgramCourseUpsertArgs<ExtArgs>>): Prisma__ProgramCourseClient<$Result.GetResult<Prisma.$ProgramCoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCourseCountArgs} args - Arguments to filter ProgramCourses to count.
     * @example
     * // Count the number of ProgramCourses
     * const count = await prisma.programCourse.count({
     *   where: {
     *     // ... the filter for the ProgramCourses we want to count
     *   }
     * })
    **/
    count<T extends ProgramCourseCountArgs>(
      args?: Subset<T, ProgramCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramCourseAggregateArgs>(args: Subset<T, ProgramCourseAggregateArgs>): Prisma.PrismaPromise<GetProgramCourseAggregateType<T>>

    /**
     * Group by ProgramCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramCourseGroupByArgs['orderBy'] }
        : { orderBy?: ProgramCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramCourse model
   */
  readonly fields: ProgramCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramCourse model
   */ 
  interface ProgramCourseFieldRefs {
    readonly id: FieldRef<"ProgramCourse", 'String'>
    readonly programId: FieldRef<"ProgramCourse", 'String'>
    readonly courseId: FieldRef<"ProgramCourse", 'String'>
    readonly isRequired: FieldRef<"ProgramCourse", 'Boolean'>
    readonly semester: FieldRef<"ProgramCourse", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProgramCourse findUnique
   */
  export type ProgramCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCourse to fetch.
     */
    where: ProgramCourseWhereUniqueInput
  }

  /**
   * ProgramCourse findUniqueOrThrow
   */
  export type ProgramCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCourse to fetch.
     */
    where: ProgramCourseWhereUniqueInput
  }

  /**
   * ProgramCourse findFirst
   */
  export type ProgramCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCourse to fetch.
     */
    where?: ProgramCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCourses to fetch.
     */
    orderBy?: ProgramCourseOrderByWithRelationInput | ProgramCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramCourses.
     */
    cursor?: ProgramCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramCourses.
     */
    distinct?: ProgramCourseScalarFieldEnum | ProgramCourseScalarFieldEnum[]
  }

  /**
   * ProgramCourse findFirstOrThrow
   */
  export type ProgramCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCourse to fetch.
     */
    where?: ProgramCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCourses to fetch.
     */
    orderBy?: ProgramCourseOrderByWithRelationInput | ProgramCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramCourses.
     */
    cursor?: ProgramCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramCourses.
     */
    distinct?: ProgramCourseScalarFieldEnum | ProgramCourseScalarFieldEnum[]
  }

  /**
   * ProgramCourse findMany
   */
  export type ProgramCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCourses to fetch.
     */
    where?: ProgramCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCourses to fetch.
     */
    orderBy?: ProgramCourseOrderByWithRelationInput | ProgramCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramCourses.
     */
    cursor?: ProgramCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCourses.
     */
    skip?: number
    distinct?: ProgramCourseScalarFieldEnum | ProgramCourseScalarFieldEnum[]
  }

  /**
   * ProgramCourse create
   */
  export type ProgramCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramCourse.
     */
    data: XOR<ProgramCourseCreateInput, ProgramCourseUncheckedCreateInput>
  }

  /**
   * ProgramCourse createMany
   */
  export type ProgramCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramCourses.
     */
    data: ProgramCourseCreateManyInput | ProgramCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramCourse update
   */
  export type ProgramCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramCourse.
     */
    data: XOR<ProgramCourseUpdateInput, ProgramCourseUncheckedUpdateInput>
    /**
     * Choose, which ProgramCourse to update.
     */
    where: ProgramCourseWhereUniqueInput
  }

  /**
   * ProgramCourse updateMany
   */
  export type ProgramCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramCourses.
     */
    data: XOR<ProgramCourseUpdateManyMutationInput, ProgramCourseUncheckedUpdateManyInput>
    /**
     * Filter which ProgramCourses to update
     */
    where?: ProgramCourseWhereInput
  }

  /**
   * ProgramCourse upsert
   */
  export type ProgramCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramCourse to update in case it exists.
     */
    where: ProgramCourseWhereUniqueInput
    /**
     * In case the ProgramCourse found by the `where` argument doesn't exist, create a new ProgramCourse with this data.
     */
    create: XOR<ProgramCourseCreateInput, ProgramCourseUncheckedCreateInput>
    /**
     * In case the ProgramCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramCourseUpdateInput, ProgramCourseUncheckedUpdateInput>
  }

  /**
   * ProgramCourse delete
   */
  export type ProgramCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
    /**
     * Filter which ProgramCourse to delete.
     */
    where: ProgramCourseWhereUniqueInput
  }

  /**
   * ProgramCourse deleteMany
   */
  export type ProgramCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramCourses to delete
     */
    where?: ProgramCourseWhereInput
  }

  /**
   * ProgramCourse without action
   */
  export type ProgramCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCourse
     */
    select?: ProgramCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCourseInclude<ExtArgs> | null
  }


  /**
   * Model AcademicTerm
   */

  export type AggregateAcademicTerm = {
    _count: AcademicTermCountAggregateOutputType | null
    _avg: AcademicTermAvgAggregateOutputType | null
    _sum: AcademicTermSumAggregateOutputType | null
    _min: AcademicTermMinAggregateOutputType | null
    _max: AcademicTermMaxAggregateOutputType | null
  }

  export type AcademicTermAvgAggregateOutputType = {
    year: number | null
    semester: number | null
  }

  export type AcademicTermSumAggregateOutputType = {
    year: number | null
    semester: number | null
  }

  export type AcademicTermMinAggregateOutputType = {
    id: string | null
    year: number | null
    semester: number | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
  }

  export type AcademicTermMaxAggregateOutputType = {
    id: string | null
    year: number | null
    semester: number | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
  }

  export type AcademicTermCountAggregateOutputType = {
    id: number
    year: number
    semester: number
    startDate: number
    endDate: number
    isCurrent: number
    _all: number
  }


  export type AcademicTermAvgAggregateInputType = {
    year?: true
    semester?: true
  }

  export type AcademicTermSumAggregateInputType = {
    year?: true
    semester?: true
  }

  export type AcademicTermMinAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
  }

  export type AcademicTermMaxAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
  }

  export type AcademicTermCountAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    _all?: true
  }

  export type AcademicTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicTerm to aggregate.
     */
    where?: AcademicTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTerms to fetch.
     */
    orderBy?: AcademicTermOrderByWithRelationInput | AcademicTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicTerms
    **/
    _count?: true | AcademicTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicTermAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicTermSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicTermMaxAggregateInputType
  }

  export type GetAcademicTermAggregateType<T extends AcademicTermAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicTerm[P]>
      : GetScalarType<T[P], AggregateAcademicTerm[P]>
  }




  export type AcademicTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicTermWhereInput
    orderBy?: AcademicTermOrderByWithAggregationInput | AcademicTermOrderByWithAggregationInput[]
    by: AcademicTermScalarFieldEnum[] | AcademicTermScalarFieldEnum
    having?: AcademicTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicTermCountAggregateInputType | true
    _avg?: AcademicTermAvgAggregateInputType
    _sum?: AcademicTermSumAggregateInputType
    _min?: AcademicTermMinAggregateInputType
    _max?: AcademicTermMaxAggregateInputType
  }

  export type AcademicTermGroupByOutputType = {
    id: string
    year: number
    semester: number
    startDate: Date
    endDate: Date
    isCurrent: boolean
    _count: AcademicTermCountAggregateOutputType | null
    _avg: AcademicTermAvgAggregateOutputType | null
    _sum: AcademicTermSumAggregateOutputType | null
    _min: AcademicTermMinAggregateOutputType | null
    _max: AcademicTermMaxAggregateOutputType | null
  }

  type GetAcademicTermGroupByPayload<T extends AcademicTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicTermGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicTermGroupByOutputType[P]>
        }
      >
    >


  export type AcademicTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    semester?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    sections?: boolean | AcademicTerm$sectionsArgs<ExtArgs>
    invoices?: boolean | AcademicTerm$invoicesArgs<ExtArgs>
    examSchedules?: boolean | AcademicTerm$examSchedulesArgs<ExtArgs>
    teachingLoads?: boolean | AcademicTerm$teachingLoadsArgs<ExtArgs>
    schedules?: boolean | AcademicTerm$schedulesArgs<ExtArgs>
    _count?: boolean | AcademicTermCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicTerm"]>


  export type AcademicTermSelectScalar = {
    id?: boolean
    year?: boolean
    semester?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
  }

  export type AcademicTermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | AcademicTerm$sectionsArgs<ExtArgs>
    invoices?: boolean | AcademicTerm$invoicesArgs<ExtArgs>
    examSchedules?: boolean | AcademicTerm$examSchedulesArgs<ExtArgs>
    teachingLoads?: boolean | AcademicTerm$teachingLoadsArgs<ExtArgs>
    schedules?: boolean | AcademicTerm$schedulesArgs<ExtArgs>
    _count?: boolean | AcademicTermCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcademicTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicTerm"
    objects: {
      sections: Prisma.$ClassSectionPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      examSchedules: Prisma.$ExamSchedulePayload<ExtArgs>[]
      teachingLoads: Prisma.$TeachingLoadPayload<ExtArgs>[]
      schedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      semester: number
      startDate: Date
      endDate: Date
      isCurrent: boolean
    }, ExtArgs["result"]["academicTerm"]>
    composites: {}
  }

  type AcademicTermGetPayload<S extends boolean | null | undefined | AcademicTermDefaultArgs> = $Result.GetResult<Prisma.$AcademicTermPayload, S>

  type AcademicTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicTermFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicTermCountAggregateInputType | true
    }

  export interface AcademicTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicTerm'], meta: { name: 'AcademicTerm' } }
    /**
     * Find zero or one AcademicTerm that matches the filter.
     * @param {AcademicTermFindUniqueArgs} args - Arguments to find a AcademicTerm
     * @example
     * // Get one AcademicTerm
     * const academicTerm = await prisma.academicTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicTermFindUniqueArgs>(args: SelectSubset<T, AcademicTermFindUniqueArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicTerm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicTermFindUniqueOrThrowArgs} args - Arguments to find a AcademicTerm
     * @example
     * // Get one AcademicTerm
     * const academicTerm = await prisma.academicTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicTermFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTermFindFirstArgs} args - Arguments to find a AcademicTerm
     * @example
     * // Get one AcademicTerm
     * const academicTerm = await prisma.academicTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicTermFindFirstArgs>(args?: SelectSubset<T, AcademicTermFindFirstArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTermFindFirstOrThrowArgs} args - Arguments to find a AcademicTerm
     * @example
     * // Get one AcademicTerm
     * const academicTerm = await prisma.academicTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicTermFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicTerms
     * const academicTerms = await prisma.academicTerm.findMany()
     * 
     * // Get first 10 AcademicTerms
     * const academicTerms = await prisma.academicTerm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicTermWithIdOnly = await prisma.academicTerm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicTermFindManyArgs>(args?: SelectSubset<T, AcademicTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicTerm.
     * @param {AcademicTermCreateArgs} args - Arguments to create a AcademicTerm.
     * @example
     * // Create one AcademicTerm
     * const AcademicTerm = await prisma.academicTerm.create({
     *   data: {
     *     // ... data to create a AcademicTerm
     *   }
     * })
     * 
     */
    create<T extends AcademicTermCreateArgs>(args: SelectSubset<T, AcademicTermCreateArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicTerms.
     * @param {AcademicTermCreateManyArgs} args - Arguments to create many AcademicTerms.
     * @example
     * // Create many AcademicTerms
     * const academicTerm = await prisma.academicTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicTermCreateManyArgs>(args?: SelectSubset<T, AcademicTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicTerm.
     * @param {AcademicTermDeleteArgs} args - Arguments to delete one AcademicTerm.
     * @example
     * // Delete one AcademicTerm
     * const AcademicTerm = await prisma.academicTerm.delete({
     *   where: {
     *     // ... filter to delete one AcademicTerm
     *   }
     * })
     * 
     */
    delete<T extends AcademicTermDeleteArgs>(args: SelectSubset<T, AcademicTermDeleteArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicTerm.
     * @param {AcademicTermUpdateArgs} args - Arguments to update one AcademicTerm.
     * @example
     * // Update one AcademicTerm
     * const academicTerm = await prisma.academicTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicTermUpdateArgs>(args: SelectSubset<T, AcademicTermUpdateArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicTerms.
     * @param {AcademicTermDeleteManyArgs} args - Arguments to filter AcademicTerms to delete.
     * @example
     * // Delete a few AcademicTerms
     * const { count } = await prisma.academicTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicTermDeleteManyArgs>(args?: SelectSubset<T, AcademicTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicTerms
     * const academicTerm = await prisma.academicTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicTermUpdateManyArgs>(args: SelectSubset<T, AcademicTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicTerm.
     * @param {AcademicTermUpsertArgs} args - Arguments to update or create a AcademicTerm.
     * @example
     * // Update or create a AcademicTerm
     * const academicTerm = await prisma.academicTerm.upsert({
     *   create: {
     *     // ... data to create a AcademicTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicTerm we want to update
     *   }
     * })
     */
    upsert<T extends AcademicTermUpsertArgs>(args: SelectSubset<T, AcademicTermUpsertArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTermCountArgs} args - Arguments to filter AcademicTerms to count.
     * @example
     * // Count the number of AcademicTerms
     * const count = await prisma.academicTerm.count({
     *   where: {
     *     // ... the filter for the AcademicTerms we want to count
     *   }
     * })
    **/
    count<T extends AcademicTermCountArgs>(
      args?: Subset<T, AcademicTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicTermAggregateArgs>(args: Subset<T, AcademicTermAggregateArgs>): Prisma.PrismaPromise<GetAcademicTermAggregateType<T>>

    /**
     * Group by AcademicTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicTermGroupByArgs['orderBy'] }
        : { orderBy?: AcademicTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicTerm model
   */
  readonly fields: AcademicTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends AcademicTerm$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTerm$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends AcademicTerm$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTerm$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    examSchedules<T extends AcademicTerm$examSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTerm$examSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    teachingLoads<T extends AcademicTerm$teachingLoadsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTerm$teachingLoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends AcademicTerm$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTerm$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicTerm model
   */ 
  interface AcademicTermFieldRefs {
    readonly id: FieldRef<"AcademicTerm", 'String'>
    readonly year: FieldRef<"AcademicTerm", 'Int'>
    readonly semester: FieldRef<"AcademicTerm", 'Int'>
    readonly startDate: FieldRef<"AcademicTerm", 'DateTime'>
    readonly endDate: FieldRef<"AcademicTerm", 'DateTime'>
    readonly isCurrent: FieldRef<"AcademicTerm", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AcademicTerm findUnique
   */
  export type AcademicTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTerm to fetch.
     */
    where: AcademicTermWhereUniqueInput
  }

  /**
   * AcademicTerm findUniqueOrThrow
   */
  export type AcademicTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTerm to fetch.
     */
    where: AcademicTermWhereUniqueInput
  }

  /**
   * AcademicTerm findFirst
   */
  export type AcademicTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTerm to fetch.
     */
    where?: AcademicTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTerms to fetch.
     */
    orderBy?: AcademicTermOrderByWithRelationInput | AcademicTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicTerms.
     */
    cursor?: AcademicTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicTerms.
     */
    distinct?: AcademicTermScalarFieldEnum | AcademicTermScalarFieldEnum[]
  }

  /**
   * AcademicTerm findFirstOrThrow
   */
  export type AcademicTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTerm to fetch.
     */
    where?: AcademicTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTerms to fetch.
     */
    orderBy?: AcademicTermOrderByWithRelationInput | AcademicTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicTerms.
     */
    cursor?: AcademicTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicTerms.
     */
    distinct?: AcademicTermScalarFieldEnum | AcademicTermScalarFieldEnum[]
  }

  /**
   * AcademicTerm findMany
   */
  export type AcademicTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTerms to fetch.
     */
    where?: AcademicTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTerms to fetch.
     */
    orderBy?: AcademicTermOrderByWithRelationInput | AcademicTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicTerms.
     */
    cursor?: AcademicTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTerms.
     */
    skip?: number
    distinct?: AcademicTermScalarFieldEnum | AcademicTermScalarFieldEnum[]
  }

  /**
   * AcademicTerm create
   */
  export type AcademicTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicTerm.
     */
    data: XOR<AcademicTermCreateInput, AcademicTermUncheckedCreateInput>
  }

  /**
   * AcademicTerm createMany
   */
  export type AcademicTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicTerms.
     */
    data: AcademicTermCreateManyInput | AcademicTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicTerm update
   */
  export type AcademicTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicTerm.
     */
    data: XOR<AcademicTermUpdateInput, AcademicTermUncheckedUpdateInput>
    /**
     * Choose, which AcademicTerm to update.
     */
    where: AcademicTermWhereUniqueInput
  }

  /**
   * AcademicTerm updateMany
   */
  export type AcademicTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicTerms.
     */
    data: XOR<AcademicTermUpdateManyMutationInput, AcademicTermUncheckedUpdateManyInput>
    /**
     * Filter which AcademicTerms to update
     */
    where?: AcademicTermWhereInput
  }

  /**
   * AcademicTerm upsert
   */
  export type AcademicTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicTerm to update in case it exists.
     */
    where: AcademicTermWhereUniqueInput
    /**
     * In case the AcademicTerm found by the `where` argument doesn't exist, create a new AcademicTerm with this data.
     */
    create: XOR<AcademicTermCreateInput, AcademicTermUncheckedCreateInput>
    /**
     * In case the AcademicTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicTermUpdateInput, AcademicTermUncheckedUpdateInput>
  }

  /**
   * AcademicTerm delete
   */
  export type AcademicTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    /**
     * Filter which AcademicTerm to delete.
     */
    where: AcademicTermWhereUniqueInput
  }

  /**
   * AcademicTerm deleteMany
   */
  export type AcademicTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicTerms to delete
     */
    where?: AcademicTermWhereInput
  }

  /**
   * AcademicTerm.sections
   */
  export type AcademicTerm$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    where?: ClassSectionWhereInput
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    cursor?: ClassSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * AcademicTerm.invoices
   */
  export type AcademicTerm$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * AcademicTerm.examSchedules
   */
  export type AcademicTerm$examSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    where?: ExamScheduleWhereInput
    orderBy?: ExamScheduleOrderByWithRelationInput | ExamScheduleOrderByWithRelationInput[]
    cursor?: ExamScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScheduleScalarFieldEnum | ExamScheduleScalarFieldEnum[]
  }

  /**
   * AcademicTerm.teachingLoads
   */
  export type AcademicTerm$teachingLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    where?: TeachingLoadWhereInput
    orderBy?: TeachingLoadOrderByWithRelationInput | TeachingLoadOrderByWithRelationInput[]
    cursor?: TeachingLoadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingLoadScalarFieldEnum | TeachingLoadScalarFieldEnum[]
  }

  /**
   * AcademicTerm.schedules
   */
  export type AcademicTerm$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * AcademicTerm without action
   */
  export type AcademicTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
  }


  /**
   * Model Applicant
   */

  export type AggregateApplicant = {
    _count: ApplicantCountAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  export type ApplicantMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    firstNameTh: string | null
    lastNameTh: string | null
    nationality: string | null
    title: string | null
    citizenId: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    phone: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    zipCode: string | null
    profileImageUrl: string | null
  }

  export type ApplicantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    firstNameTh: string | null
    lastNameTh: string | null
    nationality: string | null
    title: string | null
    citizenId: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    phone: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    zipCode: string | null
    profileImageUrl: string | null
  }

  export type ApplicantCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    firstNameTh: number
    lastNameTh: number
    nationality: number
    title: number
    citizenId: number
    birthDate: number
    gender: number
    phone: number
    address: number
    subDistrict: number
    district: number
    province: number
    zipCode: number
    profileImageUrl: number
    _all: number
  }


  export type ApplicantMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    firstNameTh?: true
    lastNameTh?: true
    nationality?: true
    title?: true
    citizenId?: true
    birthDate?: true
    gender?: true
    phone?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    zipCode?: true
    profileImageUrl?: true
  }

  export type ApplicantMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    firstNameTh?: true
    lastNameTh?: true
    nationality?: true
    title?: true
    citizenId?: true
    birthDate?: true
    gender?: true
    phone?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    zipCode?: true
    profileImageUrl?: true
  }

  export type ApplicantCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    firstNameTh?: true
    lastNameTh?: true
    nationality?: true
    title?: true
    citizenId?: true
    birthDate?: true
    gender?: true
    phone?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    zipCode?: true
    profileImageUrl?: true
    _all?: true
  }

  export type ApplicantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applicant to aggregate.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applicants
    **/
    _count?: true | ApplicantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicantMaxAggregateInputType
  }

  export type GetApplicantAggregateType<T extends ApplicantAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicant[P]>
      : GetScalarType<T[P], AggregateApplicant[P]>
  }




  export type ApplicantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantWhereInput
    orderBy?: ApplicantOrderByWithAggregationInput | ApplicantOrderByWithAggregationInput[]
    by: ApplicantScalarFieldEnum[] | ApplicantScalarFieldEnum
    having?: ApplicantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicantCountAggregateInputType | true
    _min?: ApplicantMinAggregateInputType
    _max?: ApplicantMaxAggregateInputType
  }

  export type ApplicantGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    firstNameTh: string | null
    lastNameTh: string | null
    nationality: string | null
    title: string | null
    citizenId: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    phone: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    zipCode: string | null
    profileImageUrl: string | null
    _count: ApplicantCountAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  type GetApplicantGroupByPayload<T extends ApplicantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
        }
      >
    >


  export type ApplicantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    nationality?: boolean
    title?: boolean
    citizenId?: boolean
    birthDate?: boolean
    gender?: boolean
    phone?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    zipCode?: boolean
    profileImageUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    educationHistory?: boolean | Applicant$educationHistoryArgs<ExtArgs>
    applications?: boolean | Applicant$applicationsArgs<ExtArgs>
    _count?: boolean | ApplicantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicant"]>


  export type ApplicantSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    nationality?: boolean
    title?: boolean
    citizenId?: boolean
    birthDate?: boolean
    gender?: boolean
    phone?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    zipCode?: boolean
    profileImageUrl?: boolean
  }

  export type ApplicantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    educationHistory?: boolean | Applicant$educationHistoryArgs<ExtArgs>
    applications?: boolean | Applicant$applicationsArgs<ExtArgs>
    _count?: boolean | ApplicantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ApplicantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Applicant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      educationHistory: Prisma.$EducationHistoryPayload<ExtArgs>[]
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      firstNameTh: string | null
      lastNameTh: string | null
      nationality: string | null
      title: string | null
      citizenId: string | null
      birthDate: Date | null
      gender: $Enums.Gender | null
      phone: string | null
      address: string | null
      subDistrict: string | null
      district: string | null
      province: string | null
      zipCode: string | null
      profileImageUrl: string | null
    }, ExtArgs["result"]["applicant"]>
    composites: {}
  }

  type ApplicantGetPayload<S extends boolean | null | undefined | ApplicantDefaultArgs> = $Result.GetResult<Prisma.$ApplicantPayload, S>

  type ApplicantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApplicantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicantCountAggregateInputType | true
    }

  export interface ApplicantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Applicant'], meta: { name: 'Applicant' } }
    /**
     * Find zero or one Applicant that matches the filter.
     * @param {ApplicantFindUniqueArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicantFindUniqueArgs>(args: SelectSubset<T, ApplicantFindUniqueArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Applicant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApplicantFindUniqueOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicantFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Applicant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicantFindFirstArgs>(args?: SelectSubset<T, ApplicantFindFirstArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Applicant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicantFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicants
     * const applicants = await prisma.applicant.findMany()
     * 
     * // Get first 10 Applicants
     * const applicants = await prisma.applicant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicantWithIdOnly = await prisma.applicant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicantFindManyArgs>(args?: SelectSubset<T, ApplicantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Applicant.
     * @param {ApplicantCreateArgs} args - Arguments to create a Applicant.
     * @example
     * // Create one Applicant
     * const Applicant = await prisma.applicant.create({
     *   data: {
     *     // ... data to create a Applicant
     *   }
     * })
     * 
     */
    create<T extends ApplicantCreateArgs>(args: SelectSubset<T, ApplicantCreateArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applicants.
     * @param {ApplicantCreateManyArgs} args - Arguments to create many Applicants.
     * @example
     * // Create many Applicants
     * const applicant = await prisma.applicant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicantCreateManyArgs>(args?: SelectSubset<T, ApplicantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applicant.
     * @param {ApplicantDeleteArgs} args - Arguments to delete one Applicant.
     * @example
     * // Delete one Applicant
     * const Applicant = await prisma.applicant.delete({
     *   where: {
     *     // ... filter to delete one Applicant
     *   }
     * })
     * 
     */
    delete<T extends ApplicantDeleteArgs>(args: SelectSubset<T, ApplicantDeleteArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Applicant.
     * @param {ApplicantUpdateArgs} args - Arguments to update one Applicant.
     * @example
     * // Update one Applicant
     * const applicant = await prisma.applicant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicantUpdateArgs>(args: SelectSubset<T, ApplicantUpdateArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applicants.
     * @param {ApplicantDeleteManyArgs} args - Arguments to filter Applicants to delete.
     * @example
     * // Delete a few Applicants
     * const { count } = await prisma.applicant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicantDeleteManyArgs>(args?: SelectSubset<T, ApplicantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicants
     * const applicant = await prisma.applicant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicantUpdateManyArgs>(args: SelectSubset<T, ApplicantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicant.
     * @param {ApplicantUpsertArgs} args - Arguments to update or create a Applicant.
     * @example
     * // Update or create a Applicant
     * const applicant = await prisma.applicant.upsert({
     *   create: {
     *     // ... data to create a Applicant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicant we want to update
     *   }
     * })
     */
    upsert<T extends ApplicantUpsertArgs>(args: SelectSubset<T, ApplicantUpsertArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantCountArgs} args - Arguments to filter Applicants to count.
     * @example
     * // Count the number of Applicants
     * const count = await prisma.applicant.count({
     *   where: {
     *     // ... the filter for the Applicants we want to count
     *   }
     * })
    **/
    count<T extends ApplicantCountArgs>(
      args?: Subset<T, ApplicantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicantAggregateArgs>(args: Subset<T, ApplicantAggregateArgs>): Prisma.PrismaPromise<GetApplicantAggregateType<T>>

    /**
     * Group by Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicantGroupByArgs['orderBy'] }
        : { orderBy?: ApplicantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Applicant model
   */
  readonly fields: ApplicantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Applicant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    educationHistory<T extends Applicant$educationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$educationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    applications<T extends Applicant$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Applicant model
   */ 
  interface ApplicantFieldRefs {
    readonly id: FieldRef<"Applicant", 'String'>
    readonly userId: FieldRef<"Applicant", 'String'>
    readonly firstName: FieldRef<"Applicant", 'String'>
    readonly lastName: FieldRef<"Applicant", 'String'>
    readonly firstNameTh: FieldRef<"Applicant", 'String'>
    readonly lastNameTh: FieldRef<"Applicant", 'String'>
    readonly nationality: FieldRef<"Applicant", 'String'>
    readonly title: FieldRef<"Applicant", 'String'>
    readonly citizenId: FieldRef<"Applicant", 'String'>
    readonly birthDate: FieldRef<"Applicant", 'DateTime'>
    readonly gender: FieldRef<"Applicant", 'Gender'>
    readonly phone: FieldRef<"Applicant", 'String'>
    readonly address: FieldRef<"Applicant", 'String'>
    readonly subDistrict: FieldRef<"Applicant", 'String'>
    readonly district: FieldRef<"Applicant", 'String'>
    readonly province: FieldRef<"Applicant", 'String'>
    readonly zipCode: FieldRef<"Applicant", 'String'>
    readonly profileImageUrl: FieldRef<"Applicant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Applicant findUnique
   */
  export type ApplicantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant findUniqueOrThrow
   */
  export type ApplicantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant findFirst
   */
  export type ApplicantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     */
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant findFirstOrThrow
   */
  export type ApplicantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     */
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant findMany
   */
  export type ApplicantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicants to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant create
   */
  export type ApplicantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The data needed to create a Applicant.
     */
    data: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
  }

  /**
   * Applicant createMany
   */
  export type ApplicantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applicants.
     */
    data: ApplicantCreateManyInput | ApplicantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Applicant update
   */
  export type ApplicantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The data needed to update a Applicant.
     */
    data: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
    /**
     * Choose, which Applicant to update.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant updateMany
   */
  export type ApplicantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applicants.
     */
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyInput>
    /**
     * Filter which Applicants to update
     */
    where?: ApplicantWhereInput
  }

  /**
   * Applicant upsert
   */
  export type ApplicantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The filter to search for the Applicant to update in case it exists.
     */
    where: ApplicantWhereUniqueInput
    /**
     * In case the Applicant found by the `where` argument doesn't exist, create a new Applicant with this data.
     */
    create: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
    /**
     * In case the Applicant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
  }

  /**
   * Applicant delete
   */
  export type ApplicantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter which Applicant to delete.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant deleteMany
   */
  export type ApplicantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applicants to delete
     */
    where?: ApplicantWhereInput
  }

  /**
   * Applicant.educationHistory
   */
  export type Applicant$educationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    where?: EducationHistoryWhereInput
    orderBy?: EducationHistoryOrderByWithRelationInput | EducationHistoryOrderByWithRelationInput[]
    cursor?: EducationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationHistoryScalarFieldEnum | EducationHistoryScalarFieldEnum[]
  }

  /**
   * Applicant.applications
   */
  export type Applicant$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Applicant without action
   */
  export type ApplicantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
  }


  /**
   * Model EducationHistory
   */

  export type AggregateEducationHistory = {
    _count: EducationHistoryCountAggregateOutputType | null
    _avg: EducationHistoryAvgAggregateOutputType | null
    _sum: EducationHistorySumAggregateOutputType | null
    _min: EducationHistoryMinAggregateOutputType | null
    _max: EducationHistoryMaxAggregateOutputType | null
  }

  export type EducationHistoryAvgAggregateOutputType = {
    graduationYear: number | null
  }

  export type EducationHistorySumAggregateOutputType = {
    graduationYear: number | null
  }

  export type EducationHistoryMinAggregateOutputType = {
    id: string | null
    applicantId: string | null
    level: string | null
    degreeName: string | null
    institution: string | null
    gpa: string | null
    graduationYear: number | null
  }

  export type EducationHistoryMaxAggregateOutputType = {
    id: string | null
    applicantId: string | null
    level: string | null
    degreeName: string | null
    institution: string | null
    gpa: string | null
    graduationYear: number | null
  }

  export type EducationHistoryCountAggregateOutputType = {
    id: number
    applicantId: number
    level: number
    degreeName: number
    institution: number
    gpa: number
    graduationYear: number
    _all: number
  }


  export type EducationHistoryAvgAggregateInputType = {
    graduationYear?: true
  }

  export type EducationHistorySumAggregateInputType = {
    graduationYear?: true
  }

  export type EducationHistoryMinAggregateInputType = {
    id?: true
    applicantId?: true
    level?: true
    degreeName?: true
    institution?: true
    gpa?: true
    graduationYear?: true
  }

  export type EducationHistoryMaxAggregateInputType = {
    id?: true
    applicantId?: true
    level?: true
    degreeName?: true
    institution?: true
    gpa?: true
    graduationYear?: true
  }

  export type EducationHistoryCountAggregateInputType = {
    id?: true
    applicantId?: true
    level?: true
    degreeName?: true
    institution?: true
    gpa?: true
    graduationYear?: true
    _all?: true
  }

  export type EducationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationHistory to aggregate.
     */
    where?: EducationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationHistories to fetch.
     */
    orderBy?: EducationHistoryOrderByWithRelationInput | EducationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationHistories
    **/
    _count?: true | EducationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationHistoryMaxAggregateInputType
  }

  export type GetEducationHistoryAggregateType<T extends EducationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationHistory[P]>
      : GetScalarType<T[P], AggregateEducationHistory[P]>
  }




  export type EducationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationHistoryWhereInput
    orderBy?: EducationHistoryOrderByWithAggregationInput | EducationHistoryOrderByWithAggregationInput[]
    by: EducationHistoryScalarFieldEnum[] | EducationHistoryScalarFieldEnum
    having?: EducationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationHistoryCountAggregateInputType | true
    _avg?: EducationHistoryAvgAggregateInputType
    _sum?: EducationHistorySumAggregateInputType
    _min?: EducationHistoryMinAggregateInputType
    _max?: EducationHistoryMaxAggregateInputType
  }

  export type EducationHistoryGroupByOutputType = {
    id: string
    applicantId: string
    level: string
    degreeName: string
    institution: string
    gpa: string | null
    graduationYear: number | null
    _count: EducationHistoryCountAggregateOutputType | null
    _avg: EducationHistoryAvgAggregateOutputType | null
    _sum: EducationHistorySumAggregateOutputType | null
    _min: EducationHistoryMinAggregateOutputType | null
    _max: EducationHistoryMaxAggregateOutputType | null
  }

  type GetEducationHistoryGroupByPayload<T extends EducationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], EducationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type EducationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantId?: boolean
    level?: boolean
    degreeName?: boolean
    institution?: boolean
    gpa?: boolean
    graduationYear?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationHistory"]>


  export type EducationHistorySelectScalar = {
    id?: boolean
    applicantId?: boolean
    level?: boolean
    degreeName?: boolean
    institution?: boolean
    gpa?: boolean
    graduationYear?: boolean
  }

  export type EducationHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }

  export type $EducationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationHistory"
    objects: {
      applicant: Prisma.$ApplicantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicantId: string
      level: string
      degreeName: string
      institution: string
      gpa: string | null
      graduationYear: number | null
    }, ExtArgs["result"]["educationHistory"]>
    composites: {}
  }

  type EducationHistoryGetPayload<S extends boolean | null | undefined | EducationHistoryDefaultArgs> = $Result.GetResult<Prisma.$EducationHistoryPayload, S>

  type EducationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EducationHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EducationHistoryCountAggregateInputType | true
    }

  export interface EducationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationHistory'], meta: { name: 'EducationHistory' } }
    /**
     * Find zero or one EducationHistory that matches the filter.
     * @param {EducationHistoryFindUniqueArgs} args - Arguments to find a EducationHistory
     * @example
     * // Get one EducationHistory
     * const educationHistory = await prisma.educationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationHistoryFindUniqueArgs>(args: SelectSubset<T, EducationHistoryFindUniqueArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EducationHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EducationHistoryFindUniqueOrThrowArgs} args - Arguments to find a EducationHistory
     * @example
     * // Get one EducationHistory
     * const educationHistory = await prisma.educationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EducationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationHistoryFindFirstArgs} args - Arguments to find a EducationHistory
     * @example
     * // Get one EducationHistory
     * const educationHistory = await prisma.educationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationHistoryFindFirstArgs>(args?: SelectSubset<T, EducationHistoryFindFirstArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EducationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationHistoryFindFirstOrThrowArgs} args - Arguments to find a EducationHistory
     * @example
     * // Get one EducationHistory
     * const educationHistory = await prisma.educationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EducationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationHistories
     * const educationHistories = await prisma.educationHistory.findMany()
     * 
     * // Get first 10 EducationHistories
     * const educationHistories = await prisma.educationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationHistoryWithIdOnly = await prisma.educationHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationHistoryFindManyArgs>(args?: SelectSubset<T, EducationHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EducationHistory.
     * @param {EducationHistoryCreateArgs} args - Arguments to create a EducationHistory.
     * @example
     * // Create one EducationHistory
     * const EducationHistory = await prisma.educationHistory.create({
     *   data: {
     *     // ... data to create a EducationHistory
     *   }
     * })
     * 
     */
    create<T extends EducationHistoryCreateArgs>(args: SelectSubset<T, EducationHistoryCreateArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EducationHistories.
     * @param {EducationHistoryCreateManyArgs} args - Arguments to create many EducationHistories.
     * @example
     * // Create many EducationHistories
     * const educationHistory = await prisma.educationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationHistoryCreateManyArgs>(args?: SelectSubset<T, EducationHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EducationHistory.
     * @param {EducationHistoryDeleteArgs} args - Arguments to delete one EducationHistory.
     * @example
     * // Delete one EducationHistory
     * const EducationHistory = await prisma.educationHistory.delete({
     *   where: {
     *     // ... filter to delete one EducationHistory
     *   }
     * })
     * 
     */
    delete<T extends EducationHistoryDeleteArgs>(args: SelectSubset<T, EducationHistoryDeleteArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EducationHistory.
     * @param {EducationHistoryUpdateArgs} args - Arguments to update one EducationHistory.
     * @example
     * // Update one EducationHistory
     * const educationHistory = await prisma.educationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationHistoryUpdateArgs>(args: SelectSubset<T, EducationHistoryUpdateArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EducationHistories.
     * @param {EducationHistoryDeleteManyArgs} args - Arguments to filter EducationHistories to delete.
     * @example
     * // Delete a few EducationHistories
     * const { count } = await prisma.educationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationHistoryDeleteManyArgs>(args?: SelectSubset<T, EducationHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationHistories
     * const educationHistory = await prisma.educationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationHistoryUpdateManyArgs>(args: SelectSubset<T, EducationHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EducationHistory.
     * @param {EducationHistoryUpsertArgs} args - Arguments to update or create a EducationHistory.
     * @example
     * // Update or create a EducationHistory
     * const educationHistory = await prisma.educationHistory.upsert({
     *   create: {
     *     // ... data to create a EducationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationHistory we want to update
     *   }
     * })
     */
    upsert<T extends EducationHistoryUpsertArgs>(args: SelectSubset<T, EducationHistoryUpsertArgs<ExtArgs>>): Prisma__EducationHistoryClient<$Result.GetResult<Prisma.$EducationHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EducationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationHistoryCountArgs} args - Arguments to filter EducationHistories to count.
     * @example
     * // Count the number of EducationHistories
     * const count = await prisma.educationHistory.count({
     *   where: {
     *     // ... the filter for the EducationHistories we want to count
     *   }
     * })
    **/
    count<T extends EducationHistoryCountArgs>(
      args?: Subset<T, EducationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationHistoryAggregateArgs>(args: Subset<T, EducationHistoryAggregateArgs>): Prisma.PrismaPromise<GetEducationHistoryAggregateType<T>>

    /**
     * Group by EducationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: EducationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationHistory model
   */
  readonly fields: EducationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicant<T extends ApplicantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantDefaultArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationHistory model
   */ 
  interface EducationHistoryFieldRefs {
    readonly id: FieldRef<"EducationHistory", 'String'>
    readonly applicantId: FieldRef<"EducationHistory", 'String'>
    readonly level: FieldRef<"EducationHistory", 'String'>
    readonly degreeName: FieldRef<"EducationHistory", 'String'>
    readonly institution: FieldRef<"EducationHistory", 'String'>
    readonly gpa: FieldRef<"EducationHistory", 'String'>
    readonly graduationYear: FieldRef<"EducationHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EducationHistory findUnique
   */
  export type EducationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EducationHistory to fetch.
     */
    where: EducationHistoryWhereUniqueInput
  }

  /**
   * EducationHistory findUniqueOrThrow
   */
  export type EducationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EducationHistory to fetch.
     */
    where: EducationHistoryWhereUniqueInput
  }

  /**
   * EducationHistory findFirst
   */
  export type EducationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EducationHistory to fetch.
     */
    where?: EducationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationHistories to fetch.
     */
    orderBy?: EducationHistoryOrderByWithRelationInput | EducationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationHistories.
     */
    cursor?: EducationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationHistories.
     */
    distinct?: EducationHistoryScalarFieldEnum | EducationHistoryScalarFieldEnum[]
  }

  /**
   * EducationHistory findFirstOrThrow
   */
  export type EducationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EducationHistory to fetch.
     */
    where?: EducationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationHistories to fetch.
     */
    orderBy?: EducationHistoryOrderByWithRelationInput | EducationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationHistories.
     */
    cursor?: EducationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationHistories.
     */
    distinct?: EducationHistoryScalarFieldEnum | EducationHistoryScalarFieldEnum[]
  }

  /**
   * EducationHistory findMany
   */
  export type EducationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EducationHistories to fetch.
     */
    where?: EducationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationHistories to fetch.
     */
    orderBy?: EducationHistoryOrderByWithRelationInput | EducationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationHistories.
     */
    cursor?: EducationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationHistories.
     */
    skip?: number
    distinct?: EducationHistoryScalarFieldEnum | EducationHistoryScalarFieldEnum[]
  }

  /**
   * EducationHistory create
   */
  export type EducationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a EducationHistory.
     */
    data: XOR<EducationHistoryCreateInput, EducationHistoryUncheckedCreateInput>
  }

  /**
   * EducationHistory createMany
   */
  export type EducationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationHistories.
     */
    data: EducationHistoryCreateManyInput | EducationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationHistory update
   */
  export type EducationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a EducationHistory.
     */
    data: XOR<EducationHistoryUpdateInput, EducationHistoryUncheckedUpdateInput>
    /**
     * Choose, which EducationHistory to update.
     */
    where: EducationHistoryWhereUniqueInput
  }

  /**
   * EducationHistory updateMany
   */
  export type EducationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationHistories.
     */
    data: XOR<EducationHistoryUpdateManyMutationInput, EducationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which EducationHistories to update
     */
    where?: EducationHistoryWhereInput
  }

  /**
   * EducationHistory upsert
   */
  export type EducationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the EducationHistory to update in case it exists.
     */
    where: EducationHistoryWhereUniqueInput
    /**
     * In case the EducationHistory found by the `where` argument doesn't exist, create a new EducationHistory with this data.
     */
    create: XOR<EducationHistoryCreateInput, EducationHistoryUncheckedCreateInput>
    /**
     * In case the EducationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationHistoryUpdateInput, EducationHistoryUncheckedUpdateInput>
  }

  /**
   * EducationHistory delete
   */
  export type EducationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
    /**
     * Filter which EducationHistory to delete.
     */
    where: EducationHistoryWhereUniqueInput
  }

  /**
   * EducationHistory deleteMany
   */
  export type EducationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationHistories to delete
     */
    where?: EducationHistoryWhereInput
  }

  /**
   * EducationHistory without action
   */
  export type EducationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationHistory
     */
    select?: EducationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AdmissionTrackType
   */

  export type AggregateAdmissionTrackType = {
    _count: AdmissionTrackTypeCountAggregateOutputType | null
    _avg: AdmissionTrackTypeAvgAggregateOutputType | null
    _sum: AdmissionTrackTypeSumAggregateOutputType | null
    _min: AdmissionTrackTypeMinAggregateOutputType | null
    _max: AdmissionTrackTypeMaxAggregateOutputType | null
  }

  export type AdmissionTrackTypeAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type AdmissionTrackTypeSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type AdmissionTrackTypeMinAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    color: string | null
    icon: string | null
    displayOrder: number | null
    isActive: boolean | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionTrackTypeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    color: string | null
    icon: string | null
    displayOrder: number | null
    isActive: boolean | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionTrackTypeCountAggregateOutputType = {
    id: number
    code: number
    nameTh: number
    nameEn: number
    description: number
    color: number
    icon: number
    displayOrder: number
    isActive: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionTrackTypeAvgAggregateInputType = {
    displayOrder?: true
  }

  export type AdmissionTrackTypeSumAggregateInputType = {
    displayOrder?: true
  }

  export type AdmissionTrackTypeMinAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    color?: true
    icon?: true
    displayOrder?: true
    isActive?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionTrackTypeMaxAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    color?: true
    icon?: true
    displayOrder?: true
    isActive?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionTrackTypeCountAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    color?: true
    icon?: true
    displayOrder?: true
    isActive?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionTrackTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionTrackType to aggregate.
     */
    where?: AdmissionTrackTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTrackTypes to fetch.
     */
    orderBy?: AdmissionTrackTypeOrderByWithRelationInput | AdmissionTrackTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionTrackTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTrackTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTrackTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmissionTrackTypes
    **/
    _count?: true | AdmissionTrackTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionTrackTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionTrackTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionTrackTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionTrackTypeMaxAggregateInputType
  }

  export type GetAdmissionTrackTypeAggregateType<T extends AdmissionTrackTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissionTrackType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissionTrackType[P]>
      : GetScalarType<T[P], AggregateAdmissionTrackType[P]>
  }




  export type AdmissionTrackTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionTrackTypeWhereInput
    orderBy?: AdmissionTrackTypeOrderByWithAggregationInput | AdmissionTrackTypeOrderByWithAggregationInput[]
    by: AdmissionTrackTypeScalarFieldEnum[] | AdmissionTrackTypeScalarFieldEnum
    having?: AdmissionTrackTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionTrackTypeCountAggregateInputType | true
    _avg?: AdmissionTrackTypeAvgAggregateInputType
    _sum?: AdmissionTrackTypeSumAggregateInputType
    _min?: AdmissionTrackTypeMinAggregateInputType
    _max?: AdmissionTrackTypeMaxAggregateInputType
  }

  export type AdmissionTrackTypeGroupByOutputType = {
    id: string
    code: string
    nameTh: string
    nameEn: string
    description: string | null
    color: string
    icon: string
    displayOrder: number
    isActive: boolean
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdmissionTrackTypeCountAggregateOutputType | null
    _avg: AdmissionTrackTypeAvgAggregateOutputType | null
    _sum: AdmissionTrackTypeSumAggregateOutputType | null
    _min: AdmissionTrackTypeMinAggregateOutputType | null
    _max: AdmissionTrackTypeMaxAggregateOutputType | null
  }

  type GetAdmissionTrackTypeGroupByPayload<T extends AdmissionTrackTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionTrackTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionTrackTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionTrackTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionTrackTypeGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionTrackTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    displayOrder?: boolean
    isActive?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tracks?: boolean | AdmissionTrackType$tracksArgs<ExtArgs>
    _count?: boolean | AdmissionTrackTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionTrackType"]>


  export type AdmissionTrackTypeSelectScalar = {
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    displayOrder?: boolean
    isActive?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionTrackTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracks?: boolean | AdmissionTrackType$tracksArgs<ExtArgs>
    _count?: boolean | AdmissionTrackTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdmissionTrackTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmissionTrackType"
    objects: {
      tracks: Prisma.$AdmissionTrackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      nameTh: string
      nameEn: string
      description: string | null
      color: string
      icon: string
      displayOrder: number
      isActive: boolean
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admissionTrackType"]>
    composites: {}
  }

  type AdmissionTrackTypeGetPayload<S extends boolean | null | undefined | AdmissionTrackTypeDefaultArgs> = $Result.GetResult<Prisma.$AdmissionTrackTypePayload, S>

  type AdmissionTrackTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionTrackTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionTrackTypeCountAggregateInputType | true
    }

  export interface AdmissionTrackTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmissionTrackType'], meta: { name: 'AdmissionTrackType' } }
    /**
     * Find zero or one AdmissionTrackType that matches the filter.
     * @param {AdmissionTrackTypeFindUniqueArgs} args - Arguments to find a AdmissionTrackType
     * @example
     * // Get one AdmissionTrackType
     * const admissionTrackType = await prisma.admissionTrackType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionTrackTypeFindUniqueArgs>(args: SelectSubset<T, AdmissionTrackTypeFindUniqueArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdmissionTrackType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionTrackTypeFindUniqueOrThrowArgs} args - Arguments to find a AdmissionTrackType
     * @example
     * // Get one AdmissionTrackType
     * const admissionTrackType = await prisma.admissionTrackType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionTrackTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionTrackTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdmissionTrackType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackTypeFindFirstArgs} args - Arguments to find a AdmissionTrackType
     * @example
     * // Get one AdmissionTrackType
     * const admissionTrackType = await prisma.admissionTrackType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionTrackTypeFindFirstArgs>(args?: SelectSubset<T, AdmissionTrackTypeFindFirstArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdmissionTrackType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackTypeFindFirstOrThrowArgs} args - Arguments to find a AdmissionTrackType
     * @example
     * // Get one AdmissionTrackType
     * const admissionTrackType = await prisma.admissionTrackType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionTrackTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionTrackTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdmissionTrackTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmissionTrackTypes
     * const admissionTrackTypes = await prisma.admissionTrackType.findMany()
     * 
     * // Get first 10 AdmissionTrackTypes
     * const admissionTrackTypes = await prisma.admissionTrackType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionTrackTypeWithIdOnly = await prisma.admissionTrackType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionTrackTypeFindManyArgs>(args?: SelectSubset<T, AdmissionTrackTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdmissionTrackType.
     * @param {AdmissionTrackTypeCreateArgs} args - Arguments to create a AdmissionTrackType.
     * @example
     * // Create one AdmissionTrackType
     * const AdmissionTrackType = await prisma.admissionTrackType.create({
     *   data: {
     *     // ... data to create a AdmissionTrackType
     *   }
     * })
     * 
     */
    create<T extends AdmissionTrackTypeCreateArgs>(args: SelectSubset<T, AdmissionTrackTypeCreateArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdmissionTrackTypes.
     * @param {AdmissionTrackTypeCreateManyArgs} args - Arguments to create many AdmissionTrackTypes.
     * @example
     * // Create many AdmissionTrackTypes
     * const admissionTrackType = await prisma.admissionTrackType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionTrackTypeCreateManyArgs>(args?: SelectSubset<T, AdmissionTrackTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdmissionTrackType.
     * @param {AdmissionTrackTypeDeleteArgs} args - Arguments to delete one AdmissionTrackType.
     * @example
     * // Delete one AdmissionTrackType
     * const AdmissionTrackType = await prisma.admissionTrackType.delete({
     *   where: {
     *     // ... filter to delete one AdmissionTrackType
     *   }
     * })
     * 
     */
    delete<T extends AdmissionTrackTypeDeleteArgs>(args: SelectSubset<T, AdmissionTrackTypeDeleteArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdmissionTrackType.
     * @param {AdmissionTrackTypeUpdateArgs} args - Arguments to update one AdmissionTrackType.
     * @example
     * // Update one AdmissionTrackType
     * const admissionTrackType = await prisma.admissionTrackType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionTrackTypeUpdateArgs>(args: SelectSubset<T, AdmissionTrackTypeUpdateArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdmissionTrackTypes.
     * @param {AdmissionTrackTypeDeleteManyArgs} args - Arguments to filter AdmissionTrackTypes to delete.
     * @example
     * // Delete a few AdmissionTrackTypes
     * const { count } = await prisma.admissionTrackType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionTrackTypeDeleteManyArgs>(args?: SelectSubset<T, AdmissionTrackTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionTrackTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmissionTrackTypes
     * const admissionTrackType = await prisma.admissionTrackType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionTrackTypeUpdateManyArgs>(args: SelectSubset<T, AdmissionTrackTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmissionTrackType.
     * @param {AdmissionTrackTypeUpsertArgs} args - Arguments to update or create a AdmissionTrackType.
     * @example
     * // Update or create a AdmissionTrackType
     * const admissionTrackType = await prisma.admissionTrackType.upsert({
     *   create: {
     *     // ... data to create a AdmissionTrackType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmissionTrackType we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionTrackTypeUpsertArgs>(args: SelectSubset<T, AdmissionTrackTypeUpsertArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdmissionTrackTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackTypeCountArgs} args - Arguments to filter AdmissionTrackTypes to count.
     * @example
     * // Count the number of AdmissionTrackTypes
     * const count = await prisma.admissionTrackType.count({
     *   where: {
     *     // ... the filter for the AdmissionTrackTypes we want to count
     *   }
     * })
    **/
    count<T extends AdmissionTrackTypeCountArgs>(
      args?: Subset<T, AdmissionTrackTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionTrackTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmissionTrackType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionTrackTypeAggregateArgs>(args: Subset<T, AdmissionTrackTypeAggregateArgs>): Prisma.PrismaPromise<GetAdmissionTrackTypeAggregateType<T>>

    /**
     * Group by AdmissionTrackType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionTrackTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionTrackTypeGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionTrackTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionTrackTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionTrackTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmissionTrackType model
   */
  readonly fields: AdmissionTrackTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmissionTrackType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionTrackTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tracks<T extends AdmissionTrackType$tracksArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionTrackType$tracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmissionTrackType model
   */ 
  interface AdmissionTrackTypeFieldRefs {
    readonly id: FieldRef<"AdmissionTrackType", 'String'>
    readonly code: FieldRef<"AdmissionTrackType", 'String'>
    readonly nameTh: FieldRef<"AdmissionTrackType", 'String'>
    readonly nameEn: FieldRef<"AdmissionTrackType", 'String'>
    readonly description: FieldRef<"AdmissionTrackType", 'String'>
    readonly color: FieldRef<"AdmissionTrackType", 'String'>
    readonly icon: FieldRef<"AdmissionTrackType", 'String'>
    readonly displayOrder: FieldRef<"AdmissionTrackType", 'Int'>
    readonly isActive: FieldRef<"AdmissionTrackType", 'Boolean'>
    readonly isSystem: FieldRef<"AdmissionTrackType", 'Boolean'>
    readonly createdAt: FieldRef<"AdmissionTrackType", 'DateTime'>
    readonly updatedAt: FieldRef<"AdmissionTrackType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdmissionTrackType findUnique
   */
  export type AdmissionTrackTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrackType to fetch.
     */
    where: AdmissionTrackTypeWhereUniqueInput
  }

  /**
   * AdmissionTrackType findUniqueOrThrow
   */
  export type AdmissionTrackTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrackType to fetch.
     */
    where: AdmissionTrackTypeWhereUniqueInput
  }

  /**
   * AdmissionTrackType findFirst
   */
  export type AdmissionTrackTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrackType to fetch.
     */
    where?: AdmissionTrackTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTrackTypes to fetch.
     */
    orderBy?: AdmissionTrackTypeOrderByWithRelationInput | AdmissionTrackTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionTrackTypes.
     */
    cursor?: AdmissionTrackTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTrackTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTrackTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionTrackTypes.
     */
    distinct?: AdmissionTrackTypeScalarFieldEnum | AdmissionTrackTypeScalarFieldEnum[]
  }

  /**
   * AdmissionTrackType findFirstOrThrow
   */
  export type AdmissionTrackTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrackType to fetch.
     */
    where?: AdmissionTrackTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTrackTypes to fetch.
     */
    orderBy?: AdmissionTrackTypeOrderByWithRelationInput | AdmissionTrackTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionTrackTypes.
     */
    cursor?: AdmissionTrackTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTrackTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTrackTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionTrackTypes.
     */
    distinct?: AdmissionTrackTypeScalarFieldEnum | AdmissionTrackTypeScalarFieldEnum[]
  }

  /**
   * AdmissionTrackType findMany
   */
  export type AdmissionTrackTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrackTypes to fetch.
     */
    where?: AdmissionTrackTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTrackTypes to fetch.
     */
    orderBy?: AdmissionTrackTypeOrderByWithRelationInput | AdmissionTrackTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmissionTrackTypes.
     */
    cursor?: AdmissionTrackTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTrackTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTrackTypes.
     */
    skip?: number
    distinct?: AdmissionTrackTypeScalarFieldEnum | AdmissionTrackTypeScalarFieldEnum[]
  }

  /**
   * AdmissionTrackType create
   */
  export type AdmissionTrackTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmissionTrackType.
     */
    data: XOR<AdmissionTrackTypeCreateInput, AdmissionTrackTypeUncheckedCreateInput>
  }

  /**
   * AdmissionTrackType createMany
   */
  export type AdmissionTrackTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmissionTrackTypes.
     */
    data: AdmissionTrackTypeCreateManyInput | AdmissionTrackTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionTrackType update
   */
  export type AdmissionTrackTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmissionTrackType.
     */
    data: XOR<AdmissionTrackTypeUpdateInput, AdmissionTrackTypeUncheckedUpdateInput>
    /**
     * Choose, which AdmissionTrackType to update.
     */
    where: AdmissionTrackTypeWhereUniqueInput
  }

  /**
   * AdmissionTrackType updateMany
   */
  export type AdmissionTrackTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmissionTrackTypes.
     */
    data: XOR<AdmissionTrackTypeUpdateManyMutationInput, AdmissionTrackTypeUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionTrackTypes to update
     */
    where?: AdmissionTrackTypeWhereInput
  }

  /**
   * AdmissionTrackType upsert
   */
  export type AdmissionTrackTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmissionTrackType to update in case it exists.
     */
    where: AdmissionTrackTypeWhereUniqueInput
    /**
     * In case the AdmissionTrackType found by the `where` argument doesn't exist, create a new AdmissionTrackType with this data.
     */
    create: XOR<AdmissionTrackTypeCreateInput, AdmissionTrackTypeUncheckedCreateInput>
    /**
     * In case the AdmissionTrackType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionTrackTypeUpdateInput, AdmissionTrackTypeUncheckedUpdateInput>
  }

  /**
   * AdmissionTrackType delete
   */
  export type AdmissionTrackTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
    /**
     * Filter which AdmissionTrackType to delete.
     */
    where: AdmissionTrackTypeWhereUniqueInput
  }

  /**
   * AdmissionTrackType deleteMany
   */
  export type AdmissionTrackTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionTrackTypes to delete
     */
    where?: AdmissionTrackTypeWhereInput
  }

  /**
   * AdmissionTrackType.tracks
   */
  export type AdmissionTrackType$tracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    where?: AdmissionTrackWhereInput
    orderBy?: AdmissionTrackOrderByWithRelationInput | AdmissionTrackOrderByWithRelationInput[]
    cursor?: AdmissionTrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionTrackScalarFieldEnum | AdmissionTrackScalarFieldEnum[]
  }

  /**
   * AdmissionTrackType without action
   */
  export type AdmissionTrackTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrackType
     */
    select?: AdmissionTrackTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackTypeInclude<ExtArgs> | null
  }


  /**
   * Model AdmissionTrack
   */

  export type AggregateAdmissionTrack = {
    _count: AdmissionTrackCountAggregateOutputType | null
    _avg: AdmissionTrackAvgAggregateOutputType | null
    _sum: AdmissionTrackSumAggregateOutputType | null
    _min: AdmissionTrackMinAggregateOutputType | null
    _max: AdmissionTrackMaxAggregateOutputType | null
  }

  export type AdmissionTrackAvgAggregateOutputType = {
    totalSeats: number | null
    filledSeats: number | null
    reservedSeats: number | null
    applicationFee: number | null
    displayOrder: number | null
  }

  export type AdmissionTrackSumAggregateOutputType = {
    totalSeats: number | null
    filledSeats: number | null
    reservedSeats: number | null
    applicationFee: number | null
    displayOrder: number | null
  }

  export type AdmissionTrackMinAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    typeId: string | null
    programId: string | null
    academicYear: string | null
    openDate: Date | null
    closeDate: Date | null
    announceDate: Date | null
    totalSeats: number | null
    filledSeats: number | null
    reservedSeats: number | null
    enableWaitlist: boolean | null
    requirements: string | null
    applicationFee: number | null
    isActive: boolean | null
    isPublished: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionTrackMaxAggregateOutputType = {
    id: string | null
    code: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    typeId: string | null
    programId: string | null
    academicYear: string | null
    openDate: Date | null
    closeDate: Date | null
    announceDate: Date | null
    totalSeats: number | null
    filledSeats: number | null
    reservedSeats: number | null
    enableWaitlist: boolean | null
    requirements: string | null
    applicationFee: number | null
    isActive: boolean | null
    isPublished: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionTrackCountAggregateOutputType = {
    id: number
    code: number
    nameTh: number
    nameEn: number
    description: number
    typeId: number
    programId: number
    academicYear: number
    openDate: number
    closeDate: number
    announceDate: number
    totalSeats: number
    filledSeats: number
    reservedSeats: number
    enableWaitlist: number
    requirements: number
    applicationFee: number
    isActive: number
    isPublished: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionTrackAvgAggregateInputType = {
    totalSeats?: true
    filledSeats?: true
    reservedSeats?: true
    applicationFee?: true
    displayOrder?: true
  }

  export type AdmissionTrackSumAggregateInputType = {
    totalSeats?: true
    filledSeats?: true
    reservedSeats?: true
    applicationFee?: true
    displayOrder?: true
  }

  export type AdmissionTrackMinAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    typeId?: true
    programId?: true
    academicYear?: true
    openDate?: true
    closeDate?: true
    announceDate?: true
    totalSeats?: true
    filledSeats?: true
    reservedSeats?: true
    enableWaitlist?: true
    requirements?: true
    applicationFee?: true
    isActive?: true
    isPublished?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionTrackMaxAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    typeId?: true
    programId?: true
    academicYear?: true
    openDate?: true
    closeDate?: true
    announceDate?: true
    totalSeats?: true
    filledSeats?: true
    reservedSeats?: true
    enableWaitlist?: true
    requirements?: true
    applicationFee?: true
    isActive?: true
    isPublished?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionTrackCountAggregateInputType = {
    id?: true
    code?: true
    nameTh?: true
    nameEn?: true
    description?: true
    typeId?: true
    programId?: true
    academicYear?: true
    openDate?: true
    closeDate?: true
    announceDate?: true
    totalSeats?: true
    filledSeats?: true
    reservedSeats?: true
    enableWaitlist?: true
    requirements?: true
    applicationFee?: true
    isActive?: true
    isPublished?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionTrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionTrack to aggregate.
     */
    where?: AdmissionTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTracks to fetch.
     */
    orderBy?: AdmissionTrackOrderByWithRelationInput | AdmissionTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmissionTracks
    **/
    _count?: true | AdmissionTrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionTrackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionTrackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionTrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionTrackMaxAggregateInputType
  }

  export type GetAdmissionTrackAggregateType<T extends AdmissionTrackAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissionTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissionTrack[P]>
      : GetScalarType<T[P], AggregateAdmissionTrack[P]>
  }




  export type AdmissionTrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionTrackWhereInput
    orderBy?: AdmissionTrackOrderByWithAggregationInput | AdmissionTrackOrderByWithAggregationInput[]
    by: AdmissionTrackScalarFieldEnum[] | AdmissionTrackScalarFieldEnum
    having?: AdmissionTrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionTrackCountAggregateInputType | true
    _avg?: AdmissionTrackAvgAggregateInputType
    _sum?: AdmissionTrackSumAggregateInputType
    _min?: AdmissionTrackMinAggregateInputType
    _max?: AdmissionTrackMaxAggregateInputType
  }

  export type AdmissionTrackGroupByOutputType = {
    id: string
    code: string
    nameTh: string
    nameEn: string
    description: string | null
    typeId: string
    programId: string
    academicYear: string
    openDate: Date
    closeDate: Date
    announceDate: Date | null
    totalSeats: number
    filledSeats: number
    reservedSeats: number | null
    enableWaitlist: boolean
    requirements: string | null
    applicationFee: number | null
    isActive: boolean
    isPublished: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: AdmissionTrackCountAggregateOutputType | null
    _avg: AdmissionTrackAvgAggregateOutputType | null
    _sum: AdmissionTrackSumAggregateOutputType | null
    _min: AdmissionTrackMinAggregateOutputType | null
    _max: AdmissionTrackMaxAggregateOutputType | null
  }

  type GetAdmissionTrackGroupByPayload<T extends AdmissionTrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionTrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionTrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionTrackGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionTrackGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionTrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    typeId?: boolean
    programId?: boolean
    academicYear?: boolean
    openDate?: boolean
    closeDate?: boolean
    announceDate?: boolean
    totalSeats?: boolean
    filledSeats?: boolean
    reservedSeats?: boolean
    enableWaitlist?: boolean
    requirements?: boolean
    applicationFee?: boolean
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean | AdmissionTrackTypeDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    applications?: boolean | AdmissionTrack$applicationsArgs<ExtArgs>
    _count?: boolean | AdmissionTrackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionTrack"]>


  export type AdmissionTrackSelectScalar = {
    id?: boolean
    code?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    typeId?: boolean
    programId?: boolean
    academicYear?: boolean
    openDate?: boolean
    closeDate?: boolean
    announceDate?: boolean
    totalSeats?: boolean
    filledSeats?: boolean
    reservedSeats?: boolean
    enableWaitlist?: boolean
    requirements?: boolean
    applicationFee?: boolean
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionTrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | AdmissionTrackTypeDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    applications?: boolean | AdmissionTrack$applicationsArgs<ExtArgs>
    _count?: boolean | AdmissionTrackCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdmissionTrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmissionTrack"
    objects: {
      type: Prisma.$AdmissionTrackTypePayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs>
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      nameTh: string
      nameEn: string
      description: string | null
      typeId: string
      programId: string
      academicYear: string
      openDate: Date
      closeDate: Date
      announceDate: Date | null
      totalSeats: number
      filledSeats: number
      reservedSeats: number | null
      enableWaitlist: boolean
      requirements: string | null
      applicationFee: number | null
      isActive: boolean
      isPublished: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admissionTrack"]>
    composites: {}
  }

  type AdmissionTrackGetPayload<S extends boolean | null | undefined | AdmissionTrackDefaultArgs> = $Result.GetResult<Prisma.$AdmissionTrackPayload, S>

  type AdmissionTrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionTrackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionTrackCountAggregateInputType | true
    }

  export interface AdmissionTrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmissionTrack'], meta: { name: 'AdmissionTrack' } }
    /**
     * Find zero or one AdmissionTrack that matches the filter.
     * @param {AdmissionTrackFindUniqueArgs} args - Arguments to find a AdmissionTrack
     * @example
     * // Get one AdmissionTrack
     * const admissionTrack = await prisma.admissionTrack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionTrackFindUniqueArgs>(args: SelectSubset<T, AdmissionTrackFindUniqueArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdmissionTrack that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionTrackFindUniqueOrThrowArgs} args - Arguments to find a AdmissionTrack
     * @example
     * // Get one AdmissionTrack
     * const admissionTrack = await prisma.admissionTrack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionTrackFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionTrackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdmissionTrack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackFindFirstArgs} args - Arguments to find a AdmissionTrack
     * @example
     * // Get one AdmissionTrack
     * const admissionTrack = await prisma.admissionTrack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionTrackFindFirstArgs>(args?: SelectSubset<T, AdmissionTrackFindFirstArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdmissionTrack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackFindFirstOrThrowArgs} args - Arguments to find a AdmissionTrack
     * @example
     * // Get one AdmissionTrack
     * const admissionTrack = await prisma.admissionTrack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionTrackFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionTrackFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdmissionTracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmissionTracks
     * const admissionTracks = await prisma.admissionTrack.findMany()
     * 
     * // Get first 10 AdmissionTracks
     * const admissionTracks = await prisma.admissionTrack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionTrackWithIdOnly = await prisma.admissionTrack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionTrackFindManyArgs>(args?: SelectSubset<T, AdmissionTrackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdmissionTrack.
     * @param {AdmissionTrackCreateArgs} args - Arguments to create a AdmissionTrack.
     * @example
     * // Create one AdmissionTrack
     * const AdmissionTrack = await prisma.admissionTrack.create({
     *   data: {
     *     // ... data to create a AdmissionTrack
     *   }
     * })
     * 
     */
    create<T extends AdmissionTrackCreateArgs>(args: SelectSubset<T, AdmissionTrackCreateArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdmissionTracks.
     * @param {AdmissionTrackCreateManyArgs} args - Arguments to create many AdmissionTracks.
     * @example
     * // Create many AdmissionTracks
     * const admissionTrack = await prisma.admissionTrack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionTrackCreateManyArgs>(args?: SelectSubset<T, AdmissionTrackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdmissionTrack.
     * @param {AdmissionTrackDeleteArgs} args - Arguments to delete one AdmissionTrack.
     * @example
     * // Delete one AdmissionTrack
     * const AdmissionTrack = await prisma.admissionTrack.delete({
     *   where: {
     *     // ... filter to delete one AdmissionTrack
     *   }
     * })
     * 
     */
    delete<T extends AdmissionTrackDeleteArgs>(args: SelectSubset<T, AdmissionTrackDeleteArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdmissionTrack.
     * @param {AdmissionTrackUpdateArgs} args - Arguments to update one AdmissionTrack.
     * @example
     * // Update one AdmissionTrack
     * const admissionTrack = await prisma.admissionTrack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionTrackUpdateArgs>(args: SelectSubset<T, AdmissionTrackUpdateArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdmissionTracks.
     * @param {AdmissionTrackDeleteManyArgs} args - Arguments to filter AdmissionTracks to delete.
     * @example
     * // Delete a few AdmissionTracks
     * const { count } = await prisma.admissionTrack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionTrackDeleteManyArgs>(args?: SelectSubset<T, AdmissionTrackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmissionTracks
     * const admissionTrack = await prisma.admissionTrack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionTrackUpdateManyArgs>(args: SelectSubset<T, AdmissionTrackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmissionTrack.
     * @param {AdmissionTrackUpsertArgs} args - Arguments to update or create a AdmissionTrack.
     * @example
     * // Update or create a AdmissionTrack
     * const admissionTrack = await prisma.admissionTrack.upsert({
     *   create: {
     *     // ... data to create a AdmissionTrack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmissionTrack we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionTrackUpsertArgs>(args: SelectSubset<T, AdmissionTrackUpsertArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdmissionTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackCountArgs} args - Arguments to filter AdmissionTracks to count.
     * @example
     * // Count the number of AdmissionTracks
     * const count = await prisma.admissionTrack.count({
     *   where: {
     *     // ... the filter for the AdmissionTracks we want to count
     *   }
     * })
    **/
    count<T extends AdmissionTrackCountArgs>(
      args?: Subset<T, AdmissionTrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionTrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmissionTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionTrackAggregateArgs>(args: Subset<T, AdmissionTrackAggregateArgs>): Prisma.PrismaPromise<GetAdmissionTrackAggregateType<T>>

    /**
     * Group by AdmissionTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionTrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionTrackGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionTrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionTrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmissionTrack model
   */
  readonly fields: AdmissionTrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmissionTrack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionTrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    type<T extends AdmissionTrackTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionTrackTypeDefaultArgs<ExtArgs>>): Prisma__AdmissionTrackTypeClient<$Result.GetResult<Prisma.$AdmissionTrackTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    applications<T extends AdmissionTrack$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionTrack$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmissionTrack model
   */ 
  interface AdmissionTrackFieldRefs {
    readonly id: FieldRef<"AdmissionTrack", 'String'>
    readonly code: FieldRef<"AdmissionTrack", 'String'>
    readonly nameTh: FieldRef<"AdmissionTrack", 'String'>
    readonly nameEn: FieldRef<"AdmissionTrack", 'String'>
    readonly description: FieldRef<"AdmissionTrack", 'String'>
    readonly typeId: FieldRef<"AdmissionTrack", 'String'>
    readonly programId: FieldRef<"AdmissionTrack", 'String'>
    readonly academicYear: FieldRef<"AdmissionTrack", 'String'>
    readonly openDate: FieldRef<"AdmissionTrack", 'DateTime'>
    readonly closeDate: FieldRef<"AdmissionTrack", 'DateTime'>
    readonly announceDate: FieldRef<"AdmissionTrack", 'DateTime'>
    readonly totalSeats: FieldRef<"AdmissionTrack", 'Int'>
    readonly filledSeats: FieldRef<"AdmissionTrack", 'Int'>
    readonly reservedSeats: FieldRef<"AdmissionTrack", 'Int'>
    readonly enableWaitlist: FieldRef<"AdmissionTrack", 'Boolean'>
    readonly requirements: FieldRef<"AdmissionTrack", 'String'>
    readonly applicationFee: FieldRef<"AdmissionTrack", 'Float'>
    readonly isActive: FieldRef<"AdmissionTrack", 'Boolean'>
    readonly isPublished: FieldRef<"AdmissionTrack", 'Boolean'>
    readonly displayOrder: FieldRef<"AdmissionTrack", 'Int'>
    readonly createdAt: FieldRef<"AdmissionTrack", 'DateTime'>
    readonly updatedAt: FieldRef<"AdmissionTrack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdmissionTrack findUnique
   */
  export type AdmissionTrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrack to fetch.
     */
    where: AdmissionTrackWhereUniqueInput
  }

  /**
   * AdmissionTrack findUniqueOrThrow
   */
  export type AdmissionTrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrack to fetch.
     */
    where: AdmissionTrackWhereUniqueInput
  }

  /**
   * AdmissionTrack findFirst
   */
  export type AdmissionTrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrack to fetch.
     */
    where?: AdmissionTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTracks to fetch.
     */
    orderBy?: AdmissionTrackOrderByWithRelationInput | AdmissionTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionTracks.
     */
    cursor?: AdmissionTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionTracks.
     */
    distinct?: AdmissionTrackScalarFieldEnum | AdmissionTrackScalarFieldEnum[]
  }

  /**
   * AdmissionTrack findFirstOrThrow
   */
  export type AdmissionTrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTrack to fetch.
     */
    where?: AdmissionTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTracks to fetch.
     */
    orderBy?: AdmissionTrackOrderByWithRelationInput | AdmissionTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionTracks.
     */
    cursor?: AdmissionTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionTracks.
     */
    distinct?: AdmissionTrackScalarFieldEnum | AdmissionTrackScalarFieldEnum[]
  }

  /**
   * AdmissionTrack findMany
   */
  export type AdmissionTrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTracks to fetch.
     */
    where?: AdmissionTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTracks to fetch.
     */
    orderBy?: AdmissionTrackOrderByWithRelationInput | AdmissionTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmissionTracks.
     */
    cursor?: AdmissionTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTracks.
     */
    skip?: number
    distinct?: AdmissionTrackScalarFieldEnum | AdmissionTrackScalarFieldEnum[]
  }

  /**
   * AdmissionTrack create
   */
  export type AdmissionTrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmissionTrack.
     */
    data: XOR<AdmissionTrackCreateInput, AdmissionTrackUncheckedCreateInput>
  }

  /**
   * AdmissionTrack createMany
   */
  export type AdmissionTrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmissionTracks.
     */
    data: AdmissionTrackCreateManyInput | AdmissionTrackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionTrack update
   */
  export type AdmissionTrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmissionTrack.
     */
    data: XOR<AdmissionTrackUpdateInput, AdmissionTrackUncheckedUpdateInput>
    /**
     * Choose, which AdmissionTrack to update.
     */
    where: AdmissionTrackWhereUniqueInput
  }

  /**
   * AdmissionTrack updateMany
   */
  export type AdmissionTrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmissionTracks.
     */
    data: XOR<AdmissionTrackUpdateManyMutationInput, AdmissionTrackUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionTracks to update
     */
    where?: AdmissionTrackWhereInput
  }

  /**
   * AdmissionTrack upsert
   */
  export type AdmissionTrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmissionTrack to update in case it exists.
     */
    where: AdmissionTrackWhereUniqueInput
    /**
     * In case the AdmissionTrack found by the `where` argument doesn't exist, create a new AdmissionTrack with this data.
     */
    create: XOR<AdmissionTrackCreateInput, AdmissionTrackUncheckedCreateInput>
    /**
     * In case the AdmissionTrack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionTrackUpdateInput, AdmissionTrackUncheckedUpdateInput>
  }

  /**
   * AdmissionTrack delete
   */
  export type AdmissionTrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    /**
     * Filter which AdmissionTrack to delete.
     */
    where: AdmissionTrackWhereUniqueInput
  }

  /**
   * AdmissionTrack deleteMany
   */
  export type AdmissionTrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionTracks to delete
     */
    where?: AdmissionTrackWhereInput
  }

  /**
   * AdmissionTrack.applications
   */
  export type AdmissionTrack$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * AdmissionTrack without action
   */
  export type AdmissionTrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    applicantId: string | null
    trackId: string | null
    programId: string | null
    status: $Enums.ApplicationStatus | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    applicantId: string | null
    trackId: string | null
    programId: string | null
    status: $Enums.ApplicationStatus | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    applicantId: number
    trackId: number
    programId: number
    status: number
    submittedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApplicationMinAggregateInputType = {
    id?: true
    applicantId?: true
    trackId?: true
    programId?: true
    status?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    applicantId?: true
    trackId?: true
    programId?: true
    status?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    applicantId?: true
    trackId?: true
    programId?: true
    status?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    applicantId: string
    trackId: string | null
    programId: string
    status: $Enums.ApplicationStatus
    submittedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantId?: boolean
    trackId?: boolean
    programId?: boolean
    status?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    track?: boolean | Application$trackArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    documents?: boolean | Application$documentsArgs<ExtArgs>
    interview?: boolean | Application$interviewArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>


  export type ApplicationSelectScalar = {
    id?: boolean
    applicantId?: boolean
    trackId?: boolean
    programId?: boolean
    status?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    track?: boolean | Application$trackArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    documents?: boolean | Application$documentsArgs<ExtArgs>
    interview?: boolean | Application$interviewArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      applicant: Prisma.$ApplicantPayload<ExtArgs>
      track: Prisma.$AdmissionTrackPayload<ExtArgs> | null
      program: Prisma.$ProgramPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      interview: Prisma.$InterviewResultPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicantId: string
      trackId: string | null
      programId: string
      status: $Enums.ApplicationStatus
      submittedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicant<T extends ApplicantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantDefaultArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    track<T extends Application$trackArgs<ExtArgs> = {}>(args?: Subset<T, Application$trackArgs<ExtArgs>>): Prisma__AdmissionTrackClient<$Result.GetResult<Prisma.$AdmissionTrackPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documents<T extends Application$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Application$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    interview<T extends Application$interviewArgs<ExtArgs> = {}>(args?: Subset<T, Application$interviewArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */ 
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly applicantId: FieldRef<"Application", 'String'>
    readonly trackId: FieldRef<"Application", 'String'>
    readonly programId: FieldRef<"Application", 'String'>
    readonly status: FieldRef<"Application", 'ApplicationStatus'>
    readonly submittedAt: FieldRef<"Application", 'DateTime'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application.track
   */
  export type Application$trackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTrack
     */
    select?: AdmissionTrackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTrackInclude<ExtArgs> | null
    where?: AdmissionTrackWhereInput
  }

  /**
   * Application.documents
   */
  export type Application$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Application.interview
   */
  export type Application$interviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    where?: InterviewResultWhereInput
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    type: string | null
    url: string | null
    uploadedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    type: string | null
    url: string | null
    uploadedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    applicationId: number
    type: number
    url: number
    uploadedAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    applicationId?: true
    type?: true
    url?: true
    uploadedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    applicationId?: true
    type?: true
    url?: true
    uploadedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    applicationId?: true
    type?: true
    url?: true
    uploadedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    applicationId: string
    type: string
    url: string
    uploadedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    type?: boolean
    url?: boolean
    uploadedAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>


  export type DocumentSelectScalar = {
    id?: boolean
    applicationId?: boolean
    type?: boolean
    url?: boolean
    uploadedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      type: string
      url: string
      uploadedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly applicationId: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model InterviewSlot
   */

  export type AggregateInterviewSlot = {
    _count: InterviewSlotCountAggregateOutputType | null
    _min: InterviewSlotMinAggregateOutputType | null
    _max: InterviewSlotMaxAggregateOutputType | null
  }

  export type InterviewSlotMinAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    coordinatorName: string | null
    coordinatorPhone: string | null
    description: string | null
    programId: string | null
  }

  export type InterviewSlotMaxAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    coordinatorName: string | null
    coordinatorPhone: string | null
    description: string | null
    programId: string | null
  }

  export type InterviewSlotCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    location: number
    coordinatorName: number
    coordinatorPhone: number
    description: number
    programId: number
    _all: number
  }


  export type InterviewSlotMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    location?: true
    coordinatorName?: true
    coordinatorPhone?: true
    description?: true
    programId?: true
  }

  export type InterviewSlotMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    location?: true
    coordinatorName?: true
    coordinatorPhone?: true
    description?: true
    programId?: true
  }

  export type InterviewSlotCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    location?: true
    coordinatorName?: true
    coordinatorPhone?: true
    description?: true
    programId?: true
    _all?: true
  }

  export type InterviewSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSlot to aggregate.
     */
    where?: InterviewSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlots to fetch.
     */
    orderBy?: InterviewSlotOrderByWithRelationInput | InterviewSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewSlots
    **/
    _count?: true | InterviewSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewSlotMaxAggregateInputType
  }

  export type GetInterviewSlotAggregateType<T extends InterviewSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewSlot[P]>
      : GetScalarType<T[P], AggregateInterviewSlot[P]>
  }




  export type InterviewSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSlotWhereInput
    orderBy?: InterviewSlotOrderByWithAggregationInput | InterviewSlotOrderByWithAggregationInput[]
    by: InterviewSlotScalarFieldEnum[] | InterviewSlotScalarFieldEnum
    having?: InterviewSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewSlotCountAggregateInputType | true
    _min?: InterviewSlotMinAggregateInputType
    _max?: InterviewSlotMaxAggregateInputType
  }

  export type InterviewSlotGroupByOutputType = {
    id: string
    startTime: Date
    endTime: Date
    location: string | null
    coordinatorName: string | null
    coordinatorPhone: string | null
    description: string | null
    programId: string | null
    _count: InterviewSlotCountAggregateOutputType | null
    _min: InterviewSlotMinAggregateOutputType | null
    _max: InterviewSlotMaxAggregateOutputType | null
  }

  type GetInterviewSlotGroupByPayload<T extends InterviewSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewSlotGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewSlotGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    coordinatorName?: boolean
    coordinatorPhone?: boolean
    description?: boolean
    programId?: boolean
    program?: boolean | InterviewSlot$programArgs<ExtArgs>
    interviewResults?: boolean | InterviewSlot$interviewResultsArgs<ExtArgs>
    interviewers?: boolean | InterviewSlot$interviewersArgs<ExtArgs>
    _count?: boolean | InterviewSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewSlot"]>


  export type InterviewSlotSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    coordinatorName?: boolean
    coordinatorPhone?: boolean
    description?: boolean
    programId?: boolean
  }

  export type InterviewSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | InterviewSlot$programArgs<ExtArgs>
    interviewResults?: boolean | InterviewSlot$interviewResultsArgs<ExtArgs>
    interviewers?: boolean | InterviewSlot$interviewersArgs<ExtArgs>
    _count?: boolean | InterviewSlotCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InterviewSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewSlot"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs> | null
      interviewResults: Prisma.$InterviewResultPayload<ExtArgs>[]
      interviewers: Prisma.$InterviewSlotInterviewerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startTime: Date
      endTime: Date
      location: string | null
      coordinatorName: string | null
      coordinatorPhone: string | null
      description: string | null
      programId: string | null
    }, ExtArgs["result"]["interviewSlot"]>
    composites: {}
  }

  type InterviewSlotGetPayload<S extends boolean | null | undefined | InterviewSlotDefaultArgs> = $Result.GetResult<Prisma.$InterviewSlotPayload, S>

  type InterviewSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewSlotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewSlotCountAggregateInputType | true
    }

  export interface InterviewSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewSlot'], meta: { name: 'InterviewSlot' } }
    /**
     * Find zero or one InterviewSlot that matches the filter.
     * @param {InterviewSlotFindUniqueArgs} args - Arguments to find a InterviewSlot
     * @example
     * // Get one InterviewSlot
     * const interviewSlot = await prisma.interviewSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewSlotFindUniqueArgs>(args: SelectSubset<T, InterviewSlotFindUniqueArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterviewSlot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewSlotFindUniqueOrThrowArgs} args - Arguments to find a InterviewSlot
     * @example
     * // Get one InterviewSlot
     * const interviewSlot = await prisma.interviewSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterviewSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotFindFirstArgs} args - Arguments to find a InterviewSlot
     * @example
     * // Get one InterviewSlot
     * const interviewSlot = await prisma.interviewSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewSlotFindFirstArgs>(args?: SelectSubset<T, InterviewSlotFindFirstArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterviewSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotFindFirstOrThrowArgs} args - Arguments to find a InterviewSlot
     * @example
     * // Get one InterviewSlot
     * const interviewSlot = await prisma.interviewSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterviewSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewSlots
     * const interviewSlots = await prisma.interviewSlot.findMany()
     * 
     * // Get first 10 InterviewSlots
     * const interviewSlots = await prisma.interviewSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewSlotWithIdOnly = await prisma.interviewSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewSlotFindManyArgs>(args?: SelectSubset<T, InterviewSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterviewSlot.
     * @param {InterviewSlotCreateArgs} args - Arguments to create a InterviewSlot.
     * @example
     * // Create one InterviewSlot
     * const InterviewSlot = await prisma.interviewSlot.create({
     *   data: {
     *     // ... data to create a InterviewSlot
     *   }
     * })
     * 
     */
    create<T extends InterviewSlotCreateArgs>(args: SelectSubset<T, InterviewSlotCreateArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterviewSlots.
     * @param {InterviewSlotCreateManyArgs} args - Arguments to create many InterviewSlots.
     * @example
     * // Create many InterviewSlots
     * const interviewSlot = await prisma.interviewSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewSlotCreateManyArgs>(args?: SelectSubset<T, InterviewSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InterviewSlot.
     * @param {InterviewSlotDeleteArgs} args - Arguments to delete one InterviewSlot.
     * @example
     * // Delete one InterviewSlot
     * const InterviewSlot = await prisma.interviewSlot.delete({
     *   where: {
     *     // ... filter to delete one InterviewSlot
     *   }
     * })
     * 
     */
    delete<T extends InterviewSlotDeleteArgs>(args: SelectSubset<T, InterviewSlotDeleteArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterviewSlot.
     * @param {InterviewSlotUpdateArgs} args - Arguments to update one InterviewSlot.
     * @example
     * // Update one InterviewSlot
     * const interviewSlot = await prisma.interviewSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewSlotUpdateArgs>(args: SelectSubset<T, InterviewSlotUpdateArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterviewSlots.
     * @param {InterviewSlotDeleteManyArgs} args - Arguments to filter InterviewSlots to delete.
     * @example
     * // Delete a few InterviewSlots
     * const { count } = await prisma.interviewSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewSlotDeleteManyArgs>(args?: SelectSubset<T, InterviewSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewSlots
     * const interviewSlot = await prisma.interviewSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewSlotUpdateManyArgs>(args: SelectSubset<T, InterviewSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewSlot.
     * @param {InterviewSlotUpsertArgs} args - Arguments to update or create a InterviewSlot.
     * @example
     * // Update or create a InterviewSlot
     * const interviewSlot = await prisma.interviewSlot.upsert({
     *   create: {
     *     // ... data to create a InterviewSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewSlot we want to update
     *   }
     * })
     */
    upsert<T extends InterviewSlotUpsertArgs>(args: SelectSubset<T, InterviewSlotUpsertArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterviewSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotCountArgs} args - Arguments to filter InterviewSlots to count.
     * @example
     * // Count the number of InterviewSlots
     * const count = await prisma.interviewSlot.count({
     *   where: {
     *     // ... the filter for the InterviewSlots we want to count
     *   }
     * })
    **/
    count<T extends InterviewSlotCountArgs>(
      args?: Subset<T, InterviewSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewSlotAggregateArgs>(args: Subset<T, InterviewSlotAggregateArgs>): Prisma.PrismaPromise<GetInterviewSlotAggregateType<T>>

    /**
     * Group by InterviewSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewSlotGroupByArgs['orderBy'] }
        : { orderBy?: InterviewSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewSlot model
   */
  readonly fields: InterviewSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends InterviewSlot$programArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSlot$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    interviewResults<T extends InterviewSlot$interviewResultsArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSlot$interviewResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findMany"> | Null>
    interviewers<T extends InterviewSlot$interviewersArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSlot$interviewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewSlot model
   */ 
  interface InterviewSlotFieldRefs {
    readonly id: FieldRef<"InterviewSlot", 'String'>
    readonly startTime: FieldRef<"InterviewSlot", 'DateTime'>
    readonly endTime: FieldRef<"InterviewSlot", 'DateTime'>
    readonly location: FieldRef<"InterviewSlot", 'String'>
    readonly coordinatorName: FieldRef<"InterviewSlot", 'String'>
    readonly coordinatorPhone: FieldRef<"InterviewSlot", 'String'>
    readonly description: FieldRef<"InterviewSlot", 'String'>
    readonly programId: FieldRef<"InterviewSlot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InterviewSlot findUnique
   */
  export type InterviewSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlot to fetch.
     */
    where: InterviewSlotWhereUniqueInput
  }

  /**
   * InterviewSlot findUniqueOrThrow
   */
  export type InterviewSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlot to fetch.
     */
    where: InterviewSlotWhereUniqueInput
  }

  /**
   * InterviewSlot findFirst
   */
  export type InterviewSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlot to fetch.
     */
    where?: InterviewSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlots to fetch.
     */
    orderBy?: InterviewSlotOrderByWithRelationInput | InterviewSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSlots.
     */
    cursor?: InterviewSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSlots.
     */
    distinct?: InterviewSlotScalarFieldEnum | InterviewSlotScalarFieldEnum[]
  }

  /**
   * InterviewSlot findFirstOrThrow
   */
  export type InterviewSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlot to fetch.
     */
    where?: InterviewSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlots to fetch.
     */
    orderBy?: InterviewSlotOrderByWithRelationInput | InterviewSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSlots.
     */
    cursor?: InterviewSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSlots.
     */
    distinct?: InterviewSlotScalarFieldEnum | InterviewSlotScalarFieldEnum[]
  }

  /**
   * InterviewSlot findMany
   */
  export type InterviewSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlots to fetch.
     */
    where?: InterviewSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlots to fetch.
     */
    orderBy?: InterviewSlotOrderByWithRelationInput | InterviewSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewSlots.
     */
    cursor?: InterviewSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlots.
     */
    skip?: number
    distinct?: InterviewSlotScalarFieldEnum | InterviewSlotScalarFieldEnum[]
  }

  /**
   * InterviewSlot create
   */
  export type InterviewSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewSlot.
     */
    data: XOR<InterviewSlotCreateInput, InterviewSlotUncheckedCreateInput>
  }

  /**
   * InterviewSlot createMany
   */
  export type InterviewSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewSlots.
     */
    data: InterviewSlotCreateManyInput | InterviewSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewSlot update
   */
  export type InterviewSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewSlot.
     */
    data: XOR<InterviewSlotUpdateInput, InterviewSlotUncheckedUpdateInput>
    /**
     * Choose, which InterviewSlot to update.
     */
    where: InterviewSlotWhereUniqueInput
  }

  /**
   * InterviewSlot updateMany
   */
  export type InterviewSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewSlots.
     */
    data: XOR<InterviewSlotUpdateManyMutationInput, InterviewSlotUncheckedUpdateManyInput>
    /**
     * Filter which InterviewSlots to update
     */
    where?: InterviewSlotWhereInput
  }

  /**
   * InterviewSlot upsert
   */
  export type InterviewSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewSlot to update in case it exists.
     */
    where: InterviewSlotWhereUniqueInput
    /**
     * In case the InterviewSlot found by the `where` argument doesn't exist, create a new InterviewSlot with this data.
     */
    create: XOR<InterviewSlotCreateInput, InterviewSlotUncheckedCreateInput>
    /**
     * In case the InterviewSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewSlotUpdateInput, InterviewSlotUncheckedUpdateInput>
  }

  /**
   * InterviewSlot delete
   */
  export type InterviewSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
    /**
     * Filter which InterviewSlot to delete.
     */
    where: InterviewSlotWhereUniqueInput
  }

  /**
   * InterviewSlot deleteMany
   */
  export type InterviewSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSlots to delete
     */
    where?: InterviewSlotWhereInput
  }

  /**
   * InterviewSlot.program
   */
  export type InterviewSlot$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * InterviewSlot.interviewResults
   */
  export type InterviewSlot$interviewResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    where?: InterviewResultWhereInput
    orderBy?: InterviewResultOrderByWithRelationInput | InterviewResultOrderByWithRelationInput[]
    cursor?: InterviewResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewResultScalarFieldEnum | InterviewResultScalarFieldEnum[]
  }

  /**
   * InterviewSlot.interviewers
   */
  export type InterviewSlot$interviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    where?: InterviewSlotInterviewerWhereInput
    orderBy?: InterviewSlotInterviewerOrderByWithRelationInput | InterviewSlotInterviewerOrderByWithRelationInput[]
    cursor?: InterviewSlotInterviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewSlotInterviewerScalarFieldEnum | InterviewSlotInterviewerScalarFieldEnum[]
  }

  /**
   * InterviewSlot without action
   */
  export type InterviewSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlot
     */
    select?: InterviewSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInclude<ExtArgs> | null
  }


  /**
   * Model InterviewSlotInterviewer
   */

  export type AggregateInterviewSlotInterviewer = {
    _count: InterviewSlotInterviewerCountAggregateOutputType | null
    _min: InterviewSlotInterviewerMinAggregateOutputType | null
    _max: InterviewSlotInterviewerMaxAggregateOutputType | null
  }

  export type InterviewSlotInterviewerMinAggregateOutputType = {
    id: string | null
    slotId: string | null
    interviewerId: string | null
  }

  export type InterviewSlotInterviewerMaxAggregateOutputType = {
    id: string | null
    slotId: string | null
    interviewerId: string | null
  }

  export type InterviewSlotInterviewerCountAggregateOutputType = {
    id: number
    slotId: number
    interviewerId: number
    _all: number
  }


  export type InterviewSlotInterviewerMinAggregateInputType = {
    id?: true
    slotId?: true
    interviewerId?: true
  }

  export type InterviewSlotInterviewerMaxAggregateInputType = {
    id?: true
    slotId?: true
    interviewerId?: true
  }

  export type InterviewSlotInterviewerCountAggregateInputType = {
    id?: true
    slotId?: true
    interviewerId?: true
    _all?: true
  }

  export type InterviewSlotInterviewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSlotInterviewer to aggregate.
     */
    where?: InterviewSlotInterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlotInterviewers to fetch.
     */
    orderBy?: InterviewSlotInterviewerOrderByWithRelationInput | InterviewSlotInterviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewSlotInterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlotInterviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlotInterviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewSlotInterviewers
    **/
    _count?: true | InterviewSlotInterviewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewSlotInterviewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewSlotInterviewerMaxAggregateInputType
  }

  export type GetInterviewSlotInterviewerAggregateType<T extends InterviewSlotInterviewerAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewSlotInterviewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewSlotInterviewer[P]>
      : GetScalarType<T[P], AggregateInterviewSlotInterviewer[P]>
  }




  export type InterviewSlotInterviewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSlotInterviewerWhereInput
    orderBy?: InterviewSlotInterviewerOrderByWithAggregationInput | InterviewSlotInterviewerOrderByWithAggregationInput[]
    by: InterviewSlotInterviewerScalarFieldEnum[] | InterviewSlotInterviewerScalarFieldEnum
    having?: InterviewSlotInterviewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewSlotInterviewerCountAggregateInputType | true
    _min?: InterviewSlotInterviewerMinAggregateInputType
    _max?: InterviewSlotInterviewerMaxAggregateInputType
  }

  export type InterviewSlotInterviewerGroupByOutputType = {
    id: string
    slotId: string
    interviewerId: string
    _count: InterviewSlotInterviewerCountAggregateOutputType | null
    _min: InterviewSlotInterviewerMinAggregateOutputType | null
    _max: InterviewSlotInterviewerMaxAggregateOutputType | null
  }

  type GetInterviewSlotInterviewerGroupByPayload<T extends InterviewSlotInterviewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewSlotInterviewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewSlotInterviewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewSlotInterviewerGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewSlotInterviewerGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSlotInterviewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotId?: boolean
    interviewerId?: boolean
    slot?: boolean | InterviewSlotDefaultArgs<ExtArgs>
    interviewer?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewSlotInterviewer"]>


  export type InterviewSlotInterviewerSelectScalar = {
    id?: boolean
    slotId?: boolean
    interviewerId?: boolean
  }

  export type InterviewSlotInterviewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slot?: boolean | InterviewSlotDefaultArgs<ExtArgs>
    interviewer?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $InterviewSlotInterviewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewSlotInterviewer"
    objects: {
      slot: Prisma.$InterviewSlotPayload<ExtArgs>
      interviewer: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slotId: string
      interviewerId: string
    }, ExtArgs["result"]["interviewSlotInterviewer"]>
    composites: {}
  }

  type InterviewSlotInterviewerGetPayload<S extends boolean | null | undefined | InterviewSlotInterviewerDefaultArgs> = $Result.GetResult<Prisma.$InterviewSlotInterviewerPayload, S>

  type InterviewSlotInterviewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewSlotInterviewerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewSlotInterviewerCountAggregateInputType | true
    }

  export interface InterviewSlotInterviewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewSlotInterviewer'], meta: { name: 'InterviewSlotInterviewer' } }
    /**
     * Find zero or one InterviewSlotInterviewer that matches the filter.
     * @param {InterviewSlotInterviewerFindUniqueArgs} args - Arguments to find a InterviewSlotInterviewer
     * @example
     * // Get one InterviewSlotInterviewer
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewSlotInterviewerFindUniqueArgs>(args: SelectSubset<T, InterviewSlotInterviewerFindUniqueArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterviewSlotInterviewer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewSlotInterviewerFindUniqueOrThrowArgs} args - Arguments to find a InterviewSlotInterviewer
     * @example
     * // Get one InterviewSlotInterviewer
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewSlotInterviewerFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewSlotInterviewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterviewSlotInterviewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotInterviewerFindFirstArgs} args - Arguments to find a InterviewSlotInterviewer
     * @example
     * // Get one InterviewSlotInterviewer
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewSlotInterviewerFindFirstArgs>(args?: SelectSubset<T, InterviewSlotInterviewerFindFirstArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterviewSlotInterviewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotInterviewerFindFirstOrThrowArgs} args - Arguments to find a InterviewSlotInterviewer
     * @example
     * // Get one InterviewSlotInterviewer
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewSlotInterviewerFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewSlotInterviewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterviewSlotInterviewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotInterviewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewSlotInterviewers
     * const interviewSlotInterviewers = await prisma.interviewSlotInterviewer.findMany()
     * 
     * // Get first 10 InterviewSlotInterviewers
     * const interviewSlotInterviewers = await prisma.interviewSlotInterviewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewSlotInterviewerWithIdOnly = await prisma.interviewSlotInterviewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewSlotInterviewerFindManyArgs>(args?: SelectSubset<T, InterviewSlotInterviewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterviewSlotInterviewer.
     * @param {InterviewSlotInterviewerCreateArgs} args - Arguments to create a InterviewSlotInterviewer.
     * @example
     * // Create one InterviewSlotInterviewer
     * const InterviewSlotInterviewer = await prisma.interviewSlotInterviewer.create({
     *   data: {
     *     // ... data to create a InterviewSlotInterviewer
     *   }
     * })
     * 
     */
    create<T extends InterviewSlotInterviewerCreateArgs>(args: SelectSubset<T, InterviewSlotInterviewerCreateArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterviewSlotInterviewers.
     * @param {InterviewSlotInterviewerCreateManyArgs} args - Arguments to create many InterviewSlotInterviewers.
     * @example
     * // Create many InterviewSlotInterviewers
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewSlotInterviewerCreateManyArgs>(args?: SelectSubset<T, InterviewSlotInterviewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InterviewSlotInterviewer.
     * @param {InterviewSlotInterviewerDeleteArgs} args - Arguments to delete one InterviewSlotInterviewer.
     * @example
     * // Delete one InterviewSlotInterviewer
     * const InterviewSlotInterviewer = await prisma.interviewSlotInterviewer.delete({
     *   where: {
     *     // ... filter to delete one InterviewSlotInterviewer
     *   }
     * })
     * 
     */
    delete<T extends InterviewSlotInterviewerDeleteArgs>(args: SelectSubset<T, InterviewSlotInterviewerDeleteArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterviewSlotInterviewer.
     * @param {InterviewSlotInterviewerUpdateArgs} args - Arguments to update one InterviewSlotInterviewer.
     * @example
     * // Update one InterviewSlotInterviewer
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewSlotInterviewerUpdateArgs>(args: SelectSubset<T, InterviewSlotInterviewerUpdateArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterviewSlotInterviewers.
     * @param {InterviewSlotInterviewerDeleteManyArgs} args - Arguments to filter InterviewSlotInterviewers to delete.
     * @example
     * // Delete a few InterviewSlotInterviewers
     * const { count } = await prisma.interviewSlotInterviewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewSlotInterviewerDeleteManyArgs>(args?: SelectSubset<T, InterviewSlotInterviewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewSlotInterviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotInterviewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewSlotInterviewers
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewSlotInterviewerUpdateManyArgs>(args: SelectSubset<T, InterviewSlotInterviewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewSlotInterviewer.
     * @param {InterviewSlotInterviewerUpsertArgs} args - Arguments to update or create a InterviewSlotInterviewer.
     * @example
     * // Update or create a InterviewSlotInterviewer
     * const interviewSlotInterviewer = await prisma.interviewSlotInterviewer.upsert({
     *   create: {
     *     // ... data to create a InterviewSlotInterviewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewSlotInterviewer we want to update
     *   }
     * })
     */
    upsert<T extends InterviewSlotInterviewerUpsertArgs>(args: SelectSubset<T, InterviewSlotInterviewerUpsertArgs<ExtArgs>>): Prisma__InterviewSlotInterviewerClient<$Result.GetResult<Prisma.$InterviewSlotInterviewerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterviewSlotInterviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotInterviewerCountArgs} args - Arguments to filter InterviewSlotInterviewers to count.
     * @example
     * // Count the number of InterviewSlotInterviewers
     * const count = await prisma.interviewSlotInterviewer.count({
     *   where: {
     *     // ... the filter for the InterviewSlotInterviewers we want to count
     *   }
     * })
    **/
    count<T extends InterviewSlotInterviewerCountArgs>(
      args?: Subset<T, InterviewSlotInterviewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewSlotInterviewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewSlotInterviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotInterviewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewSlotInterviewerAggregateArgs>(args: Subset<T, InterviewSlotInterviewerAggregateArgs>): Prisma.PrismaPromise<GetInterviewSlotInterviewerAggregateType<T>>

    /**
     * Group by InterviewSlotInterviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSlotInterviewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewSlotInterviewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewSlotInterviewerGroupByArgs['orderBy'] }
        : { orderBy?: InterviewSlotInterviewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewSlotInterviewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewSlotInterviewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewSlotInterviewer model
   */
  readonly fields: InterviewSlotInterviewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewSlotInterviewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewSlotInterviewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    slot<T extends InterviewSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSlotDefaultArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    interviewer<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewSlotInterviewer model
   */ 
  interface InterviewSlotInterviewerFieldRefs {
    readonly id: FieldRef<"InterviewSlotInterviewer", 'String'>
    readonly slotId: FieldRef<"InterviewSlotInterviewer", 'String'>
    readonly interviewerId: FieldRef<"InterviewSlotInterviewer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InterviewSlotInterviewer findUnique
   */
  export type InterviewSlotInterviewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlotInterviewer to fetch.
     */
    where: InterviewSlotInterviewerWhereUniqueInput
  }

  /**
   * InterviewSlotInterviewer findUniqueOrThrow
   */
  export type InterviewSlotInterviewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlotInterviewer to fetch.
     */
    where: InterviewSlotInterviewerWhereUniqueInput
  }

  /**
   * InterviewSlotInterviewer findFirst
   */
  export type InterviewSlotInterviewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlotInterviewer to fetch.
     */
    where?: InterviewSlotInterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlotInterviewers to fetch.
     */
    orderBy?: InterviewSlotInterviewerOrderByWithRelationInput | InterviewSlotInterviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSlotInterviewers.
     */
    cursor?: InterviewSlotInterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlotInterviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlotInterviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSlotInterviewers.
     */
    distinct?: InterviewSlotInterviewerScalarFieldEnum | InterviewSlotInterviewerScalarFieldEnum[]
  }

  /**
   * InterviewSlotInterviewer findFirstOrThrow
   */
  export type InterviewSlotInterviewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlotInterviewer to fetch.
     */
    where?: InterviewSlotInterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlotInterviewers to fetch.
     */
    orderBy?: InterviewSlotInterviewerOrderByWithRelationInput | InterviewSlotInterviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSlotInterviewers.
     */
    cursor?: InterviewSlotInterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlotInterviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlotInterviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSlotInterviewers.
     */
    distinct?: InterviewSlotInterviewerScalarFieldEnum | InterviewSlotInterviewerScalarFieldEnum[]
  }

  /**
   * InterviewSlotInterviewer findMany
   */
  export type InterviewSlotInterviewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSlotInterviewers to fetch.
     */
    where?: InterviewSlotInterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSlotInterviewers to fetch.
     */
    orderBy?: InterviewSlotInterviewerOrderByWithRelationInput | InterviewSlotInterviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewSlotInterviewers.
     */
    cursor?: InterviewSlotInterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSlotInterviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSlotInterviewers.
     */
    skip?: number
    distinct?: InterviewSlotInterviewerScalarFieldEnum | InterviewSlotInterviewerScalarFieldEnum[]
  }

  /**
   * InterviewSlotInterviewer create
   */
  export type InterviewSlotInterviewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewSlotInterviewer.
     */
    data: XOR<InterviewSlotInterviewerCreateInput, InterviewSlotInterviewerUncheckedCreateInput>
  }

  /**
   * InterviewSlotInterviewer createMany
   */
  export type InterviewSlotInterviewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewSlotInterviewers.
     */
    data: InterviewSlotInterviewerCreateManyInput | InterviewSlotInterviewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewSlotInterviewer update
   */
  export type InterviewSlotInterviewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewSlotInterviewer.
     */
    data: XOR<InterviewSlotInterviewerUpdateInput, InterviewSlotInterviewerUncheckedUpdateInput>
    /**
     * Choose, which InterviewSlotInterviewer to update.
     */
    where: InterviewSlotInterviewerWhereUniqueInput
  }

  /**
   * InterviewSlotInterviewer updateMany
   */
  export type InterviewSlotInterviewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewSlotInterviewers.
     */
    data: XOR<InterviewSlotInterviewerUpdateManyMutationInput, InterviewSlotInterviewerUncheckedUpdateManyInput>
    /**
     * Filter which InterviewSlotInterviewers to update
     */
    where?: InterviewSlotInterviewerWhereInput
  }

  /**
   * InterviewSlotInterviewer upsert
   */
  export type InterviewSlotInterviewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewSlotInterviewer to update in case it exists.
     */
    where: InterviewSlotInterviewerWhereUniqueInput
    /**
     * In case the InterviewSlotInterviewer found by the `where` argument doesn't exist, create a new InterviewSlotInterviewer with this data.
     */
    create: XOR<InterviewSlotInterviewerCreateInput, InterviewSlotInterviewerUncheckedCreateInput>
    /**
     * In case the InterviewSlotInterviewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewSlotInterviewerUpdateInput, InterviewSlotInterviewerUncheckedUpdateInput>
  }

  /**
   * InterviewSlotInterviewer delete
   */
  export type InterviewSlotInterviewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
    /**
     * Filter which InterviewSlotInterviewer to delete.
     */
    where: InterviewSlotInterviewerWhereUniqueInput
  }

  /**
   * InterviewSlotInterviewer deleteMany
   */
  export type InterviewSlotInterviewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSlotInterviewers to delete
     */
    where?: InterviewSlotInterviewerWhereInput
  }

  /**
   * InterviewSlotInterviewer without action
   */
  export type InterviewSlotInterviewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSlotInterviewer
     */
    select?: InterviewSlotInterviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSlotInterviewerInclude<ExtArgs> | null
  }


  /**
   * Model InterviewResult
   */

  export type AggregateInterviewResult = {
    _count: InterviewResultCountAggregateOutputType | null
    _avg: InterviewResultAvgAggregateOutputType | null
    _sum: InterviewResultSumAggregateOutputType | null
    _min: InterviewResultMinAggregateOutputType | null
    _max: InterviewResultMaxAggregateOutputType | null
  }

  export type InterviewResultAvgAggregateOutputType = {
    score: number | null
  }

  export type InterviewResultSumAggregateOutputType = {
    score: number | null
  }

  export type InterviewResultMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    slotId: string | null
    score: number | null
    comments: string | null
    isPassed: boolean | null
    confirmedAt: Date | null
    rescheduleRequested: boolean | null
    rescheduleReason: string | null
    checkedInAt: Date | null
  }

  export type InterviewResultMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    slotId: string | null
    score: number | null
    comments: string | null
    isPassed: boolean | null
    confirmedAt: Date | null
    rescheduleRequested: boolean | null
    rescheduleReason: string | null
    checkedInAt: Date | null
  }

  export type InterviewResultCountAggregateOutputType = {
    id: number
    applicationId: number
    slotId: number
    score: number
    comments: number
    isPassed: number
    confirmedAt: number
    rescheduleRequested: number
    rescheduleReason: number
    checkedInAt: number
    _all: number
  }


  export type InterviewResultAvgAggregateInputType = {
    score?: true
  }

  export type InterviewResultSumAggregateInputType = {
    score?: true
  }

  export type InterviewResultMinAggregateInputType = {
    id?: true
    applicationId?: true
    slotId?: true
    score?: true
    comments?: true
    isPassed?: true
    confirmedAt?: true
    rescheduleRequested?: true
    rescheduleReason?: true
    checkedInAt?: true
  }

  export type InterviewResultMaxAggregateInputType = {
    id?: true
    applicationId?: true
    slotId?: true
    score?: true
    comments?: true
    isPassed?: true
    confirmedAt?: true
    rescheduleRequested?: true
    rescheduleReason?: true
    checkedInAt?: true
  }

  export type InterviewResultCountAggregateInputType = {
    id?: true
    applicationId?: true
    slotId?: true
    score?: true
    comments?: true
    isPassed?: true
    confirmedAt?: true
    rescheduleRequested?: true
    rescheduleReason?: true
    checkedInAt?: true
    _all?: true
  }

  export type InterviewResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewResult to aggregate.
     */
    where?: InterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResults to fetch.
     */
    orderBy?: InterviewResultOrderByWithRelationInput | InterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewResults
    **/
    _count?: true | InterviewResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewResultMaxAggregateInputType
  }

  export type GetInterviewResultAggregateType<T extends InterviewResultAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewResult[P]>
      : GetScalarType<T[P], AggregateInterviewResult[P]>
  }




  export type InterviewResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewResultWhereInput
    orderBy?: InterviewResultOrderByWithAggregationInput | InterviewResultOrderByWithAggregationInput[]
    by: InterviewResultScalarFieldEnum[] | InterviewResultScalarFieldEnum
    having?: InterviewResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewResultCountAggregateInputType | true
    _avg?: InterviewResultAvgAggregateInputType
    _sum?: InterviewResultSumAggregateInputType
    _min?: InterviewResultMinAggregateInputType
    _max?: InterviewResultMaxAggregateInputType
  }

  export type InterviewResultGroupByOutputType = {
    id: string
    applicationId: string
    slotId: string
    score: number | null
    comments: string | null
    isPassed: boolean | null
    confirmedAt: Date | null
    rescheduleRequested: boolean
    rescheduleReason: string | null
    checkedInAt: Date | null
    _count: InterviewResultCountAggregateOutputType | null
    _avg: InterviewResultAvgAggregateOutputType | null
    _sum: InterviewResultSumAggregateOutputType | null
    _min: InterviewResultMinAggregateOutputType | null
    _max: InterviewResultMaxAggregateOutputType | null
  }

  type GetInterviewResultGroupByPayload<T extends InterviewResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewResultGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewResultGroupByOutputType[P]>
        }
      >
    >


  export type InterviewResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    slotId?: boolean
    score?: boolean
    comments?: boolean
    isPassed?: boolean
    confirmedAt?: boolean
    rescheduleRequested?: boolean
    rescheduleReason?: boolean
    checkedInAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
    slot?: boolean | InterviewSlotDefaultArgs<ExtArgs>
    feedback?: boolean | InterviewResult$feedbackArgs<ExtArgs>
  }, ExtArgs["result"]["interviewResult"]>


  export type InterviewResultSelectScalar = {
    id?: boolean
    applicationId?: boolean
    slotId?: boolean
    score?: boolean
    comments?: boolean
    isPassed?: boolean
    confirmedAt?: boolean
    rescheduleRequested?: boolean
    rescheduleReason?: boolean
    checkedInAt?: boolean
  }

  export type InterviewResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
    slot?: boolean | InterviewSlotDefaultArgs<ExtArgs>
    feedback?: boolean | InterviewResult$feedbackArgs<ExtArgs>
  }

  export type $InterviewResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewResult"
    objects: {
      application: Prisma.$ApplicationPayload<ExtArgs>
      slot: Prisma.$InterviewSlotPayload<ExtArgs>
      feedback: Prisma.$InterviewFeedbackPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      slotId: string
      score: number | null
      comments: string | null
      isPassed: boolean | null
      confirmedAt: Date | null
      rescheduleRequested: boolean
      rescheduleReason: string | null
      checkedInAt: Date | null
    }, ExtArgs["result"]["interviewResult"]>
    composites: {}
  }

  type InterviewResultGetPayload<S extends boolean | null | undefined | InterviewResultDefaultArgs> = $Result.GetResult<Prisma.$InterviewResultPayload, S>

  type InterviewResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewResultCountAggregateInputType | true
    }

  export interface InterviewResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewResult'], meta: { name: 'InterviewResult' } }
    /**
     * Find zero or one InterviewResult that matches the filter.
     * @param {InterviewResultFindUniqueArgs} args - Arguments to find a InterviewResult
     * @example
     * // Get one InterviewResult
     * const interviewResult = await prisma.interviewResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewResultFindUniqueArgs>(args: SelectSubset<T, InterviewResultFindUniqueArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterviewResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewResultFindUniqueOrThrowArgs} args - Arguments to find a InterviewResult
     * @example
     * // Get one InterviewResult
     * const interviewResult = await prisma.interviewResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewResultFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterviewResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResultFindFirstArgs} args - Arguments to find a InterviewResult
     * @example
     * // Get one InterviewResult
     * const interviewResult = await prisma.interviewResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewResultFindFirstArgs>(args?: SelectSubset<T, InterviewResultFindFirstArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterviewResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResultFindFirstOrThrowArgs} args - Arguments to find a InterviewResult
     * @example
     * // Get one InterviewResult
     * const interviewResult = await prisma.interviewResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewResultFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterviewResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewResults
     * const interviewResults = await prisma.interviewResult.findMany()
     * 
     * // Get first 10 InterviewResults
     * const interviewResults = await prisma.interviewResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewResultWithIdOnly = await prisma.interviewResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewResultFindManyArgs>(args?: SelectSubset<T, InterviewResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterviewResult.
     * @param {InterviewResultCreateArgs} args - Arguments to create a InterviewResult.
     * @example
     * // Create one InterviewResult
     * const InterviewResult = await prisma.interviewResult.create({
     *   data: {
     *     // ... data to create a InterviewResult
     *   }
     * })
     * 
     */
    create<T extends InterviewResultCreateArgs>(args: SelectSubset<T, InterviewResultCreateArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterviewResults.
     * @param {InterviewResultCreateManyArgs} args - Arguments to create many InterviewResults.
     * @example
     * // Create many InterviewResults
     * const interviewResult = await prisma.interviewResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewResultCreateManyArgs>(args?: SelectSubset<T, InterviewResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InterviewResult.
     * @param {InterviewResultDeleteArgs} args - Arguments to delete one InterviewResult.
     * @example
     * // Delete one InterviewResult
     * const InterviewResult = await prisma.interviewResult.delete({
     *   where: {
     *     // ... filter to delete one InterviewResult
     *   }
     * })
     * 
     */
    delete<T extends InterviewResultDeleteArgs>(args: SelectSubset<T, InterviewResultDeleteArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterviewResult.
     * @param {InterviewResultUpdateArgs} args - Arguments to update one InterviewResult.
     * @example
     * // Update one InterviewResult
     * const interviewResult = await prisma.interviewResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewResultUpdateArgs>(args: SelectSubset<T, InterviewResultUpdateArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterviewResults.
     * @param {InterviewResultDeleteManyArgs} args - Arguments to filter InterviewResults to delete.
     * @example
     * // Delete a few InterviewResults
     * const { count } = await prisma.interviewResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewResultDeleteManyArgs>(args?: SelectSubset<T, InterviewResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewResults
     * const interviewResult = await prisma.interviewResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewResultUpdateManyArgs>(args: SelectSubset<T, InterviewResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewResult.
     * @param {InterviewResultUpsertArgs} args - Arguments to update or create a InterviewResult.
     * @example
     * // Update or create a InterviewResult
     * const interviewResult = await prisma.interviewResult.upsert({
     *   create: {
     *     // ... data to create a InterviewResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewResult we want to update
     *   }
     * })
     */
    upsert<T extends InterviewResultUpsertArgs>(args: SelectSubset<T, InterviewResultUpsertArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterviewResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResultCountArgs} args - Arguments to filter InterviewResults to count.
     * @example
     * // Count the number of InterviewResults
     * const count = await prisma.interviewResult.count({
     *   where: {
     *     // ... the filter for the InterviewResults we want to count
     *   }
     * })
    **/
    count<T extends InterviewResultCountArgs>(
      args?: Subset<T, InterviewResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewResultAggregateArgs>(args: Subset<T, InterviewResultAggregateArgs>): Prisma.PrismaPromise<GetInterviewResultAggregateType<T>>

    /**
     * Group by InterviewResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewResultGroupByArgs['orderBy'] }
        : { orderBy?: InterviewResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewResult model
   */
  readonly fields: InterviewResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    slot<T extends InterviewSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSlotDefaultArgs<ExtArgs>>): Prisma__InterviewSlotClient<$Result.GetResult<Prisma.$InterviewSlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    feedback<T extends InterviewResult$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, InterviewResult$feedbackArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewResult model
   */ 
  interface InterviewResultFieldRefs {
    readonly id: FieldRef<"InterviewResult", 'String'>
    readonly applicationId: FieldRef<"InterviewResult", 'String'>
    readonly slotId: FieldRef<"InterviewResult", 'String'>
    readonly score: FieldRef<"InterviewResult", 'Int'>
    readonly comments: FieldRef<"InterviewResult", 'String'>
    readonly isPassed: FieldRef<"InterviewResult", 'Boolean'>
    readonly confirmedAt: FieldRef<"InterviewResult", 'DateTime'>
    readonly rescheduleRequested: FieldRef<"InterviewResult", 'Boolean'>
    readonly rescheduleReason: FieldRef<"InterviewResult", 'String'>
    readonly checkedInAt: FieldRef<"InterviewResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewResult findUnique
   */
  export type InterviewResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResult to fetch.
     */
    where: InterviewResultWhereUniqueInput
  }

  /**
   * InterviewResult findUniqueOrThrow
   */
  export type InterviewResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResult to fetch.
     */
    where: InterviewResultWhereUniqueInput
  }

  /**
   * InterviewResult findFirst
   */
  export type InterviewResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResult to fetch.
     */
    where?: InterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResults to fetch.
     */
    orderBy?: InterviewResultOrderByWithRelationInput | InterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewResults.
     */
    cursor?: InterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewResults.
     */
    distinct?: InterviewResultScalarFieldEnum | InterviewResultScalarFieldEnum[]
  }

  /**
   * InterviewResult findFirstOrThrow
   */
  export type InterviewResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResult to fetch.
     */
    where?: InterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResults to fetch.
     */
    orderBy?: InterviewResultOrderByWithRelationInput | InterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewResults.
     */
    cursor?: InterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewResults.
     */
    distinct?: InterviewResultScalarFieldEnum | InterviewResultScalarFieldEnum[]
  }

  /**
   * InterviewResult findMany
   */
  export type InterviewResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResults to fetch.
     */
    where?: InterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResults to fetch.
     */
    orderBy?: InterviewResultOrderByWithRelationInput | InterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewResults.
     */
    cursor?: InterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResults.
     */
    skip?: number
    distinct?: InterviewResultScalarFieldEnum | InterviewResultScalarFieldEnum[]
  }

  /**
   * InterviewResult create
   */
  export type InterviewResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewResult.
     */
    data: XOR<InterviewResultCreateInput, InterviewResultUncheckedCreateInput>
  }

  /**
   * InterviewResult createMany
   */
  export type InterviewResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewResults.
     */
    data: InterviewResultCreateManyInput | InterviewResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewResult update
   */
  export type InterviewResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewResult.
     */
    data: XOR<InterviewResultUpdateInput, InterviewResultUncheckedUpdateInput>
    /**
     * Choose, which InterviewResult to update.
     */
    where: InterviewResultWhereUniqueInput
  }

  /**
   * InterviewResult updateMany
   */
  export type InterviewResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewResults.
     */
    data: XOR<InterviewResultUpdateManyMutationInput, InterviewResultUncheckedUpdateManyInput>
    /**
     * Filter which InterviewResults to update
     */
    where?: InterviewResultWhereInput
  }

  /**
   * InterviewResult upsert
   */
  export type InterviewResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewResult to update in case it exists.
     */
    where: InterviewResultWhereUniqueInput
    /**
     * In case the InterviewResult found by the `where` argument doesn't exist, create a new InterviewResult with this data.
     */
    create: XOR<InterviewResultCreateInput, InterviewResultUncheckedCreateInput>
    /**
     * In case the InterviewResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewResultUpdateInput, InterviewResultUncheckedUpdateInput>
  }

  /**
   * InterviewResult delete
   */
  export type InterviewResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
    /**
     * Filter which InterviewResult to delete.
     */
    where: InterviewResultWhereUniqueInput
  }

  /**
   * InterviewResult deleteMany
   */
  export type InterviewResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewResults to delete
     */
    where?: InterviewResultWhereInput
  }

  /**
   * InterviewResult.feedback
   */
  export type InterviewResult$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    where?: InterviewFeedbackWhereInput
  }

  /**
   * InterviewResult without action
   */
  export type InterviewResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResult
     */
    select?: InterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResultInclude<ExtArgs> | null
  }


  /**
   * Model InterviewFeedback
   */

  export type AggregateInterviewFeedback = {
    _count: InterviewFeedbackCountAggregateOutputType | null
    _avg: InterviewFeedbackAvgAggregateOutputType | null
    _sum: InterviewFeedbackSumAggregateOutputType | null
    _min: InterviewFeedbackMinAggregateOutputType | null
    _max: InterviewFeedbackMaxAggregateOutputType | null
  }

  export type InterviewFeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type InterviewFeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type InterviewFeedbackMinAggregateOutputType = {
    id: string | null
    interviewResultId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type InterviewFeedbackMaxAggregateOutputType = {
    id: string | null
    interviewResultId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type InterviewFeedbackCountAggregateOutputType = {
    id: number
    interviewResultId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type InterviewFeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type InterviewFeedbackSumAggregateInputType = {
    rating?: true
  }

  export type InterviewFeedbackMinAggregateInputType = {
    id?: true
    interviewResultId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type InterviewFeedbackMaxAggregateInputType = {
    id?: true
    interviewResultId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type InterviewFeedbackCountAggregateInputType = {
    id?: true
    interviewResultId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type InterviewFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewFeedback to aggregate.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewFeedbacks
    **/
    _count?: true | InterviewFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewFeedbackMaxAggregateInputType
  }

  export type GetInterviewFeedbackAggregateType<T extends InterviewFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewFeedback[P]>
      : GetScalarType<T[P], AggregateInterviewFeedback[P]>
  }




  export type InterviewFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewFeedbackWhereInput
    orderBy?: InterviewFeedbackOrderByWithAggregationInput | InterviewFeedbackOrderByWithAggregationInput[]
    by: InterviewFeedbackScalarFieldEnum[] | InterviewFeedbackScalarFieldEnum
    having?: InterviewFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewFeedbackCountAggregateInputType | true
    _avg?: InterviewFeedbackAvgAggregateInputType
    _sum?: InterviewFeedbackSumAggregateInputType
    _min?: InterviewFeedbackMinAggregateInputType
    _max?: InterviewFeedbackMaxAggregateInputType
  }

  export type InterviewFeedbackGroupByOutputType = {
    id: string
    interviewResultId: string
    rating: number
    comment: string | null
    createdAt: Date
    _count: InterviewFeedbackCountAggregateOutputType | null
    _avg: InterviewFeedbackAvgAggregateOutputType | null
    _sum: InterviewFeedbackSumAggregateOutputType | null
    _min: InterviewFeedbackMinAggregateOutputType | null
    _max: InterviewFeedbackMaxAggregateOutputType | null
  }

  type GetInterviewFeedbackGroupByPayload<T extends InterviewFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type InterviewFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewResultId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    interviewResult?: boolean | InterviewResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewFeedback"]>


  export type InterviewFeedbackSelectScalar = {
    id?: boolean
    interviewResultId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type InterviewFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interviewResult?: boolean | InterviewResultDefaultArgs<ExtArgs>
  }

  export type $InterviewFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewFeedback"
    objects: {
      interviewResult: Prisma.$InterviewResultPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interviewResultId: string
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["interviewFeedback"]>
    composites: {}
  }

  type InterviewFeedbackGetPayload<S extends boolean | null | undefined | InterviewFeedbackDefaultArgs> = $Result.GetResult<Prisma.$InterviewFeedbackPayload, S>

  type InterviewFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewFeedbackCountAggregateInputType | true
    }

  export interface InterviewFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewFeedback'], meta: { name: 'InterviewFeedback' } }
    /**
     * Find zero or one InterviewFeedback that matches the filter.
     * @param {InterviewFeedbackFindUniqueArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewFeedbackFindUniqueArgs>(args: SelectSubset<T, InterviewFeedbackFindUniqueArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterviewFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewFeedbackFindUniqueOrThrowArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterviewFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackFindFirstArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewFeedbackFindFirstArgs>(args?: SelectSubset<T, InterviewFeedbackFindFirstArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterviewFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackFindFirstOrThrowArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterviewFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewFeedbacks
     * const interviewFeedbacks = await prisma.interviewFeedback.findMany()
     * 
     * // Get first 10 InterviewFeedbacks
     * const interviewFeedbacks = await prisma.interviewFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewFeedbackWithIdOnly = await prisma.interviewFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewFeedbackFindManyArgs>(args?: SelectSubset<T, InterviewFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterviewFeedback.
     * @param {InterviewFeedbackCreateArgs} args - Arguments to create a InterviewFeedback.
     * @example
     * // Create one InterviewFeedback
     * const InterviewFeedback = await prisma.interviewFeedback.create({
     *   data: {
     *     // ... data to create a InterviewFeedback
     *   }
     * })
     * 
     */
    create<T extends InterviewFeedbackCreateArgs>(args: SelectSubset<T, InterviewFeedbackCreateArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterviewFeedbacks.
     * @param {InterviewFeedbackCreateManyArgs} args - Arguments to create many InterviewFeedbacks.
     * @example
     * // Create many InterviewFeedbacks
     * const interviewFeedback = await prisma.interviewFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewFeedbackCreateManyArgs>(args?: SelectSubset<T, InterviewFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InterviewFeedback.
     * @param {InterviewFeedbackDeleteArgs} args - Arguments to delete one InterviewFeedback.
     * @example
     * // Delete one InterviewFeedback
     * const InterviewFeedback = await prisma.interviewFeedback.delete({
     *   where: {
     *     // ... filter to delete one InterviewFeedback
     *   }
     * })
     * 
     */
    delete<T extends InterviewFeedbackDeleteArgs>(args: SelectSubset<T, InterviewFeedbackDeleteArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterviewFeedback.
     * @param {InterviewFeedbackUpdateArgs} args - Arguments to update one InterviewFeedback.
     * @example
     * // Update one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewFeedbackUpdateArgs>(args: SelectSubset<T, InterviewFeedbackUpdateArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterviewFeedbacks.
     * @param {InterviewFeedbackDeleteManyArgs} args - Arguments to filter InterviewFeedbacks to delete.
     * @example
     * // Delete a few InterviewFeedbacks
     * const { count } = await prisma.interviewFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewFeedbackDeleteManyArgs>(args?: SelectSubset<T, InterviewFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewFeedbacks
     * const interviewFeedback = await prisma.interviewFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewFeedbackUpdateManyArgs>(args: SelectSubset<T, InterviewFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewFeedback.
     * @param {InterviewFeedbackUpsertArgs} args - Arguments to update or create a InterviewFeedback.
     * @example
     * // Update or create a InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.upsert({
     *   create: {
     *     // ... data to create a InterviewFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewFeedback we want to update
     *   }
     * })
     */
    upsert<T extends InterviewFeedbackUpsertArgs>(args: SelectSubset<T, InterviewFeedbackUpsertArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterviewFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackCountArgs} args - Arguments to filter InterviewFeedbacks to count.
     * @example
     * // Count the number of InterviewFeedbacks
     * const count = await prisma.interviewFeedback.count({
     *   where: {
     *     // ... the filter for the InterviewFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends InterviewFeedbackCountArgs>(
      args?: Subset<T, InterviewFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewFeedbackAggregateArgs>(args: Subset<T, InterviewFeedbackAggregateArgs>): Prisma.PrismaPromise<GetInterviewFeedbackAggregateType<T>>

    /**
     * Group by InterviewFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: InterviewFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewFeedback model
   */
  readonly fields: InterviewFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interviewResult<T extends InterviewResultDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewResultDefaultArgs<ExtArgs>>): Prisma__InterviewResultClient<$Result.GetResult<Prisma.$InterviewResultPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewFeedback model
   */ 
  interface InterviewFeedbackFieldRefs {
    readonly id: FieldRef<"InterviewFeedback", 'String'>
    readonly interviewResultId: FieldRef<"InterviewFeedback", 'String'>
    readonly rating: FieldRef<"InterviewFeedback", 'Int'>
    readonly comment: FieldRef<"InterviewFeedback", 'String'>
    readonly createdAt: FieldRef<"InterviewFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewFeedback findUnique
   */
  export type InterviewFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback findUniqueOrThrow
   */
  export type InterviewFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback findFirst
   */
  export type InterviewFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewFeedbacks.
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewFeedbacks.
     */
    distinct?: InterviewFeedbackScalarFieldEnum | InterviewFeedbackScalarFieldEnum[]
  }

  /**
   * InterviewFeedback findFirstOrThrow
   */
  export type InterviewFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewFeedbacks.
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewFeedbacks.
     */
    distinct?: InterviewFeedbackScalarFieldEnum | InterviewFeedbackScalarFieldEnum[]
  }

  /**
   * InterviewFeedback findMany
   */
  export type InterviewFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedbacks to fetch.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewFeedbacks.
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    distinct?: InterviewFeedbackScalarFieldEnum | InterviewFeedbackScalarFieldEnum[]
  }

  /**
   * InterviewFeedback create
   */
  export type InterviewFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewFeedback.
     */
    data: XOR<InterviewFeedbackCreateInput, InterviewFeedbackUncheckedCreateInput>
  }

  /**
   * InterviewFeedback createMany
   */
  export type InterviewFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewFeedbacks.
     */
    data: InterviewFeedbackCreateManyInput | InterviewFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewFeedback update
   */
  export type InterviewFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewFeedback.
     */
    data: XOR<InterviewFeedbackUpdateInput, InterviewFeedbackUncheckedUpdateInput>
    /**
     * Choose, which InterviewFeedback to update.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback updateMany
   */
  export type InterviewFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewFeedbacks.
     */
    data: XOR<InterviewFeedbackUpdateManyMutationInput, InterviewFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which InterviewFeedbacks to update
     */
    where?: InterviewFeedbackWhereInput
  }

  /**
   * InterviewFeedback upsert
   */
  export type InterviewFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewFeedback to update in case it exists.
     */
    where: InterviewFeedbackWhereUniqueInput
    /**
     * In case the InterviewFeedback found by the `where` argument doesn't exist, create a new InterviewFeedback with this data.
     */
    create: XOR<InterviewFeedbackCreateInput, InterviewFeedbackUncheckedCreateInput>
    /**
     * In case the InterviewFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewFeedbackUpdateInput, InterviewFeedbackUncheckedUpdateInput>
  }

  /**
   * InterviewFeedback delete
   */
  export type InterviewFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter which InterviewFeedback to delete.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback deleteMany
   */
  export type InterviewFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewFeedbacks to delete
     */
    where?: InterviewFeedbackWhereInput
  }

  /**
   * InterviewFeedback without action
   */
  export type InterviewFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model StudentGroup
   */

  export type AggregateStudentGroup = {
    _count: StudentGroupCountAggregateOutputType | null
    _avg: StudentGroupAvgAggregateOutputType | null
    _sum: StudentGroupSumAggregateOutputType | null
    _min: StudentGroupMinAggregateOutputType | null
    _max: StudentGroupMaxAggregateOutputType | null
  }

  export type StudentGroupAvgAggregateOutputType = {
    admissionYear: number | null
  }

  export type StudentGroupSumAggregateOutputType = {
    admissionYear: number | null
  }

  export type StudentGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    admissionYear: number | null
    programId: string | null
    advisorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    admissionYear: number | null
    programId: string | null
    advisorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentGroupCountAggregateOutputType = {
    id: number
    name: number
    admissionYear: number
    programId: number
    advisorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentGroupAvgAggregateInputType = {
    admissionYear?: true
  }

  export type StudentGroupSumAggregateInputType = {
    admissionYear?: true
  }

  export type StudentGroupMinAggregateInputType = {
    id?: true
    name?: true
    admissionYear?: true
    programId?: true
    advisorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentGroupMaxAggregateInputType = {
    id?: true
    name?: true
    admissionYear?: true
    programId?: true
    advisorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentGroupCountAggregateInputType = {
    id?: true
    name?: true
    admissionYear?: true
    programId?: true
    advisorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentGroup to aggregate.
     */
    where?: StudentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGroups to fetch.
     */
    orderBy?: StudentGroupOrderByWithRelationInput | StudentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentGroups
    **/
    _count?: true | StudentGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentGroupMaxAggregateInputType
  }

  export type GetStudentGroupAggregateType<T extends StudentGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentGroup[P]>
      : GetScalarType<T[P], AggregateStudentGroup[P]>
  }




  export type StudentGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGroupWhereInput
    orderBy?: StudentGroupOrderByWithAggregationInput | StudentGroupOrderByWithAggregationInput[]
    by: StudentGroupScalarFieldEnum[] | StudentGroupScalarFieldEnum
    having?: StudentGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentGroupCountAggregateInputType | true
    _avg?: StudentGroupAvgAggregateInputType
    _sum?: StudentGroupSumAggregateInputType
    _min?: StudentGroupMinAggregateInputType
    _max?: StudentGroupMaxAggregateInputType
  }

  export type StudentGroupGroupByOutputType = {
    id: string
    name: string
    admissionYear: number
    programId: string
    advisorId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentGroupCountAggregateOutputType | null
    _avg: StudentGroupAvgAggregateOutputType | null
    _sum: StudentGroupSumAggregateOutputType | null
    _min: StudentGroupMinAggregateOutputType | null
    _max: StudentGroupMaxAggregateOutputType | null
  }

  type GetStudentGroupGroupByPayload<T extends StudentGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupGroupByOutputType[P]>
        }
      >
    >


  export type StudentGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    admissionYear?: boolean
    programId?: boolean
    advisorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    advisor?: boolean | StudentGroup$advisorArgs<ExtArgs>
    students?: boolean | StudentGroup$studentsArgs<ExtArgs>
    sections?: boolean | StudentGroup$sectionsArgs<ExtArgs>
    _count?: boolean | StudentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentGroup"]>


  export type StudentGroupSelectScalar = {
    id?: boolean
    name?: boolean
    admissionYear?: boolean
    programId?: boolean
    advisorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    advisor?: boolean | StudentGroup$advisorArgs<ExtArgs>
    students?: boolean | StudentGroup$studentsArgs<ExtArgs>
    sections?: boolean | StudentGroup$sectionsArgs<ExtArgs>
    _count?: boolean | StudentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentGroup"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      advisor: Prisma.$PersonnelPayload<ExtArgs> | null
      students: Prisma.$StudentPayload<ExtArgs>[]
      sections: Prisma.$ClassSectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      admissionYear: number
      programId: string
      advisorId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentGroup"]>
    composites: {}
  }

  type StudentGroupGetPayload<S extends boolean | null | undefined | StudentGroupDefaultArgs> = $Result.GetResult<Prisma.$StudentGroupPayload, S>

  type StudentGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentGroupCountAggregateInputType | true
    }

  export interface StudentGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentGroup'], meta: { name: 'StudentGroup' } }
    /**
     * Find zero or one StudentGroup that matches the filter.
     * @param {StudentGroupFindUniqueArgs} args - Arguments to find a StudentGroup
     * @example
     * // Get one StudentGroup
     * const studentGroup = await prisma.studentGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentGroupFindUniqueArgs>(args: SelectSubset<T, StudentGroupFindUniqueArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentGroupFindUniqueOrThrowArgs} args - Arguments to find a StudentGroup
     * @example
     * // Get one StudentGroup
     * const studentGroup = await prisma.studentGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupFindFirstArgs} args - Arguments to find a StudentGroup
     * @example
     * // Get one StudentGroup
     * const studentGroup = await prisma.studentGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentGroupFindFirstArgs>(args?: SelectSubset<T, StudentGroupFindFirstArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupFindFirstOrThrowArgs} args - Arguments to find a StudentGroup
     * @example
     * // Get one StudentGroup
     * const studentGroup = await prisma.studentGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentGroups
     * const studentGroups = await prisma.studentGroup.findMany()
     * 
     * // Get first 10 StudentGroups
     * const studentGroups = await prisma.studentGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentGroupWithIdOnly = await prisma.studentGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentGroupFindManyArgs>(args?: SelectSubset<T, StudentGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentGroup.
     * @param {StudentGroupCreateArgs} args - Arguments to create a StudentGroup.
     * @example
     * // Create one StudentGroup
     * const StudentGroup = await prisma.studentGroup.create({
     *   data: {
     *     // ... data to create a StudentGroup
     *   }
     * })
     * 
     */
    create<T extends StudentGroupCreateArgs>(args: SelectSubset<T, StudentGroupCreateArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentGroups.
     * @param {StudentGroupCreateManyArgs} args - Arguments to create many StudentGroups.
     * @example
     * // Create many StudentGroups
     * const studentGroup = await prisma.studentGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentGroupCreateManyArgs>(args?: SelectSubset<T, StudentGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentGroup.
     * @param {StudentGroupDeleteArgs} args - Arguments to delete one StudentGroup.
     * @example
     * // Delete one StudentGroup
     * const StudentGroup = await prisma.studentGroup.delete({
     *   where: {
     *     // ... filter to delete one StudentGroup
     *   }
     * })
     * 
     */
    delete<T extends StudentGroupDeleteArgs>(args: SelectSubset<T, StudentGroupDeleteArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentGroup.
     * @param {StudentGroupUpdateArgs} args - Arguments to update one StudentGroup.
     * @example
     * // Update one StudentGroup
     * const studentGroup = await prisma.studentGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentGroupUpdateArgs>(args: SelectSubset<T, StudentGroupUpdateArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentGroups.
     * @param {StudentGroupDeleteManyArgs} args - Arguments to filter StudentGroups to delete.
     * @example
     * // Delete a few StudentGroups
     * const { count } = await prisma.studentGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentGroupDeleteManyArgs>(args?: SelectSubset<T, StudentGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentGroups
     * const studentGroup = await prisma.studentGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentGroupUpdateManyArgs>(args: SelectSubset<T, StudentGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentGroup.
     * @param {StudentGroupUpsertArgs} args - Arguments to update or create a StudentGroup.
     * @example
     * // Update or create a StudentGroup
     * const studentGroup = await prisma.studentGroup.upsert({
     *   create: {
     *     // ... data to create a StudentGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentGroup we want to update
     *   }
     * })
     */
    upsert<T extends StudentGroupUpsertArgs>(args: SelectSubset<T, StudentGroupUpsertArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupCountArgs} args - Arguments to filter StudentGroups to count.
     * @example
     * // Count the number of StudentGroups
     * const count = await prisma.studentGroup.count({
     *   where: {
     *     // ... the filter for the StudentGroups we want to count
     *   }
     * })
    **/
    count<T extends StudentGroupCountArgs>(
      args?: Subset<T, StudentGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentGroupAggregateArgs>(args: Subset<T, StudentGroupAggregateArgs>): Prisma.PrismaPromise<GetStudentGroupAggregateType<T>>

    /**
     * Group by StudentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentGroup model
   */
  readonly fields: StudentGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    advisor<T extends StudentGroup$advisorArgs<ExtArgs> = {}>(args?: Subset<T, StudentGroup$advisorArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    students<T extends StudentGroup$studentsArgs<ExtArgs> = {}>(args?: Subset<T, StudentGroup$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    sections<T extends StudentGroup$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, StudentGroup$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentGroup model
   */ 
  interface StudentGroupFieldRefs {
    readonly id: FieldRef<"StudentGroup", 'String'>
    readonly name: FieldRef<"StudentGroup", 'String'>
    readonly admissionYear: FieldRef<"StudentGroup", 'Int'>
    readonly programId: FieldRef<"StudentGroup", 'String'>
    readonly advisorId: FieldRef<"StudentGroup", 'String'>
    readonly createdAt: FieldRef<"StudentGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentGroup findUnique
   */
  export type StudentGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudentGroup to fetch.
     */
    where: StudentGroupWhereUniqueInput
  }

  /**
   * StudentGroup findUniqueOrThrow
   */
  export type StudentGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudentGroup to fetch.
     */
    where: StudentGroupWhereUniqueInput
  }

  /**
   * StudentGroup findFirst
   */
  export type StudentGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudentGroup to fetch.
     */
    where?: StudentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGroups to fetch.
     */
    orderBy?: StudentGroupOrderByWithRelationInput | StudentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentGroups.
     */
    cursor?: StudentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentGroups.
     */
    distinct?: StudentGroupScalarFieldEnum | StudentGroupScalarFieldEnum[]
  }

  /**
   * StudentGroup findFirstOrThrow
   */
  export type StudentGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudentGroup to fetch.
     */
    where?: StudentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGroups to fetch.
     */
    orderBy?: StudentGroupOrderByWithRelationInput | StudentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentGroups.
     */
    cursor?: StudentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentGroups.
     */
    distinct?: StudentGroupScalarFieldEnum | StudentGroupScalarFieldEnum[]
  }

  /**
   * StudentGroup findMany
   */
  export type StudentGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudentGroups to fetch.
     */
    where?: StudentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGroups to fetch.
     */
    orderBy?: StudentGroupOrderByWithRelationInput | StudentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentGroups.
     */
    cursor?: StudentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGroups.
     */
    skip?: number
    distinct?: StudentGroupScalarFieldEnum | StudentGroupScalarFieldEnum[]
  }

  /**
   * StudentGroup create
   */
  export type StudentGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentGroup.
     */
    data: XOR<StudentGroupCreateInput, StudentGroupUncheckedCreateInput>
  }

  /**
   * StudentGroup createMany
   */
  export type StudentGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentGroups.
     */
    data: StudentGroupCreateManyInput | StudentGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentGroup update
   */
  export type StudentGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentGroup.
     */
    data: XOR<StudentGroupUpdateInput, StudentGroupUncheckedUpdateInput>
    /**
     * Choose, which StudentGroup to update.
     */
    where: StudentGroupWhereUniqueInput
  }

  /**
   * StudentGroup updateMany
   */
  export type StudentGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentGroups.
     */
    data: XOR<StudentGroupUpdateManyMutationInput, StudentGroupUncheckedUpdateManyInput>
    /**
     * Filter which StudentGroups to update
     */
    where?: StudentGroupWhereInput
  }

  /**
   * StudentGroup upsert
   */
  export type StudentGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentGroup to update in case it exists.
     */
    where: StudentGroupWhereUniqueInput
    /**
     * In case the StudentGroup found by the `where` argument doesn't exist, create a new StudentGroup with this data.
     */
    create: XOR<StudentGroupCreateInput, StudentGroupUncheckedCreateInput>
    /**
     * In case the StudentGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentGroupUpdateInput, StudentGroupUncheckedUpdateInput>
  }

  /**
   * StudentGroup delete
   */
  export type StudentGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    /**
     * Filter which StudentGroup to delete.
     */
    where: StudentGroupWhereUniqueInput
  }

  /**
   * StudentGroup deleteMany
   */
  export type StudentGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentGroups to delete
     */
    where?: StudentGroupWhereInput
  }

  /**
   * StudentGroup.advisor
   */
  export type StudentGroup$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * StudentGroup.students
   */
  export type StudentGroup$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * StudentGroup.sections
   */
  export type StudentGroup$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    where?: ClassSectionWhereInput
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    cursor?: ClassSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * StudentGroup without action
   */
  export type StudentGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    gpax: number | null
    admissionYear: number | null
  }

  export type StudentSumAggregateOutputType = {
    gpax: number | null
    admissionYear: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    userId: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    firstNameTh: string | null
    lastNameTh: string | null
    nationality: string | null
    citizenId: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    phone: string | null
    profileImageUrl: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    zipCode: string | null
    programId: string | null
    studentType: $Enums.StudentType | null
    status: $Enums.StudentStatus | null
    gpax: number | null
    bio: string | null
    interests: string | null
    skills: string | null
    socialLinks: string | null
    isProfilePublic: boolean | null
    showGPA: boolean | null
    admissionYear: number | null
    studentGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    userId: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    firstNameTh: string | null
    lastNameTh: string | null
    nationality: string | null
    citizenId: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    phone: string | null
    profileImageUrl: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    zipCode: string | null
    programId: string | null
    studentType: $Enums.StudentType | null
    status: $Enums.StudentStatus | null
    gpax: number | null
    bio: string | null
    interests: string | null
    skills: string | null
    socialLinks: string | null
    isProfilePublic: boolean | null
    showGPA: boolean | null
    admissionYear: number | null
    studentGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    studentId: number
    userId: number
    title: number
    firstName: number
    lastName: number
    firstNameTh: number
    lastNameTh: number
    nationality: number
    citizenId: number
    birthDate: number
    gender: number
    phone: number
    profileImageUrl: number
    address: number
    subDistrict: number
    district: number
    province: number
    zipCode: number
    programId: number
    studentType: number
    status: number
    gpax: number
    bio: number
    interests: number
    skills: number
    socialLinks: number
    isProfilePublic: number
    showGPA: number
    admissionYear: number
    studentGroupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    gpax?: true
    admissionYear?: true
  }

  export type StudentSumAggregateInputType = {
    gpax?: true
    admissionYear?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    title?: true
    firstName?: true
    lastName?: true
    firstNameTh?: true
    lastNameTh?: true
    nationality?: true
    citizenId?: true
    birthDate?: true
    gender?: true
    phone?: true
    profileImageUrl?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    zipCode?: true
    programId?: true
    studentType?: true
    status?: true
    gpax?: true
    bio?: true
    interests?: true
    skills?: true
    socialLinks?: true
    isProfilePublic?: true
    showGPA?: true
    admissionYear?: true
    studentGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    title?: true
    firstName?: true
    lastName?: true
    firstNameTh?: true
    lastNameTh?: true
    nationality?: true
    citizenId?: true
    birthDate?: true
    gender?: true
    phone?: true
    profileImageUrl?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    zipCode?: true
    programId?: true
    studentType?: true
    status?: true
    gpax?: true
    bio?: true
    interests?: true
    skills?: true
    socialLinks?: true
    isProfilePublic?: true
    showGPA?: true
    admissionYear?: true
    studentGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    title?: true
    firstName?: true
    lastName?: true
    firstNameTh?: true
    lastNameTh?: true
    nationality?: true
    citizenId?: true
    birthDate?: true
    gender?: true
    phone?: true
    profileImageUrl?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    zipCode?: true
    programId?: true
    studentType?: true
    status?: true
    gpax?: true
    bio?: true
    interests?: true
    skills?: true
    socialLinks?: true
    isProfilePublic?: true
    showGPA?: true
    admissionYear?: true
    studentGroupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    studentId: string
    userId: string
    title: string | null
    firstName: string
    lastName: string
    firstNameTh: string | null
    lastNameTh: string | null
    nationality: string | null
    citizenId: string | null
    birthDate: Date
    gender: $Enums.Gender | null
    phone: string | null
    profileImageUrl: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    zipCode: string | null
    programId: string
    studentType: $Enums.StudentType
    status: $Enums.StudentStatus
    gpax: number
    bio: string | null
    interests: string | null
    skills: string | null
    socialLinks: string | null
    isProfilePublic: boolean
    showGPA: boolean
    admissionYear: number | null
    studentGroupId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    userId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    nationality?: boolean
    citizenId?: boolean
    birthDate?: boolean
    gender?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    zipCode?: boolean
    programId?: boolean
    studentType?: boolean
    status?: boolean
    gpax?: boolean
    bio?: boolean
    interests?: boolean
    skills?: boolean
    socialLinks?: boolean
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: boolean
    studentGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    studentGroup?: boolean | Student$studentGroupArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    invoices?: boolean | Student$invoicesArgs<ExtArgs>
    leaveRequests?: boolean | Student$leaveRequestsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>


  export type StudentSelectScalar = {
    id?: boolean
    studentId?: boolean
    userId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    nationality?: boolean
    citizenId?: boolean
    birthDate?: boolean
    gender?: boolean
    phone?: boolean
    profileImageUrl?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    zipCode?: boolean
    programId?: boolean
    studentType?: boolean
    status?: boolean
    gpax?: boolean
    bio?: boolean
    interests?: boolean
    skills?: boolean
    socialLinks?: boolean
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: boolean
    studentGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    studentGroup?: boolean | Student$studentGroupArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    invoices?: boolean | Student$invoicesArgs<ExtArgs>
    leaveRequests?: boolean | Student$leaveRequestsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs>
      studentGroup: Prisma.$StudentGroupPayload<ExtArgs> | null
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      leaveRequests: Prisma.$LeaveRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      userId: string
      title: string | null
      firstName: string
      lastName: string
      firstNameTh: string | null
      lastNameTh: string | null
      nationality: string | null
      citizenId: string | null
      birthDate: Date
      gender: $Enums.Gender | null
      phone: string | null
      profileImageUrl: string | null
      address: string | null
      subDistrict: string | null
      district: string | null
      province: string | null
      zipCode: string | null
      programId: string
      studentType: $Enums.StudentType
      status: $Enums.StudentStatus
      gpax: number
      bio: string | null
      interests: string | null
      skills: string | null
      socialLinks: string | null
      isProfilePublic: boolean
      showGPA: boolean
      admissionYear: number | null
      studentGroupId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    studentGroup<T extends Student$studentGroupArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentGroupArgs<ExtArgs>>): Prisma__StudentGroupClient<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Student$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Student$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    leaveRequests<T extends Student$leaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Student$leaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly studentId: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly title: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly firstNameTh: FieldRef<"Student", 'String'>
    readonly lastNameTh: FieldRef<"Student", 'String'>
    readonly nationality: FieldRef<"Student", 'String'>
    readonly citizenId: FieldRef<"Student", 'String'>
    readonly birthDate: FieldRef<"Student", 'DateTime'>
    readonly gender: FieldRef<"Student", 'Gender'>
    readonly phone: FieldRef<"Student", 'String'>
    readonly profileImageUrl: FieldRef<"Student", 'String'>
    readonly address: FieldRef<"Student", 'String'>
    readonly subDistrict: FieldRef<"Student", 'String'>
    readonly district: FieldRef<"Student", 'String'>
    readonly province: FieldRef<"Student", 'String'>
    readonly zipCode: FieldRef<"Student", 'String'>
    readonly programId: FieldRef<"Student", 'String'>
    readonly studentType: FieldRef<"Student", 'StudentType'>
    readonly status: FieldRef<"Student", 'StudentStatus'>
    readonly gpax: FieldRef<"Student", 'Float'>
    readonly bio: FieldRef<"Student", 'String'>
    readonly interests: FieldRef<"Student", 'String'>
    readonly skills: FieldRef<"Student", 'String'>
    readonly socialLinks: FieldRef<"Student", 'String'>
    readonly isProfilePublic: FieldRef<"Student", 'Boolean'>
    readonly showGPA: FieldRef<"Student", 'Boolean'>
    readonly admissionYear: FieldRef<"Student", 'Int'>
    readonly studentGroupId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.studentGroup
   */
  export type Student$studentGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    where?: StudentGroupWhereInput
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Student.invoices
   */
  export type Student$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Student.leaveRequests
   */
  export type Student$leaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model ClassSection
   */

  export type AggregateClassSection = {
    _count: ClassSectionCountAggregateOutputType | null
    _avg: ClassSectionAvgAggregateOutputType | null
    _sum: ClassSectionSumAggregateOutputType | null
    _min: ClassSectionMinAggregateOutputType | null
    _max: ClassSectionMaxAggregateOutputType | null
  }

  export type ClassSectionAvgAggregateOutputType = {
    capacity: number | null
  }

  export type ClassSectionSumAggregateOutputType = {
    capacity: number | null
  }

  export type ClassSectionMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    termId: string | null
    sectionNumber: string | null
    capacity: number | null
    instructorId: string | null
  }

  export type ClassSectionMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    termId: string | null
    sectionNumber: string | null
    capacity: number | null
    instructorId: string | null
  }

  export type ClassSectionCountAggregateOutputType = {
    id: number
    courseId: number
    termId: number
    sectionNumber: number
    capacity: number
    instructorId: number
    _all: number
  }


  export type ClassSectionAvgAggregateInputType = {
    capacity?: true
  }

  export type ClassSectionSumAggregateInputType = {
    capacity?: true
  }

  export type ClassSectionMinAggregateInputType = {
    id?: true
    courseId?: true
    termId?: true
    sectionNumber?: true
    capacity?: true
    instructorId?: true
  }

  export type ClassSectionMaxAggregateInputType = {
    id?: true
    courseId?: true
    termId?: true
    sectionNumber?: true
    capacity?: true
    instructorId?: true
  }

  export type ClassSectionCountAggregateInputType = {
    id?: true
    courseId?: true
    termId?: true
    sectionNumber?: true
    capacity?: true
    instructorId?: true
    _all?: true
  }

  export type ClassSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSection to aggregate.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSections
    **/
    _count?: true | ClassSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSectionMaxAggregateInputType
  }

  export type GetClassSectionAggregateType<T extends ClassSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSection[P]>
      : GetScalarType<T[P], AggregateClassSection[P]>
  }




  export type ClassSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSectionWhereInput
    orderBy?: ClassSectionOrderByWithAggregationInput | ClassSectionOrderByWithAggregationInput[]
    by: ClassSectionScalarFieldEnum[] | ClassSectionScalarFieldEnum
    having?: ClassSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSectionCountAggregateInputType | true
    _avg?: ClassSectionAvgAggregateInputType
    _sum?: ClassSectionSumAggregateInputType
    _min?: ClassSectionMinAggregateInputType
    _max?: ClassSectionMaxAggregateInputType
  }

  export type ClassSectionGroupByOutputType = {
    id: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId: string | null
    _count: ClassSectionCountAggregateOutputType | null
    _avg: ClassSectionAvgAggregateOutputType | null
    _sum: ClassSectionSumAggregateOutputType | null
    _min: ClassSectionMinAggregateOutputType | null
    _max: ClassSectionMaxAggregateOutputType | null
  }

  type GetClassSectionGroupByPayload<T extends ClassSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSectionGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSectionGroupByOutputType[P]>
        }
      >
    >


  export type ClassSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    termId?: boolean
    sectionNumber?: boolean
    capacity?: boolean
    instructorId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
    instructor?: boolean | ClassSection$instructorArgs<ExtArgs>
    schedules?: boolean | ClassSection$schedulesArgs<ExtArgs>
    enrollments?: boolean | ClassSection$enrollmentsArgs<ExtArgs>
    studentGroups?: boolean | ClassSection$studentGroupsArgs<ExtArgs>
    _count?: boolean | ClassSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSection"]>


  export type ClassSectionSelectScalar = {
    id?: boolean
    courseId?: boolean
    termId?: boolean
    sectionNumber?: boolean
    capacity?: boolean
    instructorId?: boolean
  }

  export type ClassSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
    instructor?: boolean | ClassSection$instructorArgs<ExtArgs>
    schedules?: boolean | ClassSection$schedulesArgs<ExtArgs>
    enrollments?: boolean | ClassSection$enrollmentsArgs<ExtArgs>
    studentGroups?: boolean | ClassSection$studentGroupsArgs<ExtArgs>
    _count?: boolean | ClassSectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSection"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      term: Prisma.$AcademicTermPayload<ExtArgs>
      instructor: Prisma.$PersonnelPayload<ExtArgs> | null
      schedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      studentGroups: Prisma.$StudentGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      termId: string
      sectionNumber: string
      capacity: number
      instructorId: string | null
    }, ExtArgs["result"]["classSection"]>
    composites: {}
  }

  type ClassSectionGetPayload<S extends boolean | null | undefined | ClassSectionDefaultArgs> = $Result.GetResult<Prisma.$ClassSectionPayload, S>

  type ClassSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassSectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassSectionCountAggregateInputType | true
    }

  export interface ClassSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSection'], meta: { name: 'ClassSection' } }
    /**
     * Find zero or one ClassSection that matches the filter.
     * @param {ClassSectionFindUniqueArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSectionFindUniqueArgs>(args: SelectSubset<T, ClassSectionFindUniqueArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassSection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassSectionFindUniqueOrThrowArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionFindFirstArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSectionFindFirstArgs>(args?: SelectSubset<T, ClassSectionFindFirstArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionFindFirstOrThrowArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSections
     * const classSections = await prisma.classSection.findMany()
     * 
     * // Get first 10 ClassSections
     * const classSections = await prisma.classSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSectionWithIdOnly = await prisma.classSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassSectionFindManyArgs>(args?: SelectSubset<T, ClassSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassSection.
     * @param {ClassSectionCreateArgs} args - Arguments to create a ClassSection.
     * @example
     * // Create one ClassSection
     * const ClassSection = await prisma.classSection.create({
     *   data: {
     *     // ... data to create a ClassSection
     *   }
     * })
     * 
     */
    create<T extends ClassSectionCreateArgs>(args: SelectSubset<T, ClassSectionCreateArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassSections.
     * @param {ClassSectionCreateManyArgs} args - Arguments to create many ClassSections.
     * @example
     * // Create many ClassSections
     * const classSection = await prisma.classSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSectionCreateManyArgs>(args?: SelectSubset<T, ClassSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassSection.
     * @param {ClassSectionDeleteArgs} args - Arguments to delete one ClassSection.
     * @example
     * // Delete one ClassSection
     * const ClassSection = await prisma.classSection.delete({
     *   where: {
     *     // ... filter to delete one ClassSection
     *   }
     * })
     * 
     */
    delete<T extends ClassSectionDeleteArgs>(args: SelectSubset<T, ClassSectionDeleteArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassSection.
     * @param {ClassSectionUpdateArgs} args - Arguments to update one ClassSection.
     * @example
     * // Update one ClassSection
     * const classSection = await prisma.classSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSectionUpdateArgs>(args: SelectSubset<T, ClassSectionUpdateArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassSections.
     * @param {ClassSectionDeleteManyArgs} args - Arguments to filter ClassSections to delete.
     * @example
     * // Delete a few ClassSections
     * const { count } = await prisma.classSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSectionDeleteManyArgs>(args?: SelectSubset<T, ClassSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSections
     * const classSection = await prisma.classSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSectionUpdateManyArgs>(args: SelectSubset<T, ClassSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSection.
     * @param {ClassSectionUpsertArgs} args - Arguments to update or create a ClassSection.
     * @example
     * // Update or create a ClassSection
     * const classSection = await prisma.classSection.upsert({
     *   create: {
     *     // ... data to create a ClassSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSection we want to update
     *   }
     * })
     */
    upsert<T extends ClassSectionUpsertArgs>(args: SelectSubset<T, ClassSectionUpsertArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionCountArgs} args - Arguments to filter ClassSections to count.
     * @example
     * // Count the number of ClassSections
     * const count = await prisma.classSection.count({
     *   where: {
     *     // ... the filter for the ClassSections we want to count
     *   }
     * })
    **/
    count<T extends ClassSectionCountArgs>(
      args?: Subset<T, ClassSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSectionAggregateArgs>(args: Subset<T, ClassSectionAggregateArgs>): Prisma.PrismaPromise<GetClassSectionAggregateType<T>>

    /**
     * Group by ClassSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSectionGroupByArgs['orderBy'] }
        : { orderBy?: ClassSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSection model
   */
  readonly fields: ClassSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    term<T extends AcademicTermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTermDefaultArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    instructor<T extends ClassSection$instructorArgs<ExtArgs> = {}>(args?: Subset<T, ClassSection$instructorArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    schedules<T extends ClassSection$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, ClassSection$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends ClassSection$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, ClassSection$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    studentGroups<T extends ClassSection$studentGroupsArgs<ExtArgs> = {}>(args?: Subset<T, ClassSection$studentGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGroupPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSection model
   */ 
  interface ClassSectionFieldRefs {
    readonly id: FieldRef<"ClassSection", 'String'>
    readonly courseId: FieldRef<"ClassSection", 'String'>
    readonly termId: FieldRef<"ClassSection", 'String'>
    readonly sectionNumber: FieldRef<"ClassSection", 'String'>
    readonly capacity: FieldRef<"ClassSection", 'Int'>
    readonly instructorId: FieldRef<"ClassSection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassSection findUnique
   */
  export type ClassSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection findUniqueOrThrow
   */
  export type ClassSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection findFirst
   */
  export type ClassSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSections.
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSections.
     */
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * ClassSection findFirstOrThrow
   */
  export type ClassSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSections.
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSections.
     */
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * ClassSection findMany
   */
  export type ClassSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSections to fetch.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSections.
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * ClassSection create
   */
  export type ClassSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSection.
     */
    data: XOR<ClassSectionCreateInput, ClassSectionUncheckedCreateInput>
  }

  /**
   * ClassSection createMany
   */
  export type ClassSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSections.
     */
    data: ClassSectionCreateManyInput | ClassSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSection update
   */
  export type ClassSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSection.
     */
    data: XOR<ClassSectionUpdateInput, ClassSectionUncheckedUpdateInput>
    /**
     * Choose, which ClassSection to update.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection updateMany
   */
  export type ClassSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSections.
     */
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyInput>
    /**
     * Filter which ClassSections to update
     */
    where?: ClassSectionWhereInput
  }

  /**
   * ClassSection upsert
   */
  export type ClassSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSection to update in case it exists.
     */
    where: ClassSectionWhereUniqueInput
    /**
     * In case the ClassSection found by the `where` argument doesn't exist, create a new ClassSection with this data.
     */
    create: XOR<ClassSectionCreateInput, ClassSectionUncheckedCreateInput>
    /**
     * In case the ClassSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSectionUpdateInput, ClassSectionUncheckedUpdateInput>
  }

  /**
   * ClassSection delete
   */
  export type ClassSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter which ClassSection to delete.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection deleteMany
   */
  export type ClassSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSections to delete
     */
    where?: ClassSectionWhereInput
  }

  /**
   * ClassSection.instructor
   */
  export type ClassSection$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * ClassSection.schedules
   */
  export type ClassSection$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * ClassSection.enrollments
   */
  export type ClassSection$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * ClassSection.studentGroups
   */
  export type ClassSection$studentGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGroup
     */
    select?: StudentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGroupInclude<ExtArgs> | null
    where?: StudentGroupWhereInput
    orderBy?: StudentGroupOrderByWithRelationInput | StudentGroupOrderByWithRelationInput[]
    cursor?: StudentGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentGroupScalarFieldEnum | StudentGroupScalarFieldEnum[]
  }

  /**
   * ClassSection without action
   */
  export type ClassSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
  }


  /**
   * Model ClassSchedule
   */

  export type AggregateClassSchedule = {
    _count: ClassScheduleCountAggregateOutputType | null
    _min: ClassScheduleMinAggregateOutputType | null
    _max: ClassScheduleMaxAggregateOutputType | null
  }

  export type ClassScheduleMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    day: $Enums.DayOfWeek | null
    startTime: string | null
    endTime: string | null
    roomId: string | null
    courseId: string | null
    instructorId: string | null
    termId: string | null
  }

  export type ClassScheduleMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    day: $Enums.DayOfWeek | null
    startTime: string | null
    endTime: string | null
    roomId: string | null
    courseId: string | null
    instructorId: string | null
    termId: string | null
  }

  export type ClassScheduleCountAggregateOutputType = {
    id: number
    sectionId: number
    day: number
    startTime: number
    endTime: number
    roomId: number
    courseId: number
    instructorId: number
    termId: number
    _all: number
  }


  export type ClassScheduleMinAggregateInputType = {
    id?: true
    sectionId?: true
    day?: true
    startTime?: true
    endTime?: true
    roomId?: true
    courseId?: true
    instructorId?: true
    termId?: true
  }

  export type ClassScheduleMaxAggregateInputType = {
    id?: true
    sectionId?: true
    day?: true
    startTime?: true
    endTime?: true
    roomId?: true
    courseId?: true
    instructorId?: true
    termId?: true
  }

  export type ClassScheduleCountAggregateInputType = {
    id?: true
    sectionId?: true
    day?: true
    startTime?: true
    endTime?: true
    roomId?: true
    courseId?: true
    instructorId?: true
    termId?: true
    _all?: true
  }

  export type ClassScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSchedule to aggregate.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSchedules
    **/
    _count?: true | ClassScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassScheduleMaxAggregateInputType
  }

  export type GetClassScheduleAggregateType<T extends ClassScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSchedule[P]>
      : GetScalarType<T[P], AggregateClassSchedule[P]>
  }




  export type ClassScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithAggregationInput | ClassScheduleOrderByWithAggregationInput[]
    by: ClassScheduleScalarFieldEnum[] | ClassScheduleScalarFieldEnum
    having?: ClassScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassScheduleCountAggregateInputType | true
    _min?: ClassScheduleMinAggregateInputType
    _max?: ClassScheduleMaxAggregateInputType
  }

  export type ClassScheduleGroupByOutputType = {
    id: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId: string | null
    courseId: string | null
    instructorId: string | null
    termId: string | null
    _count: ClassScheduleCountAggregateOutputType | null
    _min: ClassScheduleMinAggregateOutputType | null
    _max: ClassScheduleMaxAggregateOutputType | null
  }

  type GetClassScheduleGroupByPayload<T extends ClassScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ClassScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ClassScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    day?: boolean
    startTime?: boolean
    endTime?: boolean
    roomId?: boolean
    courseId?: boolean
    instructorId?: boolean
    termId?: boolean
    section?: boolean | ClassSectionDefaultArgs<ExtArgs>
    room?: boolean | ClassSchedule$roomArgs<ExtArgs>
    course?: boolean | ClassSchedule$courseArgs<ExtArgs>
    instructor?: boolean | ClassSchedule$instructorArgs<ExtArgs>
    term?: boolean | ClassSchedule$termArgs<ExtArgs>
  }, ExtArgs["result"]["classSchedule"]>


  export type ClassScheduleSelectScalar = {
    id?: boolean
    sectionId?: boolean
    day?: boolean
    startTime?: boolean
    endTime?: boolean
    roomId?: boolean
    courseId?: boolean
    instructorId?: boolean
    termId?: boolean
  }

  export type ClassScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | ClassSectionDefaultArgs<ExtArgs>
    room?: boolean | ClassSchedule$roomArgs<ExtArgs>
    course?: boolean | ClassSchedule$courseArgs<ExtArgs>
    instructor?: boolean | ClassSchedule$instructorArgs<ExtArgs>
    term?: boolean | ClassSchedule$termArgs<ExtArgs>
  }

  export type $ClassSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSchedule"
    objects: {
      section: Prisma.$ClassSectionPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs> | null
      course: Prisma.$CoursePayload<ExtArgs> | null
      instructor: Prisma.$PersonnelPayload<ExtArgs> | null
      term: Prisma.$AcademicTermPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      day: $Enums.DayOfWeek
      startTime: string
      endTime: string
      roomId: string | null
      courseId: string | null
      instructorId: string | null
      termId: string | null
    }, ExtArgs["result"]["classSchedule"]>
    composites: {}
  }

  type ClassScheduleGetPayload<S extends boolean | null | undefined | ClassScheduleDefaultArgs> = $Result.GetResult<Prisma.$ClassSchedulePayload, S>

  type ClassScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassScheduleCountAggregateInputType | true
    }

  export interface ClassScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSchedule'], meta: { name: 'ClassSchedule' } }
    /**
     * Find zero or one ClassSchedule that matches the filter.
     * @param {ClassScheduleFindUniqueArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassScheduleFindUniqueArgs>(args: SelectSubset<T, ClassScheduleFindUniqueArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassScheduleFindUniqueOrThrowArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleFindFirstArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassScheduleFindFirstArgs>(args?: SelectSubset<T, ClassScheduleFindFirstArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleFindFirstOrThrowArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSchedules
     * const classSchedules = await prisma.classSchedule.findMany()
     * 
     * // Get first 10 ClassSchedules
     * const classSchedules = await prisma.classSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classScheduleWithIdOnly = await prisma.classSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassScheduleFindManyArgs>(args?: SelectSubset<T, ClassScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassSchedule.
     * @param {ClassScheduleCreateArgs} args - Arguments to create a ClassSchedule.
     * @example
     * // Create one ClassSchedule
     * const ClassSchedule = await prisma.classSchedule.create({
     *   data: {
     *     // ... data to create a ClassSchedule
     *   }
     * })
     * 
     */
    create<T extends ClassScheduleCreateArgs>(args: SelectSubset<T, ClassScheduleCreateArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassSchedules.
     * @param {ClassScheduleCreateManyArgs} args - Arguments to create many ClassSchedules.
     * @example
     * // Create many ClassSchedules
     * const classSchedule = await prisma.classSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassScheduleCreateManyArgs>(args?: SelectSubset<T, ClassScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassSchedule.
     * @param {ClassScheduleDeleteArgs} args - Arguments to delete one ClassSchedule.
     * @example
     * // Delete one ClassSchedule
     * const ClassSchedule = await prisma.classSchedule.delete({
     *   where: {
     *     // ... filter to delete one ClassSchedule
     *   }
     * })
     * 
     */
    delete<T extends ClassScheduleDeleteArgs>(args: SelectSubset<T, ClassScheduleDeleteArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassSchedule.
     * @param {ClassScheduleUpdateArgs} args - Arguments to update one ClassSchedule.
     * @example
     * // Update one ClassSchedule
     * const classSchedule = await prisma.classSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassScheduleUpdateArgs>(args: SelectSubset<T, ClassScheduleUpdateArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassSchedules.
     * @param {ClassScheduleDeleteManyArgs} args - Arguments to filter ClassSchedules to delete.
     * @example
     * // Delete a few ClassSchedules
     * const { count } = await prisma.classSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassScheduleDeleteManyArgs>(args?: SelectSubset<T, ClassScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSchedules
     * const classSchedule = await prisma.classSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassScheduleUpdateManyArgs>(args: SelectSubset<T, ClassScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSchedule.
     * @param {ClassScheduleUpsertArgs} args - Arguments to update or create a ClassSchedule.
     * @example
     * // Update or create a ClassSchedule
     * const classSchedule = await prisma.classSchedule.upsert({
     *   create: {
     *     // ... data to create a ClassSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ClassScheduleUpsertArgs>(args: SelectSubset<T, ClassScheduleUpsertArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleCountArgs} args - Arguments to filter ClassSchedules to count.
     * @example
     * // Count the number of ClassSchedules
     * const count = await prisma.classSchedule.count({
     *   where: {
     *     // ... the filter for the ClassSchedules we want to count
     *   }
     * })
    **/
    count<T extends ClassScheduleCountArgs>(
      args?: Subset<T, ClassScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassScheduleAggregateArgs>(args: Subset<T, ClassScheduleAggregateArgs>): Prisma.PrismaPromise<GetClassScheduleAggregateType<T>>

    /**
     * Group by ClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ClassScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSchedule model
   */
  readonly fields: ClassScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends ClassSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassSectionDefaultArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends ClassSchedule$roomArgs<ExtArgs> = {}>(args?: Subset<T, ClassSchedule$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    course<T extends ClassSchedule$courseArgs<ExtArgs> = {}>(args?: Subset<T, ClassSchedule$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    instructor<T extends ClassSchedule$instructorArgs<ExtArgs> = {}>(args?: Subset<T, ClassSchedule$instructorArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    term<T extends ClassSchedule$termArgs<ExtArgs> = {}>(args?: Subset<T, ClassSchedule$termArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSchedule model
   */ 
  interface ClassScheduleFieldRefs {
    readonly id: FieldRef<"ClassSchedule", 'String'>
    readonly sectionId: FieldRef<"ClassSchedule", 'String'>
    readonly day: FieldRef<"ClassSchedule", 'DayOfWeek'>
    readonly startTime: FieldRef<"ClassSchedule", 'String'>
    readonly endTime: FieldRef<"ClassSchedule", 'String'>
    readonly roomId: FieldRef<"ClassSchedule", 'String'>
    readonly courseId: FieldRef<"ClassSchedule", 'String'>
    readonly instructorId: FieldRef<"ClassSchedule", 'String'>
    readonly termId: FieldRef<"ClassSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassSchedule findUnique
   */
  export type ClassScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule findUniqueOrThrow
   */
  export type ClassScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule findFirst
   */
  export type ClassScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSchedules.
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSchedules.
     */
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * ClassSchedule findFirstOrThrow
   */
  export type ClassScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSchedules.
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSchedules.
     */
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * ClassSchedule findMany
   */
  export type ClassScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedules to fetch.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSchedules.
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * ClassSchedule create
   */
  export type ClassScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSchedule.
     */
    data: XOR<ClassScheduleCreateInput, ClassScheduleUncheckedCreateInput>
  }

  /**
   * ClassSchedule createMany
   */
  export type ClassScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSchedules.
     */
    data: ClassScheduleCreateManyInput | ClassScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSchedule update
   */
  export type ClassScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSchedule.
     */
    data: XOR<ClassScheduleUpdateInput, ClassScheduleUncheckedUpdateInput>
    /**
     * Choose, which ClassSchedule to update.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule updateMany
   */
  export type ClassScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSchedules.
     */
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ClassSchedules to update
     */
    where?: ClassScheduleWhereInput
  }

  /**
   * ClassSchedule upsert
   */
  export type ClassScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSchedule to update in case it exists.
     */
    where: ClassScheduleWhereUniqueInput
    /**
     * In case the ClassSchedule found by the `where` argument doesn't exist, create a new ClassSchedule with this data.
     */
    create: XOR<ClassScheduleCreateInput, ClassScheduleUncheckedCreateInput>
    /**
     * In case the ClassSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassScheduleUpdateInput, ClassScheduleUncheckedUpdateInput>
  }

  /**
   * ClassSchedule delete
   */
  export type ClassScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter which ClassSchedule to delete.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule deleteMany
   */
  export type ClassScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSchedules to delete
     */
    where?: ClassScheduleWhereInput
  }

  /**
   * ClassSchedule.room
   */
  export type ClassSchedule$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * ClassSchedule.course
   */
  export type ClassSchedule$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * ClassSchedule.instructor
   */
  export type ClassSchedule$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * ClassSchedule.term
   */
  export type ClassSchedule$termArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTerm
     */
    select?: AcademicTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicTermInclude<ExtArgs> | null
    where?: AcademicTermWhereInput
  }

  /**
   * ClassSchedule without action
   */
  export type ClassScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionId: string | null
    grade: string | null
    enrolledAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionId: string | null
    grade: string | null
    enrolledAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    sectionId: number
    grade: number
    enrolledAt: number
    _all: number
  }


  export type EnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    grade?: true
    enrolledAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    grade?: true
    enrolledAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    grade?: true
    enrolledAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    studentId: string
    sectionId: string
    grade: string | null
    enrolledAt: Date
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    grade?: boolean
    enrolledAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | ClassSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>


  export type EnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    grade?: boolean
    enrolledAt?: boolean
  }

  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | ClassSectionDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      section: Prisma.$ClassSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      sectionId: string
      grade: string | null
      enrolledAt: Date
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    section<T extends ClassSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassSectionDefaultArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */ 
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly studentId: FieldRef<"Enrollment", 'String'>
    readonly sectionId: FieldRef<"Enrollment", 'String'>
    readonly grade: FieldRef<"Enrollment", 'String'>
    readonly enrolledAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    termId: string | null
    amount: Decimal | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    termId: string | null
    amount: Decimal | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    studentId: number
    termId: number
    amount: number
    dueDate: number
    status: number
    createdAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    studentId?: true
    termId?: true
    amount?: true
    dueDate?: true
    status?: true
    createdAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    studentId?: true
    termId?: true
    amount?: true
    dueDate?: true
    status?: true
    createdAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    studentId?: true
    termId?: true
    amount?: true
    dueDate?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    studentId: string
    termId: string
    amount: Decimal
    dueDate: Date
    status: $Enums.InvoiceStatus
    createdAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    termId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>


  export type InvoiceSelectScalar = {
    id?: boolean
    studentId?: boolean
    termId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      term: Prisma.$AcademicTermPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      termId: string
      amount: Prisma.Decimal
      dueDate: Date
      status: $Enums.InvoiceStatus
      createdAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    term<T extends AcademicTermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTermDefaultArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly studentId: FieldRef<"Invoice", 'String'>
    readonly termId: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    amount: Decimal | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    amount: Decimal | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    amount: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    amount: Decimal
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>


  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      amount: Prisma.Decimal
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly amount: FieldRef<"InvoiceItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    amount: Decimal | null
    slipUrl: string | null
    paidAt: Date | null
    verifiedAt: Date | null
    verifiedBy: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    amount: Decimal | null
    slipUrl: string | null
    paidAt: Date | null
    verifiedAt: Date | null
    verifiedBy: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    amount: number
    slipUrl: number
    paidAt: number
    verifiedAt: number
    verifiedBy: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    slipUrl?: true
    paidAt?: true
    verifiedAt?: true
    verifiedBy?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    slipUrl?: true
    paidAt?: true
    verifiedAt?: true
    verifiedBy?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    slipUrl?: true
    paidAt?: true
    verifiedAt?: true
    verifiedBy?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    amount: Decimal
    slipUrl: string | null
    paidAt: Date
    verifiedAt: Date | null
    verifiedBy: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    slipUrl?: boolean
    paidAt?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>


  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    slipUrl?: boolean
    paidAt?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      amount: Prisma.Decimal
      slipUrl: string | null
      paidAt: Date
      verifiedAt: Date | null
      verifiedBy: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly slipUrl: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly verifiedAt: FieldRef<"Payment", 'DateTime'>
    readonly verifiedBy: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    imageUrl: string | null
    content: string | null
    target: $Enums.AnnouncementTarget | null
    isPublished: boolean | null
    publishedAt: Date | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    imageUrl: string | null
    content: string | null
    target: $Enums.AnnouncementTarget | null
    isPublished: boolean | null
    publishedAt: Date | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    imageUrl: number
    content: number
    target: number
    isPublished: number
    publishedAt: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    content?: true
    target?: true
    isPublished?: true
    publishedAt?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    content?: true
    target?: true
    isPublished?: true
    publishedAt?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    content?: true
    target?: true
    isPublished?: true
    publishedAt?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    imageUrl: string | null
    content: string
    target: $Enums.AnnouncementTarget
    isPublished: boolean
    publishedAt: Date | null
    authorId: string
    createdAt: Date
    updatedAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    imageUrl?: boolean
    content?: boolean
    target?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>


  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    imageUrl?: boolean
    content?: boolean
    target?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      imageUrl: string | null
      content: string
      target: $Enums.AnnouncementTarget
      isPublished: boolean
      publishedAt: Date | null
      authorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */ 
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly imageUrl: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly target: FieldRef<"Announcement", 'AnnouncementTarget'>
    readonly isPublished: FieldRef<"Announcement", 'Boolean'>
    readonly publishedAt: FieldRef<"Announcement", 'DateTime'>
    readonly authorId: FieldRef<"Announcement", 'String'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    order: number | null
  }

  export type BannerSumAggregateOutputType = {
    order: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkUrl: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkUrl: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    linkUrl: number
    isActive: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    order?: true
  }

  export type BannerSumAggregateInputType = {
    order?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkUrl?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkUrl?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkUrl?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    title: string
    description: string | null
    imageUrl: string
    linkUrl: string | null
    isActive: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkUrl?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>


  export type BannerSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkUrl?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      imageUrl: string
      linkUrl: string | null
      isActive: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */ 
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly title: FieldRef<"Banner", 'String'>
    readonly description: FieldRef<"Banner", 'String'>
    readonly imageUrl: FieldRef<"Banner", 'String'>
    readonly linkUrl: FieldRef<"Banner", 'String'>
    readonly isActive: FieldRef<"Banner", 'Boolean'>
    readonly order: FieldRef<"Banner", 'Int'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
  }


  /**
   * Model AiSettings
   */

  export type AggregateAiSettings = {
    _count: AiSettingsCountAggregateOutputType | null
    _min: AiSettingsMinAggregateOutputType | null
    _max: AiSettingsMaxAggregateOutputType | null
  }

  export type AiSettingsMinAggregateOutputType = {
    id: string | null
    botName: string | null
    welcomeMessage: string | null
    personality: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type AiSettingsMaxAggregateOutputType = {
    id: string | null
    botName: string | null
    welcomeMessage: string | null
    personality: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type AiSettingsCountAggregateOutputType = {
    id: number
    botName: number
    welcomeMessage: number
    personality: number
    isActive: number
    updatedAt: number
    _all: number
  }


  export type AiSettingsMinAggregateInputType = {
    id?: true
    botName?: true
    welcomeMessage?: true
    personality?: true
    isActive?: true
    updatedAt?: true
  }

  export type AiSettingsMaxAggregateInputType = {
    id?: true
    botName?: true
    welcomeMessage?: true
    personality?: true
    isActive?: true
    updatedAt?: true
  }

  export type AiSettingsCountAggregateInputType = {
    id?: true
    botName?: true
    welcomeMessage?: true
    personality?: true
    isActive?: true
    updatedAt?: true
    _all?: true
  }

  export type AiSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSettings to aggregate.
     */
    where?: AiSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSettings to fetch.
     */
    orderBy?: AiSettingsOrderByWithRelationInput | AiSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiSettings
    **/
    _count?: true | AiSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiSettingsMaxAggregateInputType
  }

  export type GetAiSettingsAggregateType<T extends AiSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateAiSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiSettings[P]>
      : GetScalarType<T[P], AggregateAiSettings[P]>
  }




  export type AiSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSettingsWhereInput
    orderBy?: AiSettingsOrderByWithAggregationInput | AiSettingsOrderByWithAggregationInput[]
    by: AiSettingsScalarFieldEnum[] | AiSettingsScalarFieldEnum
    having?: AiSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiSettingsCountAggregateInputType | true
    _min?: AiSettingsMinAggregateInputType
    _max?: AiSettingsMaxAggregateInputType
  }

  export type AiSettingsGroupByOutputType = {
    id: string
    botName: string
    welcomeMessage: string
    personality: string
    isActive: boolean
    updatedAt: Date
    _count: AiSettingsCountAggregateOutputType | null
    _min: AiSettingsMinAggregateOutputType | null
    _max: AiSettingsMaxAggregateOutputType | null
  }

  type GetAiSettingsGroupByPayload<T extends AiSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], AiSettingsGroupByOutputType[P]>
        }
      >
    >


  export type AiSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botName?: boolean
    welcomeMessage?: boolean
    personality?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aiSettings"]>


  export type AiSettingsSelectScalar = {
    id?: boolean
    botName?: boolean
    welcomeMessage?: boolean
    personality?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }


  export type $AiSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botName: string
      welcomeMessage: string
      personality: string
      isActive: boolean
      updatedAt: Date
    }, ExtArgs["result"]["aiSettings"]>
    composites: {}
  }

  type AiSettingsGetPayload<S extends boolean | null | undefined | AiSettingsDefaultArgs> = $Result.GetResult<Prisma.$AiSettingsPayload, S>

  type AiSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiSettingsCountAggregateInputType | true
    }

  export interface AiSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiSettings'], meta: { name: 'AiSettings' } }
    /**
     * Find zero or one AiSettings that matches the filter.
     * @param {AiSettingsFindUniqueArgs} args - Arguments to find a AiSettings
     * @example
     * // Get one AiSettings
     * const aiSettings = await prisma.aiSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiSettingsFindUniqueArgs>(args: SelectSubset<T, AiSettingsFindUniqueArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiSettingsFindUniqueOrThrowArgs} args - Arguments to find a AiSettings
     * @example
     * // Get one AiSettings
     * const aiSettings = await prisma.aiSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, AiSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSettingsFindFirstArgs} args - Arguments to find a AiSettings
     * @example
     * // Get one AiSettings
     * const aiSettings = await prisma.aiSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiSettingsFindFirstArgs>(args?: SelectSubset<T, AiSettingsFindFirstArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSettingsFindFirstOrThrowArgs} args - Arguments to find a AiSettings
     * @example
     * // Get one AiSettings
     * const aiSettings = await prisma.aiSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, AiSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiSettings
     * const aiSettings = await prisma.aiSettings.findMany()
     * 
     * // Get first 10 AiSettings
     * const aiSettings = await prisma.aiSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiSettingsWithIdOnly = await prisma.aiSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiSettingsFindManyArgs>(args?: SelectSubset<T, AiSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiSettings.
     * @param {AiSettingsCreateArgs} args - Arguments to create a AiSettings.
     * @example
     * // Create one AiSettings
     * const AiSettings = await prisma.aiSettings.create({
     *   data: {
     *     // ... data to create a AiSettings
     *   }
     * })
     * 
     */
    create<T extends AiSettingsCreateArgs>(args: SelectSubset<T, AiSettingsCreateArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiSettings.
     * @param {AiSettingsCreateManyArgs} args - Arguments to create many AiSettings.
     * @example
     * // Create many AiSettings
     * const aiSettings = await prisma.aiSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiSettingsCreateManyArgs>(args?: SelectSubset<T, AiSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiSettings.
     * @param {AiSettingsDeleteArgs} args - Arguments to delete one AiSettings.
     * @example
     * // Delete one AiSettings
     * const AiSettings = await prisma.aiSettings.delete({
     *   where: {
     *     // ... filter to delete one AiSettings
     *   }
     * })
     * 
     */
    delete<T extends AiSettingsDeleteArgs>(args: SelectSubset<T, AiSettingsDeleteArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiSettings.
     * @param {AiSettingsUpdateArgs} args - Arguments to update one AiSettings.
     * @example
     * // Update one AiSettings
     * const aiSettings = await prisma.aiSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiSettingsUpdateArgs>(args: SelectSubset<T, AiSettingsUpdateArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiSettings.
     * @param {AiSettingsDeleteManyArgs} args - Arguments to filter AiSettings to delete.
     * @example
     * // Delete a few AiSettings
     * const { count } = await prisma.aiSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiSettingsDeleteManyArgs>(args?: SelectSubset<T, AiSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiSettings
     * const aiSettings = await prisma.aiSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiSettingsUpdateManyArgs>(args: SelectSubset<T, AiSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiSettings.
     * @param {AiSettingsUpsertArgs} args - Arguments to update or create a AiSettings.
     * @example
     * // Update or create a AiSettings
     * const aiSettings = await prisma.aiSettings.upsert({
     *   create: {
     *     // ... data to create a AiSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiSettings we want to update
     *   }
     * })
     */
    upsert<T extends AiSettingsUpsertArgs>(args: SelectSubset<T, AiSettingsUpsertArgs<ExtArgs>>): Prisma__AiSettingsClient<$Result.GetResult<Prisma.$AiSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSettingsCountArgs} args - Arguments to filter AiSettings to count.
     * @example
     * // Count the number of AiSettings
     * const count = await prisma.aiSettings.count({
     *   where: {
     *     // ... the filter for the AiSettings we want to count
     *   }
     * })
    **/
    count<T extends AiSettingsCountArgs>(
      args?: Subset<T, AiSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiSettingsAggregateArgs>(args: Subset<T, AiSettingsAggregateArgs>): Prisma.PrismaPromise<GetAiSettingsAggregateType<T>>

    /**
     * Group by AiSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiSettingsGroupByArgs['orderBy'] }
        : { orderBy?: AiSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiSettings model
   */
  readonly fields: AiSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiSettings model
   */ 
  interface AiSettingsFieldRefs {
    readonly id: FieldRef<"AiSettings", 'String'>
    readonly botName: FieldRef<"AiSettings", 'String'>
    readonly welcomeMessage: FieldRef<"AiSettings", 'String'>
    readonly personality: FieldRef<"AiSettings", 'String'>
    readonly isActive: FieldRef<"AiSettings", 'Boolean'>
    readonly updatedAt: FieldRef<"AiSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiSettings findUnique
   */
  export type AiSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AiSettings to fetch.
     */
    where: AiSettingsWhereUniqueInput
  }

  /**
   * AiSettings findUniqueOrThrow
   */
  export type AiSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AiSettings to fetch.
     */
    where: AiSettingsWhereUniqueInput
  }

  /**
   * AiSettings findFirst
   */
  export type AiSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AiSettings to fetch.
     */
    where?: AiSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSettings to fetch.
     */
    orderBy?: AiSettingsOrderByWithRelationInput | AiSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSettings.
     */
    cursor?: AiSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSettings.
     */
    distinct?: AiSettingsScalarFieldEnum | AiSettingsScalarFieldEnum[]
  }

  /**
   * AiSettings findFirstOrThrow
   */
  export type AiSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AiSettings to fetch.
     */
    where?: AiSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSettings to fetch.
     */
    orderBy?: AiSettingsOrderByWithRelationInput | AiSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSettings.
     */
    cursor?: AiSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSettings.
     */
    distinct?: AiSettingsScalarFieldEnum | AiSettingsScalarFieldEnum[]
  }

  /**
   * AiSettings findMany
   */
  export type AiSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AiSettings to fetch.
     */
    where?: AiSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSettings to fetch.
     */
    orderBy?: AiSettingsOrderByWithRelationInput | AiSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiSettings.
     */
    cursor?: AiSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSettings.
     */
    skip?: number
    distinct?: AiSettingsScalarFieldEnum | AiSettingsScalarFieldEnum[]
  }

  /**
   * AiSettings create
   */
  export type AiSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a AiSettings.
     */
    data: XOR<AiSettingsCreateInput, AiSettingsUncheckedCreateInput>
  }

  /**
   * AiSettings createMany
   */
  export type AiSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiSettings.
     */
    data: AiSettingsCreateManyInput | AiSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiSettings update
   */
  export type AiSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a AiSettings.
     */
    data: XOR<AiSettingsUpdateInput, AiSettingsUncheckedUpdateInput>
    /**
     * Choose, which AiSettings to update.
     */
    where: AiSettingsWhereUniqueInput
  }

  /**
   * AiSettings updateMany
   */
  export type AiSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiSettings.
     */
    data: XOR<AiSettingsUpdateManyMutationInput, AiSettingsUncheckedUpdateManyInput>
    /**
     * Filter which AiSettings to update
     */
    where?: AiSettingsWhereInput
  }

  /**
   * AiSettings upsert
   */
  export type AiSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the AiSettings to update in case it exists.
     */
    where: AiSettingsWhereUniqueInput
    /**
     * In case the AiSettings found by the `where` argument doesn't exist, create a new AiSettings with this data.
     */
    create: XOR<AiSettingsCreateInput, AiSettingsUncheckedCreateInput>
    /**
     * In case the AiSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiSettingsUpdateInput, AiSettingsUncheckedUpdateInput>
  }

  /**
   * AiSettings delete
   */
  export type AiSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
    /**
     * Filter which AiSettings to delete.
     */
    where: AiSettingsWhereUniqueInput
  }

  /**
   * AiSettings deleteMany
   */
  export type AiSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSettings to delete
     */
    where?: AiSettingsWhereInput
  }

  /**
   * AiSettings without action
   */
  export type AiSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSettings
     */
    select?: AiSettingsSelect<ExtArgs> | null
  }


  /**
   * Model AiKnowledgeBase
   */

  export type AggregateAiKnowledgeBase = {
    _count: AiKnowledgeBaseCountAggregateOutputType | null
    _min: AiKnowledgeBaseMinAggregateOutputType | null
    _max: AiKnowledgeBaseMaxAggregateOutputType | null
  }

  export type AiKnowledgeBaseMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiKnowledgeBaseMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiKnowledgeBaseCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiKnowledgeBaseMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiKnowledgeBaseMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiKnowledgeBaseCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiKnowledgeBaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiKnowledgeBase to aggregate.
     */
    where?: AiKnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiKnowledgeBases to fetch.
     */
    orderBy?: AiKnowledgeBaseOrderByWithRelationInput | AiKnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiKnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiKnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiKnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiKnowledgeBases
    **/
    _count?: true | AiKnowledgeBaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiKnowledgeBaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiKnowledgeBaseMaxAggregateInputType
  }

  export type GetAiKnowledgeBaseAggregateType<T extends AiKnowledgeBaseAggregateArgs> = {
        [P in keyof T & keyof AggregateAiKnowledgeBase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiKnowledgeBase[P]>
      : GetScalarType<T[P], AggregateAiKnowledgeBase[P]>
  }




  export type AiKnowledgeBaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiKnowledgeBaseWhereInput
    orderBy?: AiKnowledgeBaseOrderByWithAggregationInput | AiKnowledgeBaseOrderByWithAggregationInput[]
    by: AiKnowledgeBaseScalarFieldEnum[] | AiKnowledgeBaseScalarFieldEnum
    having?: AiKnowledgeBaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiKnowledgeBaseCountAggregateInputType | true
    _min?: AiKnowledgeBaseMinAggregateInputType
    _max?: AiKnowledgeBaseMaxAggregateInputType
  }

  export type AiKnowledgeBaseGroupByOutputType = {
    id: string
    question: string
    answer: string
    category: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AiKnowledgeBaseCountAggregateOutputType | null
    _min: AiKnowledgeBaseMinAggregateOutputType | null
    _max: AiKnowledgeBaseMaxAggregateOutputType | null
  }

  type GetAiKnowledgeBaseGroupByPayload<T extends AiKnowledgeBaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiKnowledgeBaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiKnowledgeBaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiKnowledgeBaseGroupByOutputType[P]>
            : GetScalarType<T[P], AiKnowledgeBaseGroupByOutputType[P]>
        }
      >
    >


  export type AiKnowledgeBaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aiKnowledgeBase"]>


  export type AiKnowledgeBaseSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AiKnowledgeBasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiKnowledgeBase"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      category: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiKnowledgeBase"]>
    composites: {}
  }

  type AiKnowledgeBaseGetPayload<S extends boolean | null | undefined | AiKnowledgeBaseDefaultArgs> = $Result.GetResult<Prisma.$AiKnowledgeBasePayload, S>

  type AiKnowledgeBaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiKnowledgeBaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiKnowledgeBaseCountAggregateInputType | true
    }

  export interface AiKnowledgeBaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiKnowledgeBase'], meta: { name: 'AiKnowledgeBase' } }
    /**
     * Find zero or one AiKnowledgeBase that matches the filter.
     * @param {AiKnowledgeBaseFindUniqueArgs} args - Arguments to find a AiKnowledgeBase
     * @example
     * // Get one AiKnowledgeBase
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiKnowledgeBaseFindUniqueArgs>(args: SelectSubset<T, AiKnowledgeBaseFindUniqueArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiKnowledgeBase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiKnowledgeBaseFindUniqueOrThrowArgs} args - Arguments to find a AiKnowledgeBase
     * @example
     * // Get one AiKnowledgeBase
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiKnowledgeBaseFindUniqueOrThrowArgs>(args: SelectSubset<T, AiKnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiKnowledgeBase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiKnowledgeBaseFindFirstArgs} args - Arguments to find a AiKnowledgeBase
     * @example
     * // Get one AiKnowledgeBase
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiKnowledgeBaseFindFirstArgs>(args?: SelectSubset<T, AiKnowledgeBaseFindFirstArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiKnowledgeBase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiKnowledgeBaseFindFirstOrThrowArgs} args - Arguments to find a AiKnowledgeBase
     * @example
     * // Get one AiKnowledgeBase
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiKnowledgeBaseFindFirstOrThrowArgs>(args?: SelectSubset<T, AiKnowledgeBaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiKnowledgeBases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiKnowledgeBaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiKnowledgeBases
     * const aiKnowledgeBases = await prisma.aiKnowledgeBase.findMany()
     * 
     * // Get first 10 AiKnowledgeBases
     * const aiKnowledgeBases = await prisma.aiKnowledgeBase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiKnowledgeBaseWithIdOnly = await prisma.aiKnowledgeBase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiKnowledgeBaseFindManyArgs>(args?: SelectSubset<T, AiKnowledgeBaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiKnowledgeBase.
     * @param {AiKnowledgeBaseCreateArgs} args - Arguments to create a AiKnowledgeBase.
     * @example
     * // Create one AiKnowledgeBase
     * const AiKnowledgeBase = await prisma.aiKnowledgeBase.create({
     *   data: {
     *     // ... data to create a AiKnowledgeBase
     *   }
     * })
     * 
     */
    create<T extends AiKnowledgeBaseCreateArgs>(args: SelectSubset<T, AiKnowledgeBaseCreateArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiKnowledgeBases.
     * @param {AiKnowledgeBaseCreateManyArgs} args - Arguments to create many AiKnowledgeBases.
     * @example
     * // Create many AiKnowledgeBases
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiKnowledgeBaseCreateManyArgs>(args?: SelectSubset<T, AiKnowledgeBaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiKnowledgeBase.
     * @param {AiKnowledgeBaseDeleteArgs} args - Arguments to delete one AiKnowledgeBase.
     * @example
     * // Delete one AiKnowledgeBase
     * const AiKnowledgeBase = await prisma.aiKnowledgeBase.delete({
     *   where: {
     *     // ... filter to delete one AiKnowledgeBase
     *   }
     * })
     * 
     */
    delete<T extends AiKnowledgeBaseDeleteArgs>(args: SelectSubset<T, AiKnowledgeBaseDeleteArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiKnowledgeBase.
     * @param {AiKnowledgeBaseUpdateArgs} args - Arguments to update one AiKnowledgeBase.
     * @example
     * // Update one AiKnowledgeBase
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiKnowledgeBaseUpdateArgs>(args: SelectSubset<T, AiKnowledgeBaseUpdateArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiKnowledgeBases.
     * @param {AiKnowledgeBaseDeleteManyArgs} args - Arguments to filter AiKnowledgeBases to delete.
     * @example
     * // Delete a few AiKnowledgeBases
     * const { count } = await prisma.aiKnowledgeBase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiKnowledgeBaseDeleteManyArgs>(args?: SelectSubset<T, AiKnowledgeBaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiKnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiKnowledgeBaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiKnowledgeBases
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiKnowledgeBaseUpdateManyArgs>(args: SelectSubset<T, AiKnowledgeBaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiKnowledgeBase.
     * @param {AiKnowledgeBaseUpsertArgs} args - Arguments to update or create a AiKnowledgeBase.
     * @example
     * // Update or create a AiKnowledgeBase
     * const aiKnowledgeBase = await prisma.aiKnowledgeBase.upsert({
     *   create: {
     *     // ... data to create a AiKnowledgeBase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiKnowledgeBase we want to update
     *   }
     * })
     */
    upsert<T extends AiKnowledgeBaseUpsertArgs>(args: SelectSubset<T, AiKnowledgeBaseUpsertArgs<ExtArgs>>): Prisma__AiKnowledgeBaseClient<$Result.GetResult<Prisma.$AiKnowledgeBasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiKnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiKnowledgeBaseCountArgs} args - Arguments to filter AiKnowledgeBases to count.
     * @example
     * // Count the number of AiKnowledgeBases
     * const count = await prisma.aiKnowledgeBase.count({
     *   where: {
     *     // ... the filter for the AiKnowledgeBases we want to count
     *   }
     * })
    **/
    count<T extends AiKnowledgeBaseCountArgs>(
      args?: Subset<T, AiKnowledgeBaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiKnowledgeBaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiKnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiKnowledgeBaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiKnowledgeBaseAggregateArgs>(args: Subset<T, AiKnowledgeBaseAggregateArgs>): Prisma.PrismaPromise<GetAiKnowledgeBaseAggregateType<T>>

    /**
     * Group by AiKnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiKnowledgeBaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiKnowledgeBaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiKnowledgeBaseGroupByArgs['orderBy'] }
        : { orderBy?: AiKnowledgeBaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiKnowledgeBaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiKnowledgeBaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiKnowledgeBase model
   */
  readonly fields: AiKnowledgeBaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiKnowledgeBase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiKnowledgeBaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiKnowledgeBase model
   */ 
  interface AiKnowledgeBaseFieldRefs {
    readonly id: FieldRef<"AiKnowledgeBase", 'String'>
    readonly question: FieldRef<"AiKnowledgeBase", 'String'>
    readonly answer: FieldRef<"AiKnowledgeBase", 'String'>
    readonly category: FieldRef<"AiKnowledgeBase", 'String'>
    readonly isActive: FieldRef<"AiKnowledgeBase", 'Boolean'>
    readonly createdAt: FieldRef<"AiKnowledgeBase", 'DateTime'>
    readonly updatedAt: FieldRef<"AiKnowledgeBase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiKnowledgeBase findUnique
   */
  export type AiKnowledgeBaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * Filter, which AiKnowledgeBase to fetch.
     */
    where: AiKnowledgeBaseWhereUniqueInput
  }

  /**
   * AiKnowledgeBase findUniqueOrThrow
   */
  export type AiKnowledgeBaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * Filter, which AiKnowledgeBase to fetch.
     */
    where: AiKnowledgeBaseWhereUniqueInput
  }

  /**
   * AiKnowledgeBase findFirst
   */
  export type AiKnowledgeBaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * Filter, which AiKnowledgeBase to fetch.
     */
    where?: AiKnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiKnowledgeBases to fetch.
     */
    orderBy?: AiKnowledgeBaseOrderByWithRelationInput | AiKnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiKnowledgeBases.
     */
    cursor?: AiKnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiKnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiKnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiKnowledgeBases.
     */
    distinct?: AiKnowledgeBaseScalarFieldEnum | AiKnowledgeBaseScalarFieldEnum[]
  }

  /**
   * AiKnowledgeBase findFirstOrThrow
   */
  export type AiKnowledgeBaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * Filter, which AiKnowledgeBase to fetch.
     */
    where?: AiKnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiKnowledgeBases to fetch.
     */
    orderBy?: AiKnowledgeBaseOrderByWithRelationInput | AiKnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiKnowledgeBases.
     */
    cursor?: AiKnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiKnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiKnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiKnowledgeBases.
     */
    distinct?: AiKnowledgeBaseScalarFieldEnum | AiKnowledgeBaseScalarFieldEnum[]
  }

  /**
   * AiKnowledgeBase findMany
   */
  export type AiKnowledgeBaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * Filter, which AiKnowledgeBases to fetch.
     */
    where?: AiKnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiKnowledgeBases to fetch.
     */
    orderBy?: AiKnowledgeBaseOrderByWithRelationInput | AiKnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiKnowledgeBases.
     */
    cursor?: AiKnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiKnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiKnowledgeBases.
     */
    skip?: number
    distinct?: AiKnowledgeBaseScalarFieldEnum | AiKnowledgeBaseScalarFieldEnum[]
  }

  /**
   * AiKnowledgeBase create
   */
  export type AiKnowledgeBaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * The data needed to create a AiKnowledgeBase.
     */
    data: XOR<AiKnowledgeBaseCreateInput, AiKnowledgeBaseUncheckedCreateInput>
  }

  /**
   * AiKnowledgeBase createMany
   */
  export type AiKnowledgeBaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiKnowledgeBases.
     */
    data: AiKnowledgeBaseCreateManyInput | AiKnowledgeBaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiKnowledgeBase update
   */
  export type AiKnowledgeBaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * The data needed to update a AiKnowledgeBase.
     */
    data: XOR<AiKnowledgeBaseUpdateInput, AiKnowledgeBaseUncheckedUpdateInput>
    /**
     * Choose, which AiKnowledgeBase to update.
     */
    where: AiKnowledgeBaseWhereUniqueInput
  }

  /**
   * AiKnowledgeBase updateMany
   */
  export type AiKnowledgeBaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiKnowledgeBases.
     */
    data: XOR<AiKnowledgeBaseUpdateManyMutationInput, AiKnowledgeBaseUncheckedUpdateManyInput>
    /**
     * Filter which AiKnowledgeBases to update
     */
    where?: AiKnowledgeBaseWhereInput
  }

  /**
   * AiKnowledgeBase upsert
   */
  export type AiKnowledgeBaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * The filter to search for the AiKnowledgeBase to update in case it exists.
     */
    where: AiKnowledgeBaseWhereUniqueInput
    /**
     * In case the AiKnowledgeBase found by the `where` argument doesn't exist, create a new AiKnowledgeBase with this data.
     */
    create: XOR<AiKnowledgeBaseCreateInput, AiKnowledgeBaseUncheckedCreateInput>
    /**
     * In case the AiKnowledgeBase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiKnowledgeBaseUpdateInput, AiKnowledgeBaseUncheckedUpdateInput>
  }

  /**
   * AiKnowledgeBase delete
   */
  export type AiKnowledgeBaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
    /**
     * Filter which AiKnowledgeBase to delete.
     */
    where: AiKnowledgeBaseWhereUniqueInput
  }

  /**
   * AiKnowledgeBase deleteMany
   */
  export type AiKnowledgeBaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiKnowledgeBases to delete
     */
    where?: AiKnowledgeBaseWhereInput
  }

  /**
   * AiKnowledgeBase without action
   */
  export type AiKnowledgeBaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiKnowledgeBase
     */
    select?: AiKnowledgeBaseSelect<ExtArgs> | null
  }


  /**
   * Model AiConversation
   */

  export type AggregateAiConversation = {
    _count: AiConversationCountAggregateOutputType | null
    _min: AiConversationMinAggregateOutputType | null
    _max: AiConversationMaxAggregateOutputType | null
  }

  export type AiConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiConversationCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiConversationMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiConversationCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiConversation to aggregate.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiConversations
    **/
    _count?: true | AiConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiConversationMaxAggregateInputType
  }

  export type GetAiConversationAggregateType<T extends AiConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateAiConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiConversation[P]>
      : GetScalarType<T[P], AggregateAiConversation[P]>
  }




  export type AiConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiConversationWhereInput
    orderBy?: AiConversationOrderByWithAggregationInput | AiConversationOrderByWithAggregationInput[]
    by: AiConversationScalarFieldEnum[] | AiConversationScalarFieldEnum
    having?: AiConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiConversationCountAggregateInputType | true
    _min?: AiConversationMinAggregateInputType
    _max?: AiConversationMaxAggregateInputType
  }

  export type AiConversationGroupByOutputType = {
    id: string
    userId: string | null
    sessionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AiConversationCountAggregateOutputType | null
    _min: AiConversationMinAggregateOutputType | null
    _max: AiConversationMaxAggregateOutputType | null
  }

  type GetAiConversationGroupByPayload<T extends AiConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiConversationGroupByOutputType[P]>
            : GetScalarType<T[P], AiConversationGroupByOutputType[P]>
        }
      >
    >


  export type AiConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | AiConversation$messagesArgs<ExtArgs>
    _count?: boolean | AiConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiConversation"]>


  export type AiConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AiConversation$messagesArgs<ExtArgs>
    _count?: boolean | AiConversationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AiConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiConversation"
    objects: {
      messages: Prisma.$AiMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      sessionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiConversation"]>
    composites: {}
  }

  type AiConversationGetPayload<S extends boolean | null | undefined | AiConversationDefaultArgs> = $Result.GetResult<Prisma.$AiConversationPayload, S>

  type AiConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiConversationCountAggregateInputType | true
    }

  export interface AiConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiConversation'], meta: { name: 'AiConversation' } }
    /**
     * Find zero or one AiConversation that matches the filter.
     * @param {AiConversationFindUniqueArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiConversationFindUniqueArgs>(args: SelectSubset<T, AiConversationFindUniqueArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiConversationFindUniqueOrThrowArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, AiConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindFirstArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiConversationFindFirstArgs>(args?: SelectSubset<T, AiConversationFindFirstArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindFirstOrThrowArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, AiConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiConversations
     * const aiConversations = await prisma.aiConversation.findMany()
     * 
     * // Get first 10 AiConversations
     * const aiConversations = await prisma.aiConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiConversationWithIdOnly = await prisma.aiConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiConversationFindManyArgs>(args?: SelectSubset<T, AiConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiConversation.
     * @param {AiConversationCreateArgs} args - Arguments to create a AiConversation.
     * @example
     * // Create one AiConversation
     * const AiConversation = await prisma.aiConversation.create({
     *   data: {
     *     // ... data to create a AiConversation
     *   }
     * })
     * 
     */
    create<T extends AiConversationCreateArgs>(args: SelectSubset<T, AiConversationCreateArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiConversations.
     * @param {AiConversationCreateManyArgs} args - Arguments to create many AiConversations.
     * @example
     * // Create many AiConversations
     * const aiConversation = await prisma.aiConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiConversationCreateManyArgs>(args?: SelectSubset<T, AiConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiConversation.
     * @param {AiConversationDeleteArgs} args - Arguments to delete one AiConversation.
     * @example
     * // Delete one AiConversation
     * const AiConversation = await prisma.aiConversation.delete({
     *   where: {
     *     // ... filter to delete one AiConversation
     *   }
     * })
     * 
     */
    delete<T extends AiConversationDeleteArgs>(args: SelectSubset<T, AiConversationDeleteArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiConversation.
     * @param {AiConversationUpdateArgs} args - Arguments to update one AiConversation.
     * @example
     * // Update one AiConversation
     * const aiConversation = await prisma.aiConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiConversationUpdateArgs>(args: SelectSubset<T, AiConversationUpdateArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiConversations.
     * @param {AiConversationDeleteManyArgs} args - Arguments to filter AiConversations to delete.
     * @example
     * // Delete a few AiConversations
     * const { count } = await prisma.aiConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiConversationDeleteManyArgs>(args?: SelectSubset<T, AiConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiConversations
     * const aiConversation = await prisma.aiConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiConversationUpdateManyArgs>(args: SelectSubset<T, AiConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiConversation.
     * @param {AiConversationUpsertArgs} args - Arguments to update or create a AiConversation.
     * @example
     * // Update or create a AiConversation
     * const aiConversation = await prisma.aiConversation.upsert({
     *   create: {
     *     // ... data to create a AiConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiConversation we want to update
     *   }
     * })
     */
    upsert<T extends AiConversationUpsertArgs>(args: SelectSubset<T, AiConversationUpsertArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationCountArgs} args - Arguments to filter AiConversations to count.
     * @example
     * // Count the number of AiConversations
     * const count = await prisma.aiConversation.count({
     *   where: {
     *     // ... the filter for the AiConversations we want to count
     *   }
     * })
    **/
    count<T extends AiConversationCountArgs>(
      args?: Subset<T, AiConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiConversationAggregateArgs>(args: Subset<T, AiConversationAggregateArgs>): Prisma.PrismaPromise<GetAiConversationAggregateType<T>>

    /**
     * Group by AiConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiConversationGroupByArgs['orderBy'] }
        : { orderBy?: AiConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiConversation model
   */
  readonly fields: AiConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends AiConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AiConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiConversation model
   */ 
  interface AiConversationFieldRefs {
    readonly id: FieldRef<"AiConversation", 'String'>
    readonly userId: FieldRef<"AiConversation", 'String'>
    readonly sessionId: FieldRef<"AiConversation", 'String'>
    readonly createdAt: FieldRef<"AiConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"AiConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiConversation findUnique
   */
  export type AiConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation findUniqueOrThrow
   */
  export type AiConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation findFirst
   */
  export type AiConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiConversations.
     */
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation findFirstOrThrow
   */
  export type AiConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiConversations.
     */
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation findMany
   */
  export type AiConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversations to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation create
   */
  export type AiConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a AiConversation.
     */
    data: XOR<AiConversationCreateInput, AiConversationUncheckedCreateInput>
  }

  /**
   * AiConversation createMany
   */
  export type AiConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiConversations.
     */
    data: AiConversationCreateManyInput | AiConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiConversation update
   */
  export type AiConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a AiConversation.
     */
    data: XOR<AiConversationUpdateInput, AiConversationUncheckedUpdateInput>
    /**
     * Choose, which AiConversation to update.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation updateMany
   */
  export type AiConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiConversations.
     */
    data: XOR<AiConversationUpdateManyMutationInput, AiConversationUncheckedUpdateManyInput>
    /**
     * Filter which AiConversations to update
     */
    where?: AiConversationWhereInput
  }

  /**
   * AiConversation upsert
   */
  export type AiConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the AiConversation to update in case it exists.
     */
    where: AiConversationWhereUniqueInput
    /**
     * In case the AiConversation found by the `where` argument doesn't exist, create a new AiConversation with this data.
     */
    create: XOR<AiConversationCreateInput, AiConversationUncheckedCreateInput>
    /**
     * In case the AiConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiConversationUpdateInput, AiConversationUncheckedUpdateInput>
  }

  /**
   * AiConversation delete
   */
  export type AiConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter which AiConversation to delete.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation deleteMany
   */
  export type AiConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiConversations to delete
     */
    where?: AiConversationWhereInput
  }

  /**
   * AiConversation.messages
   */
  export type AiConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    where?: AiMessageWhereInput
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    cursor?: AiMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiConversation without action
   */
  export type AiConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
  }


  /**
   * Model AiMessage
   */

  export type AggregateAiMessage = {
    _count: AiMessageCountAggregateOutputType | null
    _min: AiMessageMinAggregateOutputType | null
    _max: AiMessageMaxAggregateOutputType | null
  }

  export type AiMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AiMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AiMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    createdAt: number
    _all: number
  }


  export type AiMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type AiMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type AiMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AiMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMessage to aggregate.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiMessages
    **/
    _count?: true | AiMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiMessageMaxAggregateInputType
  }

  export type GetAiMessageAggregateType<T extends AiMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAiMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiMessage[P]>
      : GetScalarType<T[P], AggregateAiMessage[P]>
  }




  export type AiMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMessageWhereInput
    orderBy?: AiMessageOrderByWithAggregationInput | AiMessageOrderByWithAggregationInput[]
    by: AiMessageScalarFieldEnum[] | AiMessageScalarFieldEnum
    having?: AiMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiMessageCountAggregateInputType | true
    _min?: AiMessageMinAggregateInputType
    _max?: AiMessageMaxAggregateInputType
  }

  export type AiMessageGroupByOutputType = {
    id: string
    conversationId: string
    role: string
    content: string
    createdAt: Date
    _count: AiMessageCountAggregateOutputType | null
    _min: AiMessageMinAggregateOutputType | null
    _max: AiMessageMaxAggregateOutputType | null
  }

  type GetAiMessageGroupByPayload<T extends AiMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AiMessageGroupByOutputType[P]>
        }
      >
    >


  export type AiMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMessage"]>


  export type AiMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AiMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }

  export type $AiMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiMessage"
    objects: {
      conversation: Prisma.$AiConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["aiMessage"]>
    composites: {}
  }

  type AiMessageGetPayload<S extends boolean | null | undefined | AiMessageDefaultArgs> = $Result.GetResult<Prisma.$AiMessagePayload, S>

  type AiMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiMessageCountAggregateInputType | true
    }

  export interface AiMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiMessage'], meta: { name: 'AiMessage' } }
    /**
     * Find zero or one AiMessage that matches the filter.
     * @param {AiMessageFindUniqueArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiMessageFindUniqueArgs>(args: SelectSubset<T, AiMessageFindUniqueArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiMessageFindUniqueOrThrowArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AiMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindFirstArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiMessageFindFirstArgs>(args?: SelectSubset<T, AiMessageFindFirstArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindFirstOrThrowArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AiMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiMessages
     * const aiMessages = await prisma.aiMessage.findMany()
     * 
     * // Get first 10 AiMessages
     * const aiMessages = await prisma.aiMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiMessageWithIdOnly = await prisma.aiMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiMessageFindManyArgs>(args?: SelectSubset<T, AiMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiMessage.
     * @param {AiMessageCreateArgs} args - Arguments to create a AiMessage.
     * @example
     * // Create one AiMessage
     * const AiMessage = await prisma.aiMessage.create({
     *   data: {
     *     // ... data to create a AiMessage
     *   }
     * })
     * 
     */
    create<T extends AiMessageCreateArgs>(args: SelectSubset<T, AiMessageCreateArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiMessages.
     * @param {AiMessageCreateManyArgs} args - Arguments to create many AiMessages.
     * @example
     * // Create many AiMessages
     * const aiMessage = await prisma.aiMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiMessageCreateManyArgs>(args?: SelectSubset<T, AiMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiMessage.
     * @param {AiMessageDeleteArgs} args - Arguments to delete one AiMessage.
     * @example
     * // Delete one AiMessage
     * const AiMessage = await prisma.aiMessage.delete({
     *   where: {
     *     // ... filter to delete one AiMessage
     *   }
     * })
     * 
     */
    delete<T extends AiMessageDeleteArgs>(args: SelectSubset<T, AiMessageDeleteArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiMessage.
     * @param {AiMessageUpdateArgs} args - Arguments to update one AiMessage.
     * @example
     * // Update one AiMessage
     * const aiMessage = await prisma.aiMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiMessageUpdateArgs>(args: SelectSubset<T, AiMessageUpdateArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiMessages.
     * @param {AiMessageDeleteManyArgs} args - Arguments to filter AiMessages to delete.
     * @example
     * // Delete a few AiMessages
     * const { count } = await prisma.aiMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiMessageDeleteManyArgs>(args?: SelectSubset<T, AiMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiMessages
     * const aiMessage = await prisma.aiMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiMessageUpdateManyArgs>(args: SelectSubset<T, AiMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiMessage.
     * @param {AiMessageUpsertArgs} args - Arguments to update or create a AiMessage.
     * @example
     * // Update or create a AiMessage
     * const aiMessage = await prisma.aiMessage.upsert({
     *   create: {
     *     // ... data to create a AiMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiMessage we want to update
     *   }
     * })
     */
    upsert<T extends AiMessageUpsertArgs>(args: SelectSubset<T, AiMessageUpsertArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageCountArgs} args - Arguments to filter AiMessages to count.
     * @example
     * // Count the number of AiMessages
     * const count = await prisma.aiMessage.count({
     *   where: {
     *     // ... the filter for the AiMessages we want to count
     *   }
     * })
    **/
    count<T extends AiMessageCountArgs>(
      args?: Subset<T, AiMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiMessageAggregateArgs>(args: Subset<T, AiMessageAggregateArgs>): Prisma.PrismaPromise<GetAiMessageAggregateType<T>>

    /**
     * Group by AiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiMessageGroupByArgs['orderBy'] }
        : { orderBy?: AiMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiMessage model
   */
  readonly fields: AiMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends AiConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiConversationDefaultArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiMessage model
   */ 
  interface AiMessageFieldRefs {
    readonly id: FieldRef<"AiMessage", 'String'>
    readonly conversationId: FieldRef<"AiMessage", 'String'>
    readonly role: FieldRef<"AiMessage", 'String'>
    readonly content: FieldRef<"AiMessage", 'String'>
    readonly createdAt: FieldRef<"AiMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiMessage findUnique
   */
  export type AiMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage findUniqueOrThrow
   */
  export type AiMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage findFirst
   */
  export type AiMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMessages.
     */
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage findFirstOrThrow
   */
  export type AiMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMessages.
     */
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage findMany
   */
  export type AiMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessages to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage create
   */
  export type AiMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AiMessage.
     */
    data: XOR<AiMessageCreateInput, AiMessageUncheckedCreateInput>
  }

  /**
   * AiMessage createMany
   */
  export type AiMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiMessages.
     */
    data: AiMessageCreateManyInput | AiMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiMessage update
   */
  export type AiMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AiMessage.
     */
    data: XOR<AiMessageUpdateInput, AiMessageUncheckedUpdateInput>
    /**
     * Choose, which AiMessage to update.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage updateMany
   */
  export type AiMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiMessages.
     */
    data: XOR<AiMessageUpdateManyMutationInput, AiMessageUncheckedUpdateManyInput>
    /**
     * Filter which AiMessages to update
     */
    where?: AiMessageWhereInput
  }

  /**
   * AiMessage upsert
   */
  export type AiMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AiMessage to update in case it exists.
     */
    where: AiMessageWhereUniqueInput
    /**
     * In case the AiMessage found by the `where` argument doesn't exist, create a new AiMessage with this data.
     */
    create: XOR<AiMessageCreateInput, AiMessageUncheckedCreateInput>
    /**
     * In case the AiMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiMessageUpdateInput, AiMessageUncheckedUpdateInput>
  }

  /**
   * AiMessage delete
   */
  export type AiMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter which AiMessage to delete.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage deleteMany
   */
  export type AiMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMessages to delete
     */
    where?: AiMessageWhereInput
  }

  /**
   * AiMessage without action
   */
  export type AiMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
  }


  /**
   * Model HelpCategory
   */

  export type AggregateHelpCategory = {
    _count: HelpCategoryCountAggregateOutputType | null
    _avg: HelpCategoryAvgAggregateOutputType | null
    _sum: HelpCategorySumAggregateOutputType | null
    _min: HelpCategoryMinAggregateOutputType | null
    _max: HelpCategoryMaxAggregateOutputType | null
  }

  export type HelpCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type HelpCategorySumAggregateOutputType = {
    order: number | null
  }

  export type HelpCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpCategoryAvgAggregateInputType = {
    order?: true
  }

  export type HelpCategorySumAggregateInputType = {
    order?: true
  }

  export type HelpCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCategory to aggregate.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpCategories
    **/
    _count?: true | HelpCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpCategoryMaxAggregateInputType
  }

  export type GetHelpCategoryAggregateType<T extends HelpCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpCategory[P]>
      : GetScalarType<T[P], AggregateHelpCategory[P]>
  }




  export type HelpCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpCategoryWhereInput
    orderBy?: HelpCategoryOrderByWithAggregationInput | HelpCategoryOrderByWithAggregationInput[]
    by: HelpCategoryScalarFieldEnum[] | HelpCategoryScalarFieldEnum
    having?: HelpCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCategoryCountAggregateInputType | true
    _avg?: HelpCategoryAvgAggregateInputType
    _sum?: HelpCategorySumAggregateInputType
    _min?: HelpCategoryMinAggregateInputType
    _max?: HelpCategoryMaxAggregateInputType
  }

  export type HelpCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: HelpCategoryCountAggregateOutputType | null
    _avg: HelpCategoryAvgAggregateOutputType | null
    _sum: HelpCategorySumAggregateOutputType | null
    _min: HelpCategoryMinAggregateOutputType | null
    _max: HelpCategoryMaxAggregateOutputType | null
  }

  type GetHelpCategoryGroupByPayload<T extends HelpCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], HelpCategoryGroupByOutputType[P]>
        }
      >
    >


  export type HelpCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    articles?: boolean | HelpCategory$articlesArgs<ExtArgs>
    _count?: boolean | HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCategory"]>


  export type HelpCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HelpCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | HelpCategory$articlesArgs<ExtArgs>
    _count?: boolean | HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $HelpCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpCategory"
    objects: {
      articles: Prisma.$HelpArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["helpCategory"]>
    composites: {}
  }

  type HelpCategoryGetPayload<S extends boolean | null | undefined | HelpCategoryDefaultArgs> = $Result.GetResult<Prisma.$HelpCategoryPayload, S>

  type HelpCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpCategoryCountAggregateInputType | true
    }

  export interface HelpCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpCategory'], meta: { name: 'HelpCategory' } }
    /**
     * Find zero or one HelpCategory that matches the filter.
     * @param {HelpCategoryFindUniqueArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpCategoryFindUniqueArgs>(args: SelectSubset<T, HelpCategoryFindUniqueArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpCategoryFindUniqueOrThrowArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryFindFirstArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpCategoryFindFirstArgs>(args?: SelectSubset<T, HelpCategoryFindFirstArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryFindFirstOrThrowArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpCategories
     * const helpCategories = await prisma.helpCategory.findMany()
     * 
     * // Get first 10 HelpCategories
     * const helpCategories = await prisma.helpCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpCategoryWithIdOnly = await prisma.helpCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpCategoryFindManyArgs>(args?: SelectSubset<T, HelpCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpCategory.
     * @param {HelpCategoryCreateArgs} args - Arguments to create a HelpCategory.
     * @example
     * // Create one HelpCategory
     * const HelpCategory = await prisma.helpCategory.create({
     *   data: {
     *     // ... data to create a HelpCategory
     *   }
     * })
     * 
     */
    create<T extends HelpCategoryCreateArgs>(args: SelectSubset<T, HelpCategoryCreateArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpCategories.
     * @param {HelpCategoryCreateManyArgs} args - Arguments to create many HelpCategories.
     * @example
     * // Create many HelpCategories
     * const helpCategory = await prisma.helpCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpCategoryCreateManyArgs>(args?: SelectSubset<T, HelpCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HelpCategory.
     * @param {HelpCategoryDeleteArgs} args - Arguments to delete one HelpCategory.
     * @example
     * // Delete one HelpCategory
     * const HelpCategory = await prisma.helpCategory.delete({
     *   where: {
     *     // ... filter to delete one HelpCategory
     *   }
     * })
     * 
     */
    delete<T extends HelpCategoryDeleteArgs>(args: SelectSubset<T, HelpCategoryDeleteArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpCategory.
     * @param {HelpCategoryUpdateArgs} args - Arguments to update one HelpCategory.
     * @example
     * // Update one HelpCategory
     * const helpCategory = await prisma.helpCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpCategoryUpdateArgs>(args: SelectSubset<T, HelpCategoryUpdateArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpCategories.
     * @param {HelpCategoryDeleteManyArgs} args - Arguments to filter HelpCategories to delete.
     * @example
     * // Delete a few HelpCategories
     * const { count } = await prisma.helpCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpCategoryDeleteManyArgs>(args?: SelectSubset<T, HelpCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpCategories
     * const helpCategory = await prisma.helpCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpCategoryUpdateManyArgs>(args: SelectSubset<T, HelpCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpCategory.
     * @param {HelpCategoryUpsertArgs} args - Arguments to update or create a HelpCategory.
     * @example
     * // Update or create a HelpCategory
     * const helpCategory = await prisma.helpCategory.upsert({
     *   create: {
     *     // ... data to create a HelpCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpCategory we want to update
     *   }
     * })
     */
    upsert<T extends HelpCategoryUpsertArgs>(args: SelectSubset<T, HelpCategoryUpsertArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryCountArgs} args - Arguments to filter HelpCategories to count.
     * @example
     * // Count the number of HelpCategories
     * const count = await prisma.helpCategory.count({
     *   where: {
     *     // ... the filter for the HelpCategories we want to count
     *   }
     * })
    **/
    count<T extends HelpCategoryCountArgs>(
      args?: Subset<T, HelpCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpCategoryAggregateArgs>(args: Subset<T, HelpCategoryAggregateArgs>): Prisma.PrismaPromise<GetHelpCategoryAggregateType<T>>

    /**
     * Group by HelpCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpCategoryGroupByArgs['orderBy'] }
        : { orderBy?: HelpCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpCategory model
   */
  readonly fields: HelpCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    articles<T extends HelpCategory$articlesArgs<ExtArgs> = {}>(args?: Subset<T, HelpCategory$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpCategory model
   */ 
  interface HelpCategoryFieldRefs {
    readonly id: FieldRef<"HelpCategory", 'String'>
    readonly name: FieldRef<"HelpCategory", 'String'>
    readonly description: FieldRef<"HelpCategory", 'String'>
    readonly order: FieldRef<"HelpCategory", 'Int'>
    readonly createdAt: FieldRef<"HelpCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"HelpCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelpCategory findUnique
   */
  export type HelpCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory findUniqueOrThrow
   */
  export type HelpCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory findFirst
   */
  export type HelpCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCategories.
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCategories.
     */
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * HelpCategory findFirstOrThrow
   */
  export type HelpCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCategories.
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCategories.
     */
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * HelpCategory findMany
   */
  export type HelpCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategories to fetch.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpCategories.
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * HelpCategory create
   */
  export type HelpCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpCategory.
     */
    data: XOR<HelpCategoryCreateInput, HelpCategoryUncheckedCreateInput>
  }

  /**
   * HelpCategory createMany
   */
  export type HelpCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpCategories.
     */
    data: HelpCategoryCreateManyInput | HelpCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelpCategory update
   */
  export type HelpCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpCategory.
     */
    data: XOR<HelpCategoryUpdateInput, HelpCategoryUncheckedUpdateInput>
    /**
     * Choose, which HelpCategory to update.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory updateMany
   */
  export type HelpCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpCategories.
     */
    data: XOR<HelpCategoryUpdateManyMutationInput, HelpCategoryUncheckedUpdateManyInput>
    /**
     * Filter which HelpCategories to update
     */
    where?: HelpCategoryWhereInput
  }

  /**
   * HelpCategory upsert
   */
  export type HelpCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpCategory to update in case it exists.
     */
    where: HelpCategoryWhereUniqueInput
    /**
     * In case the HelpCategory found by the `where` argument doesn't exist, create a new HelpCategory with this data.
     */
    create: XOR<HelpCategoryCreateInput, HelpCategoryUncheckedCreateInput>
    /**
     * In case the HelpCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpCategoryUpdateInput, HelpCategoryUncheckedUpdateInput>
  }

  /**
   * HelpCategory delete
   */
  export type HelpCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter which HelpCategory to delete.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory deleteMany
   */
  export type HelpCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCategories to delete
     */
    where?: HelpCategoryWhereInput
  }

  /**
   * HelpCategory.articles
   */
  export type HelpCategory$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    where?: HelpArticleWhereInput
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    cursor?: HelpArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpCategory without action
   */
  export type HelpCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
  }


  /**
   * Model HelpArticle
   */

  export type AggregateHelpArticle = {
    _count: HelpArticleCountAggregateOutputType | null
    _avg: HelpArticleAvgAggregateOutputType | null
    _sum: HelpArticleSumAggregateOutputType | null
    _min: HelpArticleMinAggregateOutputType | null
    _max: HelpArticleMaxAggregateOutputType | null
  }

  export type HelpArticleAvgAggregateOutputType = {
    views: number | null
  }

  export type HelpArticleSumAggregateOutputType = {
    views: number | null
  }

  export type HelpArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    visibility: $Enums.HelpArticleVisibility | null
    isPublished: boolean | null
    authorId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    visibility: $Enums.HelpArticleVisibility | null
    isPublished: boolean | null
    authorId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpArticleCountAggregateOutputType = {
    id: number
    title: number
    content: number
    categoryId: number
    visibility: number
    isPublished: number
    authorId: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpArticleAvgAggregateInputType = {
    views?: true
  }

  export type HelpArticleSumAggregateInputType = {
    views?: true
  }

  export type HelpArticleMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    visibility?: true
    isPublished?: true
    authorId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpArticleMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    visibility?: true
    isPublished?: true
    authorId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpArticleCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    visibility?: true
    isPublished?: true
    authorId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpArticle to aggregate.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpArticles
    **/
    _count?: true | HelpArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpArticleMaxAggregateInputType
  }

  export type GetHelpArticleAggregateType<T extends HelpArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpArticle[P]>
      : GetScalarType<T[P], AggregateHelpArticle[P]>
  }




  export type HelpArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpArticleWhereInput
    orderBy?: HelpArticleOrderByWithAggregationInput | HelpArticleOrderByWithAggregationInput[]
    by: HelpArticleScalarFieldEnum[] | HelpArticleScalarFieldEnum
    having?: HelpArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpArticleCountAggregateInputType | true
    _avg?: HelpArticleAvgAggregateInputType
    _sum?: HelpArticleSumAggregateInputType
    _min?: HelpArticleMinAggregateInputType
    _max?: HelpArticleMaxAggregateInputType
  }

  export type HelpArticleGroupByOutputType = {
    id: string
    title: string
    content: string
    categoryId: string
    visibility: $Enums.HelpArticleVisibility
    isPublished: boolean
    authorId: string
    views: number
    createdAt: Date
    updatedAt: Date
    _count: HelpArticleCountAggregateOutputType | null
    _avg: HelpArticleAvgAggregateOutputType | null
    _sum: HelpArticleSumAggregateOutputType | null
    _min: HelpArticleMinAggregateOutputType | null
    _max: HelpArticleMaxAggregateOutputType | null
  }

  type GetHelpArticleGroupByPayload<T extends HelpArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpArticleGroupByOutputType[P]>
            : GetScalarType<T[P], HelpArticleGroupByOutputType[P]>
        }
      >
    >


  export type HelpArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    visibility?: boolean
    isPublished?: boolean
    authorId?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | HelpCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpArticle"]>


  export type HelpArticleSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    visibility?: boolean
    isPublished?: boolean
    authorId?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HelpArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | HelpCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HelpArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpArticle"
    objects: {
      category: Prisma.$HelpCategoryPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      categoryId: string
      visibility: $Enums.HelpArticleVisibility
      isPublished: boolean
      authorId: string
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["helpArticle"]>
    composites: {}
  }

  type HelpArticleGetPayload<S extends boolean | null | undefined | HelpArticleDefaultArgs> = $Result.GetResult<Prisma.$HelpArticlePayload, S>

  type HelpArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpArticleCountAggregateInputType | true
    }

  export interface HelpArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpArticle'], meta: { name: 'HelpArticle' } }
    /**
     * Find zero or one HelpArticle that matches the filter.
     * @param {HelpArticleFindUniqueArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpArticleFindUniqueArgs>(args: SelectSubset<T, HelpArticleFindUniqueArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpArticleFindUniqueOrThrowArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleFindFirstArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpArticleFindFirstArgs>(args?: SelectSubset<T, HelpArticleFindFirstArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleFindFirstOrThrowArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpArticles
     * const helpArticles = await prisma.helpArticle.findMany()
     * 
     * // Get first 10 HelpArticles
     * const helpArticles = await prisma.helpArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpArticleWithIdOnly = await prisma.helpArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpArticleFindManyArgs>(args?: SelectSubset<T, HelpArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpArticle.
     * @param {HelpArticleCreateArgs} args - Arguments to create a HelpArticle.
     * @example
     * // Create one HelpArticle
     * const HelpArticle = await prisma.helpArticle.create({
     *   data: {
     *     // ... data to create a HelpArticle
     *   }
     * })
     * 
     */
    create<T extends HelpArticleCreateArgs>(args: SelectSubset<T, HelpArticleCreateArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpArticles.
     * @param {HelpArticleCreateManyArgs} args - Arguments to create many HelpArticles.
     * @example
     * // Create many HelpArticles
     * const helpArticle = await prisma.helpArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpArticleCreateManyArgs>(args?: SelectSubset<T, HelpArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HelpArticle.
     * @param {HelpArticleDeleteArgs} args - Arguments to delete one HelpArticle.
     * @example
     * // Delete one HelpArticle
     * const HelpArticle = await prisma.helpArticle.delete({
     *   where: {
     *     // ... filter to delete one HelpArticle
     *   }
     * })
     * 
     */
    delete<T extends HelpArticleDeleteArgs>(args: SelectSubset<T, HelpArticleDeleteArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpArticle.
     * @param {HelpArticleUpdateArgs} args - Arguments to update one HelpArticle.
     * @example
     * // Update one HelpArticle
     * const helpArticle = await prisma.helpArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpArticleUpdateArgs>(args: SelectSubset<T, HelpArticleUpdateArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpArticles.
     * @param {HelpArticleDeleteManyArgs} args - Arguments to filter HelpArticles to delete.
     * @example
     * // Delete a few HelpArticles
     * const { count } = await prisma.helpArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpArticleDeleteManyArgs>(args?: SelectSubset<T, HelpArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpArticles
     * const helpArticle = await prisma.helpArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpArticleUpdateManyArgs>(args: SelectSubset<T, HelpArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpArticle.
     * @param {HelpArticleUpsertArgs} args - Arguments to update or create a HelpArticle.
     * @example
     * // Update or create a HelpArticle
     * const helpArticle = await prisma.helpArticle.upsert({
     *   create: {
     *     // ... data to create a HelpArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpArticle we want to update
     *   }
     * })
     */
    upsert<T extends HelpArticleUpsertArgs>(args: SelectSubset<T, HelpArticleUpsertArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleCountArgs} args - Arguments to filter HelpArticles to count.
     * @example
     * // Count the number of HelpArticles
     * const count = await prisma.helpArticle.count({
     *   where: {
     *     // ... the filter for the HelpArticles we want to count
     *   }
     * })
    **/
    count<T extends HelpArticleCountArgs>(
      args?: Subset<T, HelpArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpArticleAggregateArgs>(args: Subset<T, HelpArticleAggregateArgs>): Prisma.PrismaPromise<GetHelpArticleAggregateType<T>>

    /**
     * Group by HelpArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpArticleGroupByArgs['orderBy'] }
        : { orderBy?: HelpArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpArticle model
   */
  readonly fields: HelpArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends HelpCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelpCategoryDefaultArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpArticle model
   */ 
  interface HelpArticleFieldRefs {
    readonly id: FieldRef<"HelpArticle", 'String'>
    readonly title: FieldRef<"HelpArticle", 'String'>
    readonly content: FieldRef<"HelpArticle", 'String'>
    readonly categoryId: FieldRef<"HelpArticle", 'String'>
    readonly visibility: FieldRef<"HelpArticle", 'HelpArticleVisibility'>
    readonly isPublished: FieldRef<"HelpArticle", 'Boolean'>
    readonly authorId: FieldRef<"HelpArticle", 'String'>
    readonly views: FieldRef<"HelpArticle", 'Int'>
    readonly createdAt: FieldRef<"HelpArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"HelpArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelpArticle findUnique
   */
  export type HelpArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle findUniqueOrThrow
   */
  export type HelpArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle findFirst
   */
  export type HelpArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpArticles.
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpArticles.
     */
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpArticle findFirstOrThrow
   */
  export type HelpArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpArticles.
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpArticles.
     */
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpArticle findMany
   */
  export type HelpArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticles to fetch.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpArticles.
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpArticle create
   */
  export type HelpArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpArticle.
     */
    data: XOR<HelpArticleCreateInput, HelpArticleUncheckedCreateInput>
  }

  /**
   * HelpArticle createMany
   */
  export type HelpArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpArticles.
     */
    data: HelpArticleCreateManyInput | HelpArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelpArticle update
   */
  export type HelpArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpArticle.
     */
    data: XOR<HelpArticleUpdateInput, HelpArticleUncheckedUpdateInput>
    /**
     * Choose, which HelpArticle to update.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle updateMany
   */
  export type HelpArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpArticles.
     */
    data: XOR<HelpArticleUpdateManyMutationInput, HelpArticleUncheckedUpdateManyInput>
    /**
     * Filter which HelpArticles to update
     */
    where?: HelpArticleWhereInput
  }

  /**
   * HelpArticle upsert
   */
  export type HelpArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpArticle to update in case it exists.
     */
    where: HelpArticleWhereUniqueInput
    /**
     * In case the HelpArticle found by the `where` argument doesn't exist, create a new HelpArticle with this data.
     */
    create: XOR<HelpArticleCreateInput, HelpArticleUncheckedCreateInput>
    /**
     * In case the HelpArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpArticleUpdateInput, HelpArticleUncheckedUpdateInput>
  }

  /**
   * HelpArticle delete
   */
  export type HelpArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter which HelpArticle to delete.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle deleteMany
   */
  export type HelpArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpArticles to delete
     */
    where?: HelpArticleWhereInput
  }

  /**
   * HelpArticle without action
   */
  export type HelpArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsAvgAggregateOutputType = {
    smtpPort: number | null
  }

  export type SystemSettingsSumAggregateOutputType = {
    smtpPort: number | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    universityName: string | null
    universityNameTh: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    backgroundColor: string | null
    studentIdFormat: string | null
    defaultLanguage: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    smtpSecure: boolean | null
    smtpFromEmail: string | null
    smtpFromName: string | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    universityName: string | null
    universityNameTh: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    backgroundColor: string | null
    studentIdFormat: string | null
    defaultLanguage: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    smtpSecure: boolean | null
    smtpFromEmail: string | null
    smtpFromName: string | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    universityName: number
    universityNameTh: number
    logoUrl: number
    primaryColor: number
    secondaryColor: number
    backgroundColor: number
    studentIdFormat: number
    defaultLanguage: number
    smtpHost: number
    smtpPort: number
    smtpUser: number
    smtpPassword: number
    smtpSecure: number
    smtpFromEmail: number
    smtpFromName: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsAvgAggregateInputType = {
    smtpPort?: true
  }

  export type SystemSettingsSumAggregateInputType = {
    smtpPort?: true
  }

  export type SystemSettingsMinAggregateInputType = {
    id?: true
    universityName?: true
    universityNameTh?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    backgroundColor?: true
    studentIdFormat?: true
    defaultLanguage?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    smtpSecure?: true
    smtpFromEmail?: true
    smtpFromName?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    universityName?: true
    universityNameTh?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    backgroundColor?: true
    studentIdFormat?: true
    defaultLanguage?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    smtpSecure?: true
    smtpFromEmail?: true
    smtpFromName?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    universityName?: true
    universityNameTh?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    backgroundColor?: true
    studentIdFormat?: true
    defaultLanguage?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    smtpSecure?: true
    smtpFromEmail?: true
    smtpFromName?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _avg?: SystemSettingsAvgAggregateInputType
    _sum?: SystemSettingsSumAggregateInputType
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    universityName: string
    universityNameTh: string
    logoUrl: string | null
    primaryColor: string
    secondaryColor: string
    backgroundColor: string
    studentIdFormat: string
    defaultLanguage: string
    smtpHost: string | null
    smtpPort: number
    smtpUser: string | null
    smtpPassword: string | null
    smtpSecure: boolean
    smtpFromEmail: string
    smtpFromName: string
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    universityName?: boolean
    universityNameTh?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    backgroundColor?: boolean
    studentIdFormat?: boolean
    defaultLanguage?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpSecure?: boolean
    smtpFromEmail?: boolean
    smtpFromName?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>


  export type SystemSettingsSelectScalar = {
    id?: boolean
    universityName?: boolean
    universityNameTh?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    backgroundColor?: boolean
    studentIdFormat?: boolean
    defaultLanguage?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpSecure?: boolean
    smtpFromEmail?: boolean
    smtpFromName?: boolean
    updatedAt?: boolean
  }


  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      universityName: string
      universityNameTh: string
      logoUrl: string | null
      primaryColor: string
      secondaryColor: string
      backgroundColor: string
      studentIdFormat: string
      defaultLanguage: string
      smtpHost: string | null
      smtpPort: number
      smtpUser: string | null
      smtpPassword: string | null
      smtpSecure: boolean
      smtpFromEmail: string
      smtpFromName: string
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */ 
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly universityName: FieldRef<"SystemSettings", 'String'>
    readonly universityNameTh: FieldRef<"SystemSettings", 'String'>
    readonly logoUrl: FieldRef<"SystemSettings", 'String'>
    readonly primaryColor: FieldRef<"SystemSettings", 'String'>
    readonly secondaryColor: FieldRef<"SystemSettings", 'String'>
    readonly backgroundColor: FieldRef<"SystemSettings", 'String'>
    readonly studentIdFormat: FieldRef<"SystemSettings", 'String'>
    readonly defaultLanguage: FieldRef<"SystemSettings", 'String'>
    readonly smtpHost: FieldRef<"SystemSettings", 'String'>
    readonly smtpPort: FieldRef<"SystemSettings", 'Int'>
    readonly smtpUser: FieldRef<"SystemSettings", 'String'>
    readonly smtpPassword: FieldRef<"SystemSettings", 'String'>
    readonly smtpSecure: FieldRef<"SystemSettings", 'Boolean'>
    readonly smtpFromEmail: FieldRef<"SystemSettings", 'String'>
    readonly smtpFromName: FieldRef<"SystemSettings", 'String'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
  }


  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    details: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    details: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    details: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type SystemLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    details: string | null
    ipAddress: string | null
    createdAt: Date
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | SystemLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["systemLog"]>


  export type SystemLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type SystemLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SystemLog$userArgs<ExtArgs>
  }

  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      details: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }

  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLogFindUniqueArgs>(args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLogFindFirstArgs>(args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLogFindManyArgs>(args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
     */
    create<T extends SystemLogCreateArgs>(args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemLogs.
     * @param {SystemLogCreateManyArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLogCreateManyArgs>(args?: SelectSubset<T, SystemLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
     */
    delete<T extends SystemLogDeleteArgs>(args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLogUpdateArgs>(args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLogDeleteManyArgs>(args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLogUpdateManyArgs>(args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemLogUpsertArgs>(args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SystemLog$userArgs<ExtArgs> = {}>(args?: Subset<T, SystemLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLog model
   */ 
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'String'>
    readonly userId: FieldRef<"SystemLog", 'String'>
    readonly action: FieldRef<"SystemLog", 'String'>
    readonly details: FieldRef<"SystemLog", 'String'>
    readonly ipAddress: FieldRef<"SystemLog", 'String'>
    readonly createdAt: FieldRef<"SystemLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }

  /**
   * SystemLog createMany
   */
  export type SystemLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }

  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog.user
   */
  export type SystemLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
  }


  /**
   * Model Translation
   */

  export type AggregateTranslation = {
    _count: TranslationCountAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  export type TranslationMinAggregateOutputType = {
    id: string | null
    key: string | null
    th: string | null
    en: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranslationMaxAggregateOutputType = {
    id: string | null
    key: string | null
    th: string | null
    en: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranslationCountAggregateOutputType = {
    id: number
    key: number
    th: number
    en: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TranslationMinAggregateInputType = {
    id?: true
    key?: true
    th?: true
    en?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranslationMaxAggregateInputType = {
    id?: true
    key?: true
    th?: true
    en?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranslationCountAggregateInputType = {
    id?: true
    key?: true
    th?: true
    en?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translation to aggregate.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Translations
    **/
    _count?: true | TranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationMaxAggregateInputType
  }

  export type GetTranslationAggregateType<T extends TranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslation[P]>
      : GetScalarType<T[P], AggregateTranslation[P]>
  }




  export type TranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithAggregationInput | TranslationOrderByWithAggregationInput[]
    by: TranslationScalarFieldEnum[] | TranslationScalarFieldEnum
    having?: TranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationCountAggregateInputType | true
    _min?: TranslationMinAggregateInputType
    _max?: TranslationMaxAggregateInputType
  }

  export type TranslationGroupByOutputType = {
    id: string
    key: string
    th: string
    en: string
    createdAt: Date
    updatedAt: Date
    _count: TranslationCountAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  type GetTranslationGroupByPayload<T extends TranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationGroupByOutputType[P]>
        }
      >
    >


  export type TranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    th?: boolean
    en?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["translation"]>


  export type TranslationSelectScalar = {
    id?: boolean
    key?: boolean
    th?: boolean
    en?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Translation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      th: string
      en: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["translation"]>
    composites: {}
  }

  type TranslationGetPayload<S extends boolean | null | undefined | TranslationDefaultArgs> = $Result.GetResult<Prisma.$TranslationPayload, S>

  type TranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranslationCountAggregateInputType | true
    }

  export interface TranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Translation'], meta: { name: 'Translation' } }
    /**
     * Find zero or one Translation that matches the filter.
     * @param {TranslationFindUniqueArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationFindUniqueArgs>(args: SelectSubset<T, TranslationFindUniqueArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Translation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranslationFindUniqueOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationFindFirstArgs>(args?: SelectSubset<T, TranslationFindFirstArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Translation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Translations
     * const translations = await prisma.translation.findMany()
     * 
     * // Get first 10 Translations
     * const translations = await prisma.translation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationWithIdOnly = await prisma.translation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationFindManyArgs>(args?: SelectSubset<T, TranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Translation.
     * @param {TranslationCreateArgs} args - Arguments to create a Translation.
     * @example
     * // Create one Translation
     * const Translation = await prisma.translation.create({
     *   data: {
     *     // ... data to create a Translation
     *   }
     * })
     * 
     */
    create<T extends TranslationCreateArgs>(args: SelectSubset<T, TranslationCreateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Translations.
     * @param {TranslationCreateManyArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationCreateManyArgs>(args?: SelectSubset<T, TranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Translation.
     * @param {TranslationDeleteArgs} args - Arguments to delete one Translation.
     * @example
     * // Delete one Translation
     * const Translation = await prisma.translation.delete({
     *   where: {
     *     // ... filter to delete one Translation
     *   }
     * })
     * 
     */
    delete<T extends TranslationDeleteArgs>(args: SelectSubset<T, TranslationDeleteArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Translation.
     * @param {TranslationUpdateArgs} args - Arguments to update one Translation.
     * @example
     * // Update one Translation
     * const translation = await prisma.translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationUpdateArgs>(args: SelectSubset<T, TranslationUpdateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Translations.
     * @param {TranslationDeleteManyArgs} args - Arguments to filter Translations to delete.
     * @example
     * // Delete a few Translations
     * const { count } = await prisma.translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationDeleteManyArgs>(args?: SelectSubset<T, TranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Translations
     * const translation = await prisma.translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationUpdateManyArgs>(args: SelectSubset<T, TranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Translation.
     * @param {TranslationUpsertArgs} args - Arguments to update or create a Translation.
     * @example
     * // Update or create a Translation
     * const translation = await prisma.translation.upsert({
     *   create: {
     *     // ... data to create a Translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Translation we want to update
     *   }
     * })
     */
    upsert<T extends TranslationUpsertArgs>(args: SelectSubset<T, TranslationUpsertArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationCountArgs} args - Arguments to filter Translations to count.
     * @example
     * // Count the number of Translations
     * const count = await prisma.translation.count({
     *   where: {
     *     // ... the filter for the Translations we want to count
     *   }
     * })
    **/
    count<T extends TranslationCountArgs>(
      args?: Subset<T, TranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationAggregateArgs>(args: Subset<T, TranslationAggregateArgs>): Prisma.PrismaPromise<GetTranslationAggregateType<T>>

    /**
     * Group by Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationGroupByArgs['orderBy'] }
        : { orderBy?: TranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Translation model
   */
  readonly fields: TranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Translation model
   */ 
  interface TranslationFieldRefs {
    readonly id: FieldRef<"Translation", 'String'>
    readonly key: FieldRef<"Translation", 'String'>
    readonly th: FieldRef<"Translation", 'String'>
    readonly en: FieldRef<"Translation", 'String'>
    readonly createdAt: FieldRef<"Translation", 'DateTime'>
    readonly updatedAt: FieldRef<"Translation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Translation findUnique
   */
  export type TranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findUniqueOrThrow
   */
  export type TranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findFirst
   */
  export type TranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findFirstOrThrow
   */
  export type TranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findMany
   */
  export type TranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translations to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation create
   */
  export type TranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * The data needed to create a Translation.
     */
    data: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
  }

  /**
   * Translation createMany
   */
  export type TranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Translation update
   */
  export type TranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * The data needed to update a Translation.
     */
    data: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
    /**
     * Choose, which Translation to update.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation updateMany
   */
  export type TranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Translations.
     */
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyInput>
    /**
     * Filter which Translations to update
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation upsert
   */
  export type TranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * The filter to search for the Translation to update in case it exists.
     */
    where: TranslationWhereUniqueInput
    /**
     * In case the Translation found by the `where` argument doesn't exist, create a new Translation with this data.
     */
    create: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
    /**
     * In case the Translation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
  }

  /**
   * Translation delete
   */
  export type TranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter which Translation to delete.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation deleteMany
   */
  export type TranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translations to delete
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation without action
   */
  export type TranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    floor: number | null
    capacity: number | null
  }

  export type RoomSumAggregateOutputType = {
    floor: number | null
    capacity: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    building: string | null
    floor: number | null
    capacity: number | null
    roomType: $Enums.RoomType | null
    facilities: string | null
    isActive: boolean | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    building: string | null
    floor: number | null
    capacity: number | null
    roomType: $Enums.RoomType | null
    facilities: string | null
    isActive: boolean | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    code: number
    name: number
    building: number
    floor: number
    capacity: number
    roomType: number
    facilities: number
    isActive: number
    isAvailable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    floor?: true
    capacity?: true
  }

  export type RoomSumAggregateInputType = {
    floor?: true
    capacity?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    building?: true
    floor?: true
    capacity?: true
    roomType?: true
    facilities?: true
    isActive?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    building?: true
    floor?: true
    capacity?: true
    roomType?: true
    facilities?: true
    isActive?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    building?: true
    floor?: true
    capacity?: true
    roomType?: true
    facilities?: true
    isActive?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities: string | null
    isActive: boolean
    isAvailable: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    building?: boolean
    floor?: boolean
    capacity?: boolean
    roomType?: boolean
    facilities?: boolean
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedules?: boolean | Room$schedulesArgs<ExtArgs>
    examSlots?: boolean | Room$examSlotsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>


  export type RoomSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    building?: boolean
    floor?: boolean
    capacity?: boolean
    roomType?: boolean
    facilities?: boolean
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | Room$schedulesArgs<ExtArgs>
    examSlots?: boolean | Room$examSlotsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      schedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
      examSlots: Prisma.$ExamSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      building: string
      floor: number
      capacity: number
      roomType: $Enums.RoomType
      facilities: string | null
      isActive: boolean
      isAvailable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedules<T extends Room$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Room$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    examSlots<T extends Room$examSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Room$examSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly code: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly building: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'Int'>
    readonly capacity: FieldRef<"Room", 'Int'>
    readonly roomType: FieldRef<"Room", 'RoomType'>
    readonly facilities: FieldRef<"Room", 'String'>
    readonly isActive: FieldRef<"Room", 'Boolean'>
    readonly isAvailable: FieldRef<"Room", 'Boolean'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.schedules
   */
  export type Room$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * Room.examSlots
   */
  export type Room$examSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    where?: ExamSlotWhereInput
    orderBy?: ExamSlotOrderByWithRelationInput | ExamSlotOrderByWithRelationInput[]
    cursor?: ExamSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamSlotScalarFieldEnum | ExamSlotScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model ExamSchedule
   */

  export type AggregateExamSchedule = {
    _count: ExamScheduleCountAggregateOutputType | null
    _avg: ExamScheduleAvgAggregateOutputType | null
    _sum: ExamScheduleSumAggregateOutputType | null
    _min: ExamScheduleMinAggregateOutputType | null
    _max: ExamScheduleMaxAggregateOutputType | null
  }

  export type ExamScheduleAvgAggregateOutputType = {
    duration: number | null
  }

  export type ExamScheduleSumAggregateOutputType = {
    duration: number | null
  }

  export type ExamScheduleMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    section: string | null
    termId: string | null
    examType: $Enums.ExamType | null
    examDate: Date | null
    startTime: string | null
    endTime: string | null
    duration: number | null
    examFormat: $Enums.ExamFormat | null
    instructions: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamScheduleMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    section: string | null
    termId: string | null
    examType: $Enums.ExamType | null
    examDate: Date | null
    startTime: string | null
    endTime: string | null
    duration: number | null
    examFormat: $Enums.ExamFormat | null
    instructions: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamScheduleCountAggregateOutputType = {
    id: number
    courseId: number
    section: number
    termId: number
    examType: number
    examDate: number
    startTime: number
    endTime: number
    duration: number
    examFormat: number
    instructions: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamScheduleAvgAggregateInputType = {
    duration?: true
  }

  export type ExamScheduleSumAggregateInputType = {
    duration?: true
  }

  export type ExamScheduleMinAggregateInputType = {
    id?: true
    courseId?: true
    section?: true
    termId?: true
    examType?: true
    examDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    examFormat?: true
    instructions?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamScheduleMaxAggregateInputType = {
    id?: true
    courseId?: true
    section?: true
    termId?: true
    examType?: true
    examDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    examFormat?: true
    instructions?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamScheduleCountAggregateInputType = {
    id?: true
    courseId?: true
    section?: true
    termId?: true
    examType?: true
    examDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    examFormat?: true
    instructions?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSchedule to aggregate.
     */
    where?: ExamScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSchedules to fetch.
     */
    orderBy?: ExamScheduleOrderByWithRelationInput | ExamScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamSchedules
    **/
    _count?: true | ExamScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamScheduleMaxAggregateInputType
  }

  export type GetExamScheduleAggregateType<T extends ExamScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateExamSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamSchedule[P]>
      : GetScalarType<T[P], AggregateExamSchedule[P]>
  }




  export type ExamScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamScheduleWhereInput
    orderBy?: ExamScheduleOrderByWithAggregationInput | ExamScheduleOrderByWithAggregationInput[]
    by: ExamScheduleScalarFieldEnum[] | ExamScheduleScalarFieldEnum
    having?: ExamScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamScheduleCountAggregateInputType | true
    _avg?: ExamScheduleAvgAggregateInputType
    _sum?: ExamScheduleSumAggregateInputType
    _min?: ExamScheduleMinAggregateInputType
    _max?: ExamScheduleMaxAggregateInputType
  }

  export type ExamScheduleGroupByOutputType = {
    id: string
    courseId: string
    section: string
    termId: string
    examType: $Enums.ExamType
    examDate: Date
    startTime: string
    endTime: string
    duration: number
    examFormat: $Enums.ExamFormat
    instructions: string | null
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExamScheduleCountAggregateOutputType | null
    _avg: ExamScheduleAvgAggregateOutputType | null
    _sum: ExamScheduleSumAggregateOutputType | null
    _min: ExamScheduleMinAggregateOutputType | null
    _max: ExamScheduleMaxAggregateOutputType | null
  }

  type GetExamScheduleGroupByPayload<T extends ExamScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ExamScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ExamScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    section?: boolean
    termId?: boolean
    examType?: boolean
    examDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    examFormat?: boolean
    instructions?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
    examSlots?: boolean | ExamSchedule$examSlotsArgs<ExtArgs>
    _count?: boolean | ExamScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examSchedule"]>


  export type ExamScheduleSelectScalar = {
    id?: boolean
    courseId?: boolean
    section?: boolean
    termId?: boolean
    examType?: boolean
    examDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    examFormat?: boolean
    instructions?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
    examSlots?: boolean | ExamSchedule$examSlotsArgs<ExtArgs>
    _count?: boolean | ExamScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamSchedule"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      term: Prisma.$AcademicTermPayload<ExtArgs>
      examSlots: Prisma.$ExamSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      section: string
      termId: string
      examType: $Enums.ExamType
      examDate: Date
      startTime: string
      endTime: string
      duration: number
      examFormat: $Enums.ExamFormat
      instructions: string | null
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examSchedule"]>
    composites: {}
  }

  type ExamScheduleGetPayload<S extends boolean | null | undefined | ExamScheduleDefaultArgs> = $Result.GetResult<Prisma.$ExamSchedulePayload, S>

  type ExamScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamScheduleCountAggregateInputType | true
    }

  export interface ExamScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamSchedule'], meta: { name: 'ExamSchedule' } }
    /**
     * Find zero or one ExamSchedule that matches the filter.
     * @param {ExamScheduleFindUniqueArgs} args - Arguments to find a ExamSchedule
     * @example
     * // Get one ExamSchedule
     * const examSchedule = await prisma.examSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamScheduleFindUniqueArgs>(args: SelectSubset<T, ExamScheduleFindUniqueArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamScheduleFindUniqueOrThrowArgs} args - Arguments to find a ExamSchedule
     * @example
     * // Get one ExamSchedule
     * const examSchedule = await prisma.examSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScheduleFindFirstArgs} args - Arguments to find a ExamSchedule
     * @example
     * // Get one ExamSchedule
     * const examSchedule = await prisma.examSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamScheduleFindFirstArgs>(args?: SelectSubset<T, ExamScheduleFindFirstArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScheduleFindFirstOrThrowArgs} args - Arguments to find a ExamSchedule
     * @example
     * // Get one ExamSchedule
     * const examSchedule = await prisma.examSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamSchedules
     * const examSchedules = await prisma.examSchedule.findMany()
     * 
     * // Get first 10 ExamSchedules
     * const examSchedules = await prisma.examSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examScheduleWithIdOnly = await prisma.examSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamScheduleFindManyArgs>(args?: SelectSubset<T, ExamScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamSchedule.
     * @param {ExamScheduleCreateArgs} args - Arguments to create a ExamSchedule.
     * @example
     * // Create one ExamSchedule
     * const ExamSchedule = await prisma.examSchedule.create({
     *   data: {
     *     // ... data to create a ExamSchedule
     *   }
     * })
     * 
     */
    create<T extends ExamScheduleCreateArgs>(args: SelectSubset<T, ExamScheduleCreateArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamSchedules.
     * @param {ExamScheduleCreateManyArgs} args - Arguments to create many ExamSchedules.
     * @example
     * // Create many ExamSchedules
     * const examSchedule = await prisma.examSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamScheduleCreateManyArgs>(args?: SelectSubset<T, ExamScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamSchedule.
     * @param {ExamScheduleDeleteArgs} args - Arguments to delete one ExamSchedule.
     * @example
     * // Delete one ExamSchedule
     * const ExamSchedule = await prisma.examSchedule.delete({
     *   where: {
     *     // ... filter to delete one ExamSchedule
     *   }
     * })
     * 
     */
    delete<T extends ExamScheduleDeleteArgs>(args: SelectSubset<T, ExamScheduleDeleteArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamSchedule.
     * @param {ExamScheduleUpdateArgs} args - Arguments to update one ExamSchedule.
     * @example
     * // Update one ExamSchedule
     * const examSchedule = await prisma.examSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamScheduleUpdateArgs>(args: SelectSubset<T, ExamScheduleUpdateArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamSchedules.
     * @param {ExamScheduleDeleteManyArgs} args - Arguments to filter ExamSchedules to delete.
     * @example
     * // Delete a few ExamSchedules
     * const { count } = await prisma.examSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamScheduleDeleteManyArgs>(args?: SelectSubset<T, ExamScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamSchedules
     * const examSchedule = await prisma.examSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamScheduleUpdateManyArgs>(args: SelectSubset<T, ExamScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamSchedule.
     * @param {ExamScheduleUpsertArgs} args - Arguments to update or create a ExamSchedule.
     * @example
     * // Update or create a ExamSchedule
     * const examSchedule = await prisma.examSchedule.upsert({
     *   create: {
     *     // ... data to create a ExamSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ExamScheduleUpsertArgs>(args: SelectSubset<T, ExamScheduleUpsertArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScheduleCountArgs} args - Arguments to filter ExamSchedules to count.
     * @example
     * // Count the number of ExamSchedules
     * const count = await prisma.examSchedule.count({
     *   where: {
     *     // ... the filter for the ExamSchedules we want to count
     *   }
     * })
    **/
    count<T extends ExamScheduleCountArgs>(
      args?: Subset<T, ExamScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamScheduleAggregateArgs>(args: Subset<T, ExamScheduleAggregateArgs>): Prisma.PrismaPromise<GetExamScheduleAggregateType<T>>

    /**
     * Group by ExamSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ExamScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamSchedule model
   */
  readonly fields: ExamScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    term<T extends AcademicTermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTermDefaultArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    examSlots<T extends ExamSchedule$examSlotsArgs<ExtArgs> = {}>(args?: Subset<T, ExamSchedule$examSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamSchedule model
   */ 
  interface ExamScheduleFieldRefs {
    readonly id: FieldRef<"ExamSchedule", 'String'>
    readonly courseId: FieldRef<"ExamSchedule", 'String'>
    readonly section: FieldRef<"ExamSchedule", 'String'>
    readonly termId: FieldRef<"ExamSchedule", 'String'>
    readonly examType: FieldRef<"ExamSchedule", 'ExamType'>
    readonly examDate: FieldRef<"ExamSchedule", 'DateTime'>
    readonly startTime: FieldRef<"ExamSchedule", 'String'>
    readonly endTime: FieldRef<"ExamSchedule", 'String'>
    readonly duration: FieldRef<"ExamSchedule", 'Int'>
    readonly examFormat: FieldRef<"ExamSchedule", 'ExamFormat'>
    readonly instructions: FieldRef<"ExamSchedule", 'String'>
    readonly isPublished: FieldRef<"ExamSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"ExamSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamSchedule findUnique
   */
  export type ExamScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ExamSchedule to fetch.
     */
    where: ExamScheduleWhereUniqueInput
  }

  /**
   * ExamSchedule findUniqueOrThrow
   */
  export type ExamScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ExamSchedule to fetch.
     */
    where: ExamScheduleWhereUniqueInput
  }

  /**
   * ExamSchedule findFirst
   */
  export type ExamScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ExamSchedule to fetch.
     */
    where?: ExamScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSchedules to fetch.
     */
    orderBy?: ExamScheduleOrderByWithRelationInput | ExamScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSchedules.
     */
    cursor?: ExamScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSchedules.
     */
    distinct?: ExamScheduleScalarFieldEnum | ExamScheduleScalarFieldEnum[]
  }

  /**
   * ExamSchedule findFirstOrThrow
   */
  export type ExamScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ExamSchedule to fetch.
     */
    where?: ExamScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSchedules to fetch.
     */
    orderBy?: ExamScheduleOrderByWithRelationInput | ExamScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSchedules.
     */
    cursor?: ExamScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSchedules.
     */
    distinct?: ExamScheduleScalarFieldEnum | ExamScheduleScalarFieldEnum[]
  }

  /**
   * ExamSchedule findMany
   */
  export type ExamScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ExamSchedules to fetch.
     */
    where?: ExamScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSchedules to fetch.
     */
    orderBy?: ExamScheduleOrderByWithRelationInput | ExamScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamSchedules.
     */
    cursor?: ExamScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSchedules.
     */
    skip?: number
    distinct?: ExamScheduleScalarFieldEnum | ExamScheduleScalarFieldEnum[]
  }

  /**
   * ExamSchedule create
   */
  export type ExamScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamSchedule.
     */
    data: XOR<ExamScheduleCreateInput, ExamScheduleUncheckedCreateInput>
  }

  /**
   * ExamSchedule createMany
   */
  export type ExamScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamSchedules.
     */
    data: ExamScheduleCreateManyInput | ExamScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamSchedule update
   */
  export type ExamScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamSchedule.
     */
    data: XOR<ExamScheduleUpdateInput, ExamScheduleUncheckedUpdateInput>
    /**
     * Choose, which ExamSchedule to update.
     */
    where: ExamScheduleWhereUniqueInput
  }

  /**
   * ExamSchedule updateMany
   */
  export type ExamScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamSchedules.
     */
    data: XOR<ExamScheduleUpdateManyMutationInput, ExamScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ExamSchedules to update
     */
    where?: ExamScheduleWhereInput
  }

  /**
   * ExamSchedule upsert
   */
  export type ExamScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamSchedule to update in case it exists.
     */
    where: ExamScheduleWhereUniqueInput
    /**
     * In case the ExamSchedule found by the `where` argument doesn't exist, create a new ExamSchedule with this data.
     */
    create: XOR<ExamScheduleCreateInput, ExamScheduleUncheckedCreateInput>
    /**
     * In case the ExamSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamScheduleUpdateInput, ExamScheduleUncheckedUpdateInput>
  }

  /**
   * ExamSchedule delete
   */
  export type ExamScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
    /**
     * Filter which ExamSchedule to delete.
     */
    where: ExamScheduleWhereUniqueInput
  }

  /**
   * ExamSchedule deleteMany
   */
  export type ExamScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSchedules to delete
     */
    where?: ExamScheduleWhereInput
  }

  /**
   * ExamSchedule.examSlots
   */
  export type ExamSchedule$examSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    where?: ExamSlotWhereInput
    orderBy?: ExamSlotOrderByWithRelationInput | ExamSlotOrderByWithRelationInput[]
    cursor?: ExamSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamSlotScalarFieldEnum | ExamSlotScalarFieldEnum[]
  }

  /**
   * ExamSchedule without action
   */
  export type ExamScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSchedule
     */
    select?: ExamScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ExamSlot
   */

  export type AggregateExamSlot = {
    _count: ExamSlotCountAggregateOutputType | null
    _avg: ExamSlotAvgAggregateOutputType | null
    _sum: ExamSlotSumAggregateOutputType | null
    _min: ExamSlotMinAggregateOutputType | null
    _max: ExamSlotMaxAggregateOutputType | null
  }

  export type ExamSlotAvgAggregateOutputType = {
    capacity: number | null
    assignedCount: number | null
  }

  export type ExamSlotSumAggregateOutputType = {
    capacity: number | null
    assignedCount: number | null
  }

  export type ExamSlotMinAggregateOutputType = {
    id: string | null
    examScheduleId: string | null
    roomId: string | null
    capacity: number | null
    assignedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamSlotMaxAggregateOutputType = {
    id: string | null
    examScheduleId: string | null
    roomId: string | null
    capacity: number | null
    assignedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamSlotCountAggregateOutputType = {
    id: number
    examScheduleId: number
    roomId: number
    capacity: number
    assignedCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamSlotAvgAggregateInputType = {
    capacity?: true
    assignedCount?: true
  }

  export type ExamSlotSumAggregateInputType = {
    capacity?: true
    assignedCount?: true
  }

  export type ExamSlotMinAggregateInputType = {
    id?: true
    examScheduleId?: true
    roomId?: true
    capacity?: true
    assignedCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamSlotMaxAggregateInputType = {
    id?: true
    examScheduleId?: true
    roomId?: true
    capacity?: true
    assignedCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamSlotCountAggregateInputType = {
    id?: true
    examScheduleId?: true
    roomId?: true
    capacity?: true
    assignedCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSlot to aggregate.
     */
    where?: ExamSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSlots to fetch.
     */
    orderBy?: ExamSlotOrderByWithRelationInput | ExamSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamSlots
    **/
    _count?: true | ExamSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamSlotMaxAggregateInputType
  }

  export type GetExamSlotAggregateType<T extends ExamSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateExamSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamSlot[P]>
      : GetScalarType<T[P], AggregateExamSlot[P]>
  }




  export type ExamSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSlotWhereInput
    orderBy?: ExamSlotOrderByWithAggregationInput | ExamSlotOrderByWithAggregationInput[]
    by: ExamSlotScalarFieldEnum[] | ExamSlotScalarFieldEnum
    having?: ExamSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamSlotCountAggregateInputType | true
    _avg?: ExamSlotAvgAggregateInputType
    _sum?: ExamSlotSumAggregateInputType
    _min?: ExamSlotMinAggregateInputType
    _max?: ExamSlotMaxAggregateInputType
  }

  export type ExamSlotGroupByOutputType = {
    id: string
    examScheduleId: string
    roomId: string
    capacity: number
    assignedCount: number
    createdAt: Date
    updatedAt: Date
    _count: ExamSlotCountAggregateOutputType | null
    _avg: ExamSlotAvgAggregateOutputType | null
    _sum: ExamSlotSumAggregateOutputType | null
    _min: ExamSlotMinAggregateOutputType | null
    _max: ExamSlotMaxAggregateOutputType | null
  }

  type GetExamSlotGroupByPayload<T extends ExamSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamSlotGroupByOutputType[P]>
            : GetScalarType<T[P], ExamSlotGroupByOutputType[P]>
        }
      >
    >


  export type ExamSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examScheduleId?: boolean
    roomId?: boolean
    capacity?: boolean
    assignedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examSchedule?: boolean | ExamScheduleDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    proctors?: boolean | ExamSlot$proctorsArgs<ExtArgs>
    _count?: boolean | ExamSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examSlot"]>


  export type ExamSlotSelectScalar = {
    id?: boolean
    examScheduleId?: boolean
    roomId?: boolean
    capacity?: boolean
    assignedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examSchedule?: boolean | ExamScheduleDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    proctors?: boolean | ExamSlot$proctorsArgs<ExtArgs>
    _count?: boolean | ExamSlotCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamSlot"
    objects: {
      examSchedule: Prisma.$ExamSchedulePayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      proctors: Prisma.$ExamProctorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examScheduleId: string
      roomId: string
      capacity: number
      assignedCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examSlot"]>
    composites: {}
  }

  type ExamSlotGetPayload<S extends boolean | null | undefined | ExamSlotDefaultArgs> = $Result.GetResult<Prisma.$ExamSlotPayload, S>

  type ExamSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamSlotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamSlotCountAggregateInputType | true
    }

  export interface ExamSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamSlot'], meta: { name: 'ExamSlot' } }
    /**
     * Find zero or one ExamSlot that matches the filter.
     * @param {ExamSlotFindUniqueArgs} args - Arguments to find a ExamSlot
     * @example
     * // Get one ExamSlot
     * const examSlot = await prisma.examSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamSlotFindUniqueArgs>(args: SelectSubset<T, ExamSlotFindUniqueArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamSlot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamSlotFindUniqueOrThrowArgs} args - Arguments to find a ExamSlot
     * @example
     * // Get one ExamSlot
     * const examSlot = await prisma.examSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSlotFindFirstArgs} args - Arguments to find a ExamSlot
     * @example
     * // Get one ExamSlot
     * const examSlot = await prisma.examSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamSlotFindFirstArgs>(args?: SelectSubset<T, ExamSlotFindFirstArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSlotFindFirstOrThrowArgs} args - Arguments to find a ExamSlot
     * @example
     * // Get one ExamSlot
     * const examSlot = await prisma.examSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamSlots
     * const examSlots = await prisma.examSlot.findMany()
     * 
     * // Get first 10 ExamSlots
     * const examSlots = await prisma.examSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examSlotWithIdOnly = await prisma.examSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamSlotFindManyArgs>(args?: SelectSubset<T, ExamSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamSlot.
     * @param {ExamSlotCreateArgs} args - Arguments to create a ExamSlot.
     * @example
     * // Create one ExamSlot
     * const ExamSlot = await prisma.examSlot.create({
     *   data: {
     *     // ... data to create a ExamSlot
     *   }
     * })
     * 
     */
    create<T extends ExamSlotCreateArgs>(args: SelectSubset<T, ExamSlotCreateArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamSlots.
     * @param {ExamSlotCreateManyArgs} args - Arguments to create many ExamSlots.
     * @example
     * // Create many ExamSlots
     * const examSlot = await prisma.examSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamSlotCreateManyArgs>(args?: SelectSubset<T, ExamSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamSlot.
     * @param {ExamSlotDeleteArgs} args - Arguments to delete one ExamSlot.
     * @example
     * // Delete one ExamSlot
     * const ExamSlot = await prisma.examSlot.delete({
     *   where: {
     *     // ... filter to delete one ExamSlot
     *   }
     * })
     * 
     */
    delete<T extends ExamSlotDeleteArgs>(args: SelectSubset<T, ExamSlotDeleteArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamSlot.
     * @param {ExamSlotUpdateArgs} args - Arguments to update one ExamSlot.
     * @example
     * // Update one ExamSlot
     * const examSlot = await prisma.examSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamSlotUpdateArgs>(args: SelectSubset<T, ExamSlotUpdateArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamSlots.
     * @param {ExamSlotDeleteManyArgs} args - Arguments to filter ExamSlots to delete.
     * @example
     * // Delete a few ExamSlots
     * const { count } = await prisma.examSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamSlotDeleteManyArgs>(args?: SelectSubset<T, ExamSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamSlots
     * const examSlot = await prisma.examSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamSlotUpdateManyArgs>(args: SelectSubset<T, ExamSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamSlot.
     * @param {ExamSlotUpsertArgs} args - Arguments to update or create a ExamSlot.
     * @example
     * // Update or create a ExamSlot
     * const examSlot = await prisma.examSlot.upsert({
     *   create: {
     *     // ... data to create a ExamSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamSlot we want to update
     *   }
     * })
     */
    upsert<T extends ExamSlotUpsertArgs>(args: SelectSubset<T, ExamSlotUpsertArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSlotCountArgs} args - Arguments to filter ExamSlots to count.
     * @example
     * // Count the number of ExamSlots
     * const count = await prisma.examSlot.count({
     *   where: {
     *     // ... the filter for the ExamSlots we want to count
     *   }
     * })
    **/
    count<T extends ExamSlotCountArgs>(
      args?: Subset<T, ExamSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamSlotAggregateArgs>(args: Subset<T, ExamSlotAggregateArgs>): Prisma.PrismaPromise<GetExamSlotAggregateType<T>>

    /**
     * Group by ExamSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamSlotGroupByArgs['orderBy'] }
        : { orderBy?: ExamSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamSlot model
   */
  readonly fields: ExamSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examSchedule<T extends ExamScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamScheduleDefaultArgs<ExtArgs>>): Prisma__ExamScheduleClient<$Result.GetResult<Prisma.$ExamSchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proctors<T extends ExamSlot$proctorsArgs<ExtArgs> = {}>(args?: Subset<T, ExamSlot$proctorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamSlot model
   */ 
  interface ExamSlotFieldRefs {
    readonly id: FieldRef<"ExamSlot", 'String'>
    readonly examScheduleId: FieldRef<"ExamSlot", 'String'>
    readonly roomId: FieldRef<"ExamSlot", 'String'>
    readonly capacity: FieldRef<"ExamSlot", 'Int'>
    readonly assignedCount: FieldRef<"ExamSlot", 'Int'>
    readonly createdAt: FieldRef<"ExamSlot", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamSlot findUnique
   */
  export type ExamSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * Filter, which ExamSlot to fetch.
     */
    where: ExamSlotWhereUniqueInput
  }

  /**
   * ExamSlot findUniqueOrThrow
   */
  export type ExamSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * Filter, which ExamSlot to fetch.
     */
    where: ExamSlotWhereUniqueInput
  }

  /**
   * ExamSlot findFirst
   */
  export type ExamSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * Filter, which ExamSlot to fetch.
     */
    where?: ExamSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSlots to fetch.
     */
    orderBy?: ExamSlotOrderByWithRelationInput | ExamSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSlots.
     */
    cursor?: ExamSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSlots.
     */
    distinct?: ExamSlotScalarFieldEnum | ExamSlotScalarFieldEnum[]
  }

  /**
   * ExamSlot findFirstOrThrow
   */
  export type ExamSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * Filter, which ExamSlot to fetch.
     */
    where?: ExamSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSlots to fetch.
     */
    orderBy?: ExamSlotOrderByWithRelationInput | ExamSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSlots.
     */
    cursor?: ExamSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSlots.
     */
    distinct?: ExamSlotScalarFieldEnum | ExamSlotScalarFieldEnum[]
  }

  /**
   * ExamSlot findMany
   */
  export type ExamSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * Filter, which ExamSlots to fetch.
     */
    where?: ExamSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSlots to fetch.
     */
    orderBy?: ExamSlotOrderByWithRelationInput | ExamSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamSlots.
     */
    cursor?: ExamSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSlots.
     */
    skip?: number
    distinct?: ExamSlotScalarFieldEnum | ExamSlotScalarFieldEnum[]
  }

  /**
   * ExamSlot create
   */
  export type ExamSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamSlot.
     */
    data: XOR<ExamSlotCreateInput, ExamSlotUncheckedCreateInput>
  }

  /**
   * ExamSlot createMany
   */
  export type ExamSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamSlots.
     */
    data: ExamSlotCreateManyInput | ExamSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamSlot update
   */
  export type ExamSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamSlot.
     */
    data: XOR<ExamSlotUpdateInput, ExamSlotUncheckedUpdateInput>
    /**
     * Choose, which ExamSlot to update.
     */
    where: ExamSlotWhereUniqueInput
  }

  /**
   * ExamSlot updateMany
   */
  export type ExamSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamSlots.
     */
    data: XOR<ExamSlotUpdateManyMutationInput, ExamSlotUncheckedUpdateManyInput>
    /**
     * Filter which ExamSlots to update
     */
    where?: ExamSlotWhereInput
  }

  /**
   * ExamSlot upsert
   */
  export type ExamSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamSlot to update in case it exists.
     */
    where: ExamSlotWhereUniqueInput
    /**
     * In case the ExamSlot found by the `where` argument doesn't exist, create a new ExamSlot with this data.
     */
    create: XOR<ExamSlotCreateInput, ExamSlotUncheckedCreateInput>
    /**
     * In case the ExamSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamSlotUpdateInput, ExamSlotUncheckedUpdateInput>
  }

  /**
   * ExamSlot delete
   */
  export type ExamSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
    /**
     * Filter which ExamSlot to delete.
     */
    where: ExamSlotWhereUniqueInput
  }

  /**
   * ExamSlot deleteMany
   */
  export type ExamSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSlots to delete
     */
    where?: ExamSlotWhereInput
  }

  /**
   * ExamSlot.proctors
   */
  export type ExamSlot$proctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    where?: ExamProctorWhereInput
    orderBy?: ExamProctorOrderByWithRelationInput | ExamProctorOrderByWithRelationInput[]
    cursor?: ExamProctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamProctorScalarFieldEnum | ExamProctorScalarFieldEnum[]
  }

  /**
   * ExamSlot without action
   */
  export type ExamSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSlot
     */
    select?: ExamSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSlotInclude<ExtArgs> | null
  }


  /**
   * Model ExamProctor
   */

  export type AggregateExamProctor = {
    _count: ExamProctorCountAggregateOutputType | null
    _min: ExamProctorMinAggregateOutputType | null
    _max: ExamProctorMaxAggregateOutputType | null
  }

  export type ExamProctorMinAggregateOutputType = {
    id: string | null
    examSlotId: string | null
    proctorId: string | null
    role: $Enums.ProctorRole | null
    isConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamProctorMaxAggregateOutputType = {
    id: string | null
    examSlotId: string | null
    proctorId: string | null
    role: $Enums.ProctorRole | null
    isConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamProctorCountAggregateOutputType = {
    id: number
    examSlotId: number
    proctorId: number
    role: number
    isConfirmed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamProctorMinAggregateInputType = {
    id?: true
    examSlotId?: true
    proctorId?: true
    role?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamProctorMaxAggregateInputType = {
    id?: true
    examSlotId?: true
    proctorId?: true
    role?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamProctorCountAggregateInputType = {
    id?: true
    examSlotId?: true
    proctorId?: true
    role?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamProctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamProctor to aggregate.
     */
    where?: ExamProctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamProctors to fetch.
     */
    orderBy?: ExamProctorOrderByWithRelationInput | ExamProctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamProctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamProctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamProctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamProctors
    **/
    _count?: true | ExamProctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamProctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamProctorMaxAggregateInputType
  }

  export type GetExamProctorAggregateType<T extends ExamProctorAggregateArgs> = {
        [P in keyof T & keyof AggregateExamProctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamProctor[P]>
      : GetScalarType<T[P], AggregateExamProctor[P]>
  }




  export type ExamProctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamProctorWhereInput
    orderBy?: ExamProctorOrderByWithAggregationInput | ExamProctorOrderByWithAggregationInput[]
    by: ExamProctorScalarFieldEnum[] | ExamProctorScalarFieldEnum
    having?: ExamProctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamProctorCountAggregateInputType | true
    _min?: ExamProctorMinAggregateInputType
    _max?: ExamProctorMaxAggregateInputType
  }

  export type ExamProctorGroupByOutputType = {
    id: string
    examSlotId: string
    proctorId: string
    role: $Enums.ProctorRole
    isConfirmed: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExamProctorCountAggregateOutputType | null
    _min: ExamProctorMinAggregateOutputType | null
    _max: ExamProctorMaxAggregateOutputType | null
  }

  type GetExamProctorGroupByPayload<T extends ExamProctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamProctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamProctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamProctorGroupByOutputType[P]>
            : GetScalarType<T[P], ExamProctorGroupByOutputType[P]>
        }
      >
    >


  export type ExamProctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examSlotId?: boolean
    proctorId?: boolean
    role?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examSlot?: boolean | ExamSlotDefaultArgs<ExtArgs>
    proctor?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examProctor"]>


  export type ExamProctorSelectScalar = {
    id?: boolean
    examSlotId?: boolean
    proctorId?: boolean
    role?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamProctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examSlot?: boolean | ExamSlotDefaultArgs<ExtArgs>
    proctor?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $ExamProctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamProctor"
    objects: {
      examSlot: Prisma.$ExamSlotPayload<ExtArgs>
      proctor: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examSlotId: string
      proctorId: string
      role: $Enums.ProctorRole
      isConfirmed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examProctor"]>
    composites: {}
  }

  type ExamProctorGetPayload<S extends boolean | null | undefined | ExamProctorDefaultArgs> = $Result.GetResult<Prisma.$ExamProctorPayload, S>

  type ExamProctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamProctorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamProctorCountAggregateInputType | true
    }

  export interface ExamProctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamProctor'], meta: { name: 'ExamProctor' } }
    /**
     * Find zero or one ExamProctor that matches the filter.
     * @param {ExamProctorFindUniqueArgs} args - Arguments to find a ExamProctor
     * @example
     * // Get one ExamProctor
     * const examProctor = await prisma.examProctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamProctorFindUniqueArgs>(args: SelectSubset<T, ExamProctorFindUniqueArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamProctor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamProctorFindUniqueOrThrowArgs} args - Arguments to find a ExamProctor
     * @example
     * // Get one ExamProctor
     * const examProctor = await prisma.examProctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamProctorFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamProctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamProctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamProctorFindFirstArgs} args - Arguments to find a ExamProctor
     * @example
     * // Get one ExamProctor
     * const examProctor = await prisma.examProctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamProctorFindFirstArgs>(args?: SelectSubset<T, ExamProctorFindFirstArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamProctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamProctorFindFirstOrThrowArgs} args - Arguments to find a ExamProctor
     * @example
     * // Get one ExamProctor
     * const examProctor = await prisma.examProctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamProctorFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamProctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamProctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamProctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamProctors
     * const examProctors = await prisma.examProctor.findMany()
     * 
     * // Get first 10 ExamProctors
     * const examProctors = await prisma.examProctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examProctorWithIdOnly = await prisma.examProctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamProctorFindManyArgs>(args?: SelectSubset<T, ExamProctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamProctor.
     * @param {ExamProctorCreateArgs} args - Arguments to create a ExamProctor.
     * @example
     * // Create one ExamProctor
     * const ExamProctor = await prisma.examProctor.create({
     *   data: {
     *     // ... data to create a ExamProctor
     *   }
     * })
     * 
     */
    create<T extends ExamProctorCreateArgs>(args: SelectSubset<T, ExamProctorCreateArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamProctors.
     * @param {ExamProctorCreateManyArgs} args - Arguments to create many ExamProctors.
     * @example
     * // Create many ExamProctors
     * const examProctor = await prisma.examProctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamProctorCreateManyArgs>(args?: SelectSubset<T, ExamProctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamProctor.
     * @param {ExamProctorDeleteArgs} args - Arguments to delete one ExamProctor.
     * @example
     * // Delete one ExamProctor
     * const ExamProctor = await prisma.examProctor.delete({
     *   where: {
     *     // ... filter to delete one ExamProctor
     *   }
     * })
     * 
     */
    delete<T extends ExamProctorDeleteArgs>(args: SelectSubset<T, ExamProctorDeleteArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamProctor.
     * @param {ExamProctorUpdateArgs} args - Arguments to update one ExamProctor.
     * @example
     * // Update one ExamProctor
     * const examProctor = await prisma.examProctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamProctorUpdateArgs>(args: SelectSubset<T, ExamProctorUpdateArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamProctors.
     * @param {ExamProctorDeleteManyArgs} args - Arguments to filter ExamProctors to delete.
     * @example
     * // Delete a few ExamProctors
     * const { count } = await prisma.examProctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamProctorDeleteManyArgs>(args?: SelectSubset<T, ExamProctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamProctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamProctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamProctors
     * const examProctor = await prisma.examProctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamProctorUpdateManyArgs>(args: SelectSubset<T, ExamProctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamProctor.
     * @param {ExamProctorUpsertArgs} args - Arguments to update or create a ExamProctor.
     * @example
     * // Update or create a ExamProctor
     * const examProctor = await prisma.examProctor.upsert({
     *   create: {
     *     // ... data to create a ExamProctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamProctor we want to update
     *   }
     * })
     */
    upsert<T extends ExamProctorUpsertArgs>(args: SelectSubset<T, ExamProctorUpsertArgs<ExtArgs>>): Prisma__ExamProctorClient<$Result.GetResult<Prisma.$ExamProctorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamProctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamProctorCountArgs} args - Arguments to filter ExamProctors to count.
     * @example
     * // Count the number of ExamProctors
     * const count = await prisma.examProctor.count({
     *   where: {
     *     // ... the filter for the ExamProctors we want to count
     *   }
     * })
    **/
    count<T extends ExamProctorCountArgs>(
      args?: Subset<T, ExamProctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamProctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamProctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamProctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamProctorAggregateArgs>(args: Subset<T, ExamProctorAggregateArgs>): Prisma.PrismaPromise<GetExamProctorAggregateType<T>>

    /**
     * Group by ExamProctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamProctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamProctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamProctorGroupByArgs['orderBy'] }
        : { orderBy?: ExamProctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamProctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamProctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamProctor model
   */
  readonly fields: ExamProctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamProctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamProctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examSlot<T extends ExamSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamSlotDefaultArgs<ExtArgs>>): Prisma__ExamSlotClient<$Result.GetResult<Prisma.$ExamSlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proctor<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamProctor model
   */ 
  interface ExamProctorFieldRefs {
    readonly id: FieldRef<"ExamProctor", 'String'>
    readonly examSlotId: FieldRef<"ExamProctor", 'String'>
    readonly proctorId: FieldRef<"ExamProctor", 'String'>
    readonly role: FieldRef<"ExamProctor", 'ProctorRole'>
    readonly isConfirmed: FieldRef<"ExamProctor", 'Boolean'>
    readonly createdAt: FieldRef<"ExamProctor", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamProctor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamProctor findUnique
   */
  export type ExamProctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * Filter, which ExamProctor to fetch.
     */
    where: ExamProctorWhereUniqueInput
  }

  /**
   * ExamProctor findUniqueOrThrow
   */
  export type ExamProctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * Filter, which ExamProctor to fetch.
     */
    where: ExamProctorWhereUniqueInput
  }

  /**
   * ExamProctor findFirst
   */
  export type ExamProctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * Filter, which ExamProctor to fetch.
     */
    where?: ExamProctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamProctors to fetch.
     */
    orderBy?: ExamProctorOrderByWithRelationInput | ExamProctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamProctors.
     */
    cursor?: ExamProctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamProctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamProctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamProctors.
     */
    distinct?: ExamProctorScalarFieldEnum | ExamProctorScalarFieldEnum[]
  }

  /**
   * ExamProctor findFirstOrThrow
   */
  export type ExamProctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * Filter, which ExamProctor to fetch.
     */
    where?: ExamProctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamProctors to fetch.
     */
    orderBy?: ExamProctorOrderByWithRelationInput | ExamProctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamProctors.
     */
    cursor?: ExamProctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamProctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamProctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamProctors.
     */
    distinct?: ExamProctorScalarFieldEnum | ExamProctorScalarFieldEnum[]
  }

  /**
   * ExamProctor findMany
   */
  export type ExamProctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * Filter, which ExamProctors to fetch.
     */
    where?: ExamProctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamProctors to fetch.
     */
    orderBy?: ExamProctorOrderByWithRelationInput | ExamProctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamProctors.
     */
    cursor?: ExamProctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamProctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamProctors.
     */
    skip?: number
    distinct?: ExamProctorScalarFieldEnum | ExamProctorScalarFieldEnum[]
  }

  /**
   * ExamProctor create
   */
  export type ExamProctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamProctor.
     */
    data: XOR<ExamProctorCreateInput, ExamProctorUncheckedCreateInput>
  }

  /**
   * ExamProctor createMany
   */
  export type ExamProctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamProctors.
     */
    data: ExamProctorCreateManyInput | ExamProctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamProctor update
   */
  export type ExamProctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamProctor.
     */
    data: XOR<ExamProctorUpdateInput, ExamProctorUncheckedUpdateInput>
    /**
     * Choose, which ExamProctor to update.
     */
    where: ExamProctorWhereUniqueInput
  }

  /**
   * ExamProctor updateMany
   */
  export type ExamProctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamProctors.
     */
    data: XOR<ExamProctorUpdateManyMutationInput, ExamProctorUncheckedUpdateManyInput>
    /**
     * Filter which ExamProctors to update
     */
    where?: ExamProctorWhereInput
  }

  /**
   * ExamProctor upsert
   */
  export type ExamProctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamProctor to update in case it exists.
     */
    where: ExamProctorWhereUniqueInput
    /**
     * In case the ExamProctor found by the `where` argument doesn't exist, create a new ExamProctor with this data.
     */
    create: XOR<ExamProctorCreateInput, ExamProctorUncheckedCreateInput>
    /**
     * In case the ExamProctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamProctorUpdateInput, ExamProctorUncheckedUpdateInput>
  }

  /**
   * ExamProctor delete
   */
  export type ExamProctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
    /**
     * Filter which ExamProctor to delete.
     */
    where: ExamProctorWhereUniqueInput
  }

  /**
   * ExamProctor deleteMany
   */
  export type ExamProctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamProctors to delete
     */
    where?: ExamProctorWhereInput
  }

  /**
   * ExamProctor without action
   */
  export type ExamProctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamProctor
     */
    select?: ExamProctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamProctorInclude<ExtArgs> | null
  }


  /**
   * Model TeachingLoad
   */

  export type AggregateTeachingLoad = {
    _count: TeachingLoadCountAggregateOutputType | null
    _avg: TeachingLoadAvgAggregateOutputType | null
    _sum: TeachingLoadSumAggregateOutputType | null
    _min: TeachingLoadMinAggregateOutputType | null
    _max: TeachingLoadMaxAggregateOutputType | null
  }

  export type TeachingLoadAvgAggregateOutputType = {
    lectureHours: number | null
    labHours: number | null
    totalHours: number | null
    courseCount: number | null
  }

  export type TeachingLoadSumAggregateOutputType = {
    lectureHours: number | null
    labHours: number | null
    totalHours: number | null
    courseCount: number | null
  }

  export type TeachingLoadMinAggregateOutputType = {
    id: string | null
    instructorId: string | null
    termId: string | null
    lectureHours: number | null
    labHours: number | null
    totalHours: number | null
    courseCount: number | null
    isApproved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeachingLoadMaxAggregateOutputType = {
    id: string | null
    instructorId: string | null
    termId: string | null
    lectureHours: number | null
    labHours: number | null
    totalHours: number | null
    courseCount: number | null
    isApproved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeachingLoadCountAggregateOutputType = {
    id: number
    instructorId: number
    termId: number
    lectureHours: number
    labHours: number
    totalHours: number
    courseCount: number
    isApproved: number
    approvedBy: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeachingLoadAvgAggregateInputType = {
    lectureHours?: true
    labHours?: true
    totalHours?: true
    courseCount?: true
  }

  export type TeachingLoadSumAggregateInputType = {
    lectureHours?: true
    labHours?: true
    totalHours?: true
    courseCount?: true
  }

  export type TeachingLoadMinAggregateInputType = {
    id?: true
    instructorId?: true
    termId?: true
    lectureHours?: true
    labHours?: true
    totalHours?: true
    courseCount?: true
    isApproved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeachingLoadMaxAggregateInputType = {
    id?: true
    instructorId?: true
    termId?: true
    lectureHours?: true
    labHours?: true
    totalHours?: true
    courseCount?: true
    isApproved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeachingLoadCountAggregateInputType = {
    id?: true
    instructorId?: true
    termId?: true
    lectureHours?: true
    labHours?: true
    totalHours?: true
    courseCount?: true
    isApproved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeachingLoadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeachingLoad to aggregate.
     */
    where?: TeachingLoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingLoads to fetch.
     */
    orderBy?: TeachingLoadOrderByWithRelationInput | TeachingLoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeachingLoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingLoads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeachingLoads
    **/
    _count?: true | TeachingLoadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachingLoadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachingLoadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachingLoadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachingLoadMaxAggregateInputType
  }

  export type GetTeachingLoadAggregateType<T extends TeachingLoadAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachingLoad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachingLoad[P]>
      : GetScalarType<T[P], AggregateTeachingLoad[P]>
  }




  export type TeachingLoadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingLoadWhereInput
    orderBy?: TeachingLoadOrderByWithAggregationInput | TeachingLoadOrderByWithAggregationInput[]
    by: TeachingLoadScalarFieldEnum[] | TeachingLoadScalarFieldEnum
    having?: TeachingLoadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachingLoadCountAggregateInputType | true
    _avg?: TeachingLoadAvgAggregateInputType
    _sum?: TeachingLoadSumAggregateInputType
    _min?: TeachingLoadMinAggregateInputType
    _max?: TeachingLoadMaxAggregateInputType
  }

  export type TeachingLoadGroupByOutputType = {
    id: string
    instructorId: string
    termId: string
    lectureHours: number
    labHours: number
    totalHours: number
    courseCount: number
    isApproved: boolean
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TeachingLoadCountAggregateOutputType | null
    _avg: TeachingLoadAvgAggregateOutputType | null
    _sum: TeachingLoadSumAggregateOutputType | null
    _min: TeachingLoadMinAggregateOutputType | null
    _max: TeachingLoadMaxAggregateOutputType | null
  }

  type GetTeachingLoadGroupByPayload<T extends TeachingLoadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachingLoadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachingLoadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachingLoadGroupByOutputType[P]>
            : GetScalarType<T[P], TeachingLoadGroupByOutputType[P]>
        }
      >
    >


  export type TeachingLoadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    termId?: boolean
    lectureHours?: boolean
    labHours?: boolean
    totalHours?: boolean
    courseCount?: boolean
    isApproved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instructor?: boolean | PersonnelDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachingLoad"]>


  export type TeachingLoadSelectScalar = {
    id?: boolean
    instructorId?: boolean
    termId?: boolean
    lectureHours?: boolean
    labHours?: boolean
    totalHours?: boolean
    courseCount?: boolean
    isApproved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeachingLoadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | PersonnelDefaultArgs<ExtArgs>
    term?: boolean | AcademicTermDefaultArgs<ExtArgs>
  }

  export type $TeachingLoadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeachingLoad"
    objects: {
      instructor: Prisma.$PersonnelPayload<ExtArgs>
      term: Prisma.$AcademicTermPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instructorId: string
      termId: string
      lectureHours: number
      labHours: number
      totalHours: number
      courseCount: number
      isApproved: boolean
      approvedBy: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teachingLoad"]>
    composites: {}
  }

  type TeachingLoadGetPayload<S extends boolean | null | undefined | TeachingLoadDefaultArgs> = $Result.GetResult<Prisma.$TeachingLoadPayload, S>

  type TeachingLoadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeachingLoadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeachingLoadCountAggregateInputType | true
    }

  export interface TeachingLoadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeachingLoad'], meta: { name: 'TeachingLoad' } }
    /**
     * Find zero or one TeachingLoad that matches the filter.
     * @param {TeachingLoadFindUniqueArgs} args - Arguments to find a TeachingLoad
     * @example
     * // Get one TeachingLoad
     * const teachingLoad = await prisma.teachingLoad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeachingLoadFindUniqueArgs>(args: SelectSubset<T, TeachingLoadFindUniqueArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeachingLoad that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeachingLoadFindUniqueOrThrowArgs} args - Arguments to find a TeachingLoad
     * @example
     * // Get one TeachingLoad
     * const teachingLoad = await prisma.teachingLoad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeachingLoadFindUniqueOrThrowArgs>(args: SelectSubset<T, TeachingLoadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeachingLoad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingLoadFindFirstArgs} args - Arguments to find a TeachingLoad
     * @example
     * // Get one TeachingLoad
     * const teachingLoad = await prisma.teachingLoad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeachingLoadFindFirstArgs>(args?: SelectSubset<T, TeachingLoadFindFirstArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeachingLoad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingLoadFindFirstOrThrowArgs} args - Arguments to find a TeachingLoad
     * @example
     * // Get one TeachingLoad
     * const teachingLoad = await prisma.teachingLoad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeachingLoadFindFirstOrThrowArgs>(args?: SelectSubset<T, TeachingLoadFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeachingLoads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingLoadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeachingLoads
     * const teachingLoads = await prisma.teachingLoad.findMany()
     * 
     * // Get first 10 TeachingLoads
     * const teachingLoads = await prisma.teachingLoad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachingLoadWithIdOnly = await prisma.teachingLoad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeachingLoadFindManyArgs>(args?: SelectSubset<T, TeachingLoadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeachingLoad.
     * @param {TeachingLoadCreateArgs} args - Arguments to create a TeachingLoad.
     * @example
     * // Create one TeachingLoad
     * const TeachingLoad = await prisma.teachingLoad.create({
     *   data: {
     *     // ... data to create a TeachingLoad
     *   }
     * })
     * 
     */
    create<T extends TeachingLoadCreateArgs>(args: SelectSubset<T, TeachingLoadCreateArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeachingLoads.
     * @param {TeachingLoadCreateManyArgs} args - Arguments to create many TeachingLoads.
     * @example
     * // Create many TeachingLoads
     * const teachingLoad = await prisma.teachingLoad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeachingLoadCreateManyArgs>(args?: SelectSubset<T, TeachingLoadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeachingLoad.
     * @param {TeachingLoadDeleteArgs} args - Arguments to delete one TeachingLoad.
     * @example
     * // Delete one TeachingLoad
     * const TeachingLoad = await prisma.teachingLoad.delete({
     *   where: {
     *     // ... filter to delete one TeachingLoad
     *   }
     * })
     * 
     */
    delete<T extends TeachingLoadDeleteArgs>(args: SelectSubset<T, TeachingLoadDeleteArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeachingLoad.
     * @param {TeachingLoadUpdateArgs} args - Arguments to update one TeachingLoad.
     * @example
     * // Update one TeachingLoad
     * const teachingLoad = await prisma.teachingLoad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeachingLoadUpdateArgs>(args: SelectSubset<T, TeachingLoadUpdateArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeachingLoads.
     * @param {TeachingLoadDeleteManyArgs} args - Arguments to filter TeachingLoads to delete.
     * @example
     * // Delete a few TeachingLoads
     * const { count } = await prisma.teachingLoad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeachingLoadDeleteManyArgs>(args?: SelectSubset<T, TeachingLoadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeachingLoads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingLoadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeachingLoads
     * const teachingLoad = await prisma.teachingLoad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeachingLoadUpdateManyArgs>(args: SelectSubset<T, TeachingLoadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeachingLoad.
     * @param {TeachingLoadUpsertArgs} args - Arguments to update or create a TeachingLoad.
     * @example
     * // Update or create a TeachingLoad
     * const teachingLoad = await prisma.teachingLoad.upsert({
     *   create: {
     *     // ... data to create a TeachingLoad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeachingLoad we want to update
     *   }
     * })
     */
    upsert<T extends TeachingLoadUpsertArgs>(args: SelectSubset<T, TeachingLoadUpsertArgs<ExtArgs>>): Prisma__TeachingLoadClient<$Result.GetResult<Prisma.$TeachingLoadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeachingLoads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingLoadCountArgs} args - Arguments to filter TeachingLoads to count.
     * @example
     * // Count the number of TeachingLoads
     * const count = await prisma.teachingLoad.count({
     *   where: {
     *     // ... the filter for the TeachingLoads we want to count
     *   }
     * })
    **/
    count<T extends TeachingLoadCountArgs>(
      args?: Subset<T, TeachingLoadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachingLoadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeachingLoad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingLoadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachingLoadAggregateArgs>(args: Subset<T, TeachingLoadAggregateArgs>): Prisma.PrismaPromise<GetTeachingLoadAggregateType<T>>

    /**
     * Group by TeachingLoad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingLoadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeachingLoadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeachingLoadGroupByArgs['orderBy'] }
        : { orderBy?: TeachingLoadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeachingLoadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachingLoadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeachingLoad model
   */
  readonly fields: TeachingLoadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeachingLoad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeachingLoadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instructor<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    term<T extends AcademicTermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTermDefaultArgs<ExtArgs>>): Prisma__AcademicTermClient<$Result.GetResult<Prisma.$AcademicTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeachingLoad model
   */ 
  interface TeachingLoadFieldRefs {
    readonly id: FieldRef<"TeachingLoad", 'String'>
    readonly instructorId: FieldRef<"TeachingLoad", 'String'>
    readonly termId: FieldRef<"TeachingLoad", 'String'>
    readonly lectureHours: FieldRef<"TeachingLoad", 'Float'>
    readonly labHours: FieldRef<"TeachingLoad", 'Float'>
    readonly totalHours: FieldRef<"TeachingLoad", 'Float'>
    readonly courseCount: FieldRef<"TeachingLoad", 'Int'>
    readonly isApproved: FieldRef<"TeachingLoad", 'Boolean'>
    readonly approvedBy: FieldRef<"TeachingLoad", 'String'>
    readonly approvedAt: FieldRef<"TeachingLoad", 'DateTime'>
    readonly createdAt: FieldRef<"TeachingLoad", 'DateTime'>
    readonly updatedAt: FieldRef<"TeachingLoad", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeachingLoad findUnique
   */
  export type TeachingLoadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * Filter, which TeachingLoad to fetch.
     */
    where: TeachingLoadWhereUniqueInput
  }

  /**
   * TeachingLoad findUniqueOrThrow
   */
  export type TeachingLoadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * Filter, which TeachingLoad to fetch.
     */
    where: TeachingLoadWhereUniqueInput
  }

  /**
   * TeachingLoad findFirst
   */
  export type TeachingLoadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * Filter, which TeachingLoad to fetch.
     */
    where?: TeachingLoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingLoads to fetch.
     */
    orderBy?: TeachingLoadOrderByWithRelationInput | TeachingLoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeachingLoads.
     */
    cursor?: TeachingLoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingLoads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeachingLoads.
     */
    distinct?: TeachingLoadScalarFieldEnum | TeachingLoadScalarFieldEnum[]
  }

  /**
   * TeachingLoad findFirstOrThrow
   */
  export type TeachingLoadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * Filter, which TeachingLoad to fetch.
     */
    where?: TeachingLoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingLoads to fetch.
     */
    orderBy?: TeachingLoadOrderByWithRelationInput | TeachingLoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeachingLoads.
     */
    cursor?: TeachingLoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingLoads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeachingLoads.
     */
    distinct?: TeachingLoadScalarFieldEnum | TeachingLoadScalarFieldEnum[]
  }

  /**
   * TeachingLoad findMany
   */
  export type TeachingLoadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * Filter, which TeachingLoads to fetch.
     */
    where?: TeachingLoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingLoads to fetch.
     */
    orderBy?: TeachingLoadOrderByWithRelationInput | TeachingLoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeachingLoads.
     */
    cursor?: TeachingLoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingLoads.
     */
    skip?: number
    distinct?: TeachingLoadScalarFieldEnum | TeachingLoadScalarFieldEnum[]
  }

  /**
   * TeachingLoad create
   */
  export type TeachingLoadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * The data needed to create a TeachingLoad.
     */
    data: XOR<TeachingLoadCreateInput, TeachingLoadUncheckedCreateInput>
  }

  /**
   * TeachingLoad createMany
   */
  export type TeachingLoadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeachingLoads.
     */
    data: TeachingLoadCreateManyInput | TeachingLoadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeachingLoad update
   */
  export type TeachingLoadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * The data needed to update a TeachingLoad.
     */
    data: XOR<TeachingLoadUpdateInput, TeachingLoadUncheckedUpdateInput>
    /**
     * Choose, which TeachingLoad to update.
     */
    where: TeachingLoadWhereUniqueInput
  }

  /**
   * TeachingLoad updateMany
   */
  export type TeachingLoadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeachingLoads.
     */
    data: XOR<TeachingLoadUpdateManyMutationInput, TeachingLoadUncheckedUpdateManyInput>
    /**
     * Filter which TeachingLoads to update
     */
    where?: TeachingLoadWhereInput
  }

  /**
   * TeachingLoad upsert
   */
  export type TeachingLoadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * The filter to search for the TeachingLoad to update in case it exists.
     */
    where: TeachingLoadWhereUniqueInput
    /**
     * In case the TeachingLoad found by the `where` argument doesn't exist, create a new TeachingLoad with this data.
     */
    create: XOR<TeachingLoadCreateInput, TeachingLoadUncheckedCreateInput>
    /**
     * In case the TeachingLoad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeachingLoadUpdateInput, TeachingLoadUncheckedUpdateInput>
  }

  /**
   * TeachingLoad delete
   */
  export type TeachingLoadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
    /**
     * Filter which TeachingLoad to delete.
     */
    where: TeachingLoadWhereUniqueInput
  }

  /**
   * TeachingLoad deleteMany
   */
  export type TeachingLoadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeachingLoads to delete
     */
    where?: TeachingLoadWhereInput
  }

  /**
   * TeachingLoad without action
   */
  export type TeachingLoadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingLoad
     */
    select?: TeachingLoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingLoadInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    reason: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.LeaveRequestStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNote: string | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    reason: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.LeaveRequestStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNote: string | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    studentId: number
    reason: number
    startDate: number
    endDate: number
    status: number
    reviewedBy: number
    reviewedAt: number
    reviewNote: number
    documentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveRequestMinAggregateInputType = {
    id?: true
    studentId?: true
    reason?: true
    startDate?: true
    endDate?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNote?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    studentId?: true
    reason?: true
    startDate?: true
    endDate?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNote?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    studentId?: true
    reason?: true
    startDate?: true
    endDate?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNote?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    studentId: string
    reason: string
    startDate: Date
    endDate: Date
    status: $Enums.LeaveRequestStatus
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNote: string | null
    documentUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNote?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    reviewer?: boolean | LeaveRequest$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>


  export type LeaveRequestSelectScalar = {
    id?: boolean
    studentId?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNote?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    reviewer?: boolean | LeaveRequest$reviewerArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      reviewer: Prisma.$PersonnelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      reason: string
      startDate: Date
      endDate: Date
      status: $Enums.LeaveRequestStatus
      reviewedBy: string | null
      reviewedAt: Date | null
      reviewNote: string | null
      documentUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewer<T extends LeaveRequest$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$reviewerArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */ 
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly studentId: FieldRef<"LeaveRequest", 'String'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveRequestStatus'>
    readonly reviewedBy: FieldRef<"LeaveRequest", 'String'>
    readonly reviewedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly reviewNote: FieldRef<"LeaveRequest", 'String'>
    readonly documentUrl: FieldRef<"LeaveRequest", 'String'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest.reviewer
   */
  export type LeaveRequest$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorBackupCodes: 'twoFactorBackupCodes'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PersonnelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    title: 'title',
    position: 'position',
    phone: 'phone',
    profileImageUrl: 'profileImageUrl',
    facultyId: 'facultyId',
    departmentId: 'departmentId',
    bio: 'bio',
    expertise: 'expertise',
    education: 'education',
    publications: 'publications',
    officeHours: 'officeHours',
    officeLocation: 'officeLocation',
    isProfilePublic: 'isProfilePublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonnelScalarFieldEnum = (typeof PersonnelScalarFieldEnum)[keyof typeof PersonnelScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nameTh: 'nameTh',
    nameEn: 'nameEn',
    description: 'description',
    logoUrl: 'logoUrl'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    nameTh: 'nameTh',
    nameEn: 'nameEn',
    description: 'description',
    facultyId: 'facultyId'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    nameTh: 'nameTh',
    nameEn: 'nameEn',
    degreeLevel: 'degreeLevel',
    description: 'description',
    isAcceptingApplications: 'isAcceptingApplications',
    credits: 'credits',
    duration: 'duration',
    objectives: 'objectives',
    structure: 'structure',
    admissionRequirements: 'admissionRequirements',
    careerOpportunities: 'careerOpportunities',
    facultyId: 'facultyId',
    departmentId: 'departmentId'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nameTh: 'nameTh',
    nameEn: 'nameEn',
    credits: 'credits',
    description: 'description',
    learningOutcomes: 'learningOutcomes',
    syllabusUrl: 'syllabusUrl',
    minYearLevel: 'minYearLevel',
    allowedStudentTypes: 'allowedStudentTypes',
    allowedPrograms: 'allowedPrograms',
    minGpax: 'minGpax',
    prerequisiteCourses: 'prerequisiteCourses',
    maxEnrollment: 'maxEnrollment',
    requiresApproval: 'requiresApproval'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const ProgramCourseScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    courseId: 'courseId',
    isRequired: 'isRequired',
    semester: 'semester'
  };

  export type ProgramCourseScalarFieldEnum = (typeof ProgramCourseScalarFieldEnum)[keyof typeof ProgramCourseScalarFieldEnum]


  export const AcademicTermScalarFieldEnum: {
    id: 'id',
    year: 'year',
    semester: 'semester',
    startDate: 'startDate',
    endDate: 'endDate',
    isCurrent: 'isCurrent'
  };

  export type AcademicTermScalarFieldEnum = (typeof AcademicTermScalarFieldEnum)[keyof typeof AcademicTermScalarFieldEnum]


  export const ApplicantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    firstNameTh: 'firstNameTh',
    lastNameTh: 'lastNameTh',
    nationality: 'nationality',
    title: 'title',
    citizenId: 'citizenId',
    birthDate: 'birthDate',
    gender: 'gender',
    phone: 'phone',
    address: 'address',
    subDistrict: 'subDistrict',
    district: 'district',
    province: 'province',
    zipCode: 'zipCode',
    profileImageUrl: 'profileImageUrl'
  };

  export type ApplicantScalarFieldEnum = (typeof ApplicantScalarFieldEnum)[keyof typeof ApplicantScalarFieldEnum]


  export const EducationHistoryScalarFieldEnum: {
    id: 'id',
    applicantId: 'applicantId',
    level: 'level',
    degreeName: 'degreeName',
    institution: 'institution',
    gpa: 'gpa',
    graduationYear: 'graduationYear'
  };

  export type EducationHistoryScalarFieldEnum = (typeof EducationHistoryScalarFieldEnum)[keyof typeof EducationHistoryScalarFieldEnum]


  export const AdmissionTrackTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nameTh: 'nameTh',
    nameEn: 'nameEn',
    description: 'description',
    color: 'color',
    icon: 'icon',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionTrackTypeScalarFieldEnum = (typeof AdmissionTrackTypeScalarFieldEnum)[keyof typeof AdmissionTrackTypeScalarFieldEnum]


  export const AdmissionTrackScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nameTh: 'nameTh',
    nameEn: 'nameEn',
    description: 'description',
    typeId: 'typeId',
    programId: 'programId',
    academicYear: 'academicYear',
    openDate: 'openDate',
    closeDate: 'closeDate',
    announceDate: 'announceDate',
    totalSeats: 'totalSeats',
    filledSeats: 'filledSeats',
    reservedSeats: 'reservedSeats',
    enableWaitlist: 'enableWaitlist',
    requirements: 'requirements',
    applicationFee: 'applicationFee',
    isActive: 'isActive',
    isPublished: 'isPublished',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionTrackScalarFieldEnum = (typeof AdmissionTrackScalarFieldEnum)[keyof typeof AdmissionTrackScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    applicantId: 'applicantId',
    trackId: 'trackId',
    programId: 'programId',
    status: 'status',
    submittedAt: 'submittedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    type: 'type',
    url: 'url',
    uploadedAt: 'uploadedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const InterviewSlotScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    location: 'location',
    coordinatorName: 'coordinatorName',
    coordinatorPhone: 'coordinatorPhone',
    description: 'description',
    programId: 'programId'
  };

  export type InterviewSlotScalarFieldEnum = (typeof InterviewSlotScalarFieldEnum)[keyof typeof InterviewSlotScalarFieldEnum]


  export const InterviewSlotInterviewerScalarFieldEnum: {
    id: 'id',
    slotId: 'slotId',
    interviewerId: 'interviewerId'
  };

  export type InterviewSlotInterviewerScalarFieldEnum = (typeof InterviewSlotInterviewerScalarFieldEnum)[keyof typeof InterviewSlotInterviewerScalarFieldEnum]


  export const InterviewResultScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    slotId: 'slotId',
    score: 'score',
    comments: 'comments',
    isPassed: 'isPassed',
    confirmedAt: 'confirmedAt',
    rescheduleRequested: 'rescheduleRequested',
    rescheduleReason: 'rescheduleReason',
    checkedInAt: 'checkedInAt'
  };

  export type InterviewResultScalarFieldEnum = (typeof InterviewResultScalarFieldEnum)[keyof typeof InterviewResultScalarFieldEnum]


  export const InterviewFeedbackScalarFieldEnum: {
    id: 'id',
    interviewResultId: 'interviewResultId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type InterviewFeedbackScalarFieldEnum = (typeof InterviewFeedbackScalarFieldEnum)[keyof typeof InterviewFeedbackScalarFieldEnum]


  export const StudentGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    admissionYear: 'admissionYear',
    programId: 'programId',
    advisorId: 'advisorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentGroupScalarFieldEnum = (typeof StudentGroupScalarFieldEnum)[keyof typeof StudentGroupScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    userId: 'userId',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    firstNameTh: 'firstNameTh',
    lastNameTh: 'lastNameTh',
    nationality: 'nationality',
    citizenId: 'citizenId',
    birthDate: 'birthDate',
    gender: 'gender',
    phone: 'phone',
    profileImageUrl: 'profileImageUrl',
    address: 'address',
    subDistrict: 'subDistrict',
    district: 'district',
    province: 'province',
    zipCode: 'zipCode',
    programId: 'programId',
    studentType: 'studentType',
    status: 'status',
    gpax: 'gpax',
    bio: 'bio',
    interests: 'interests',
    skills: 'skills',
    socialLinks: 'socialLinks',
    isProfilePublic: 'isProfilePublic',
    showGPA: 'showGPA',
    admissionYear: 'admissionYear',
    studentGroupId: 'studentGroupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ClassSectionScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    termId: 'termId',
    sectionNumber: 'sectionNumber',
    capacity: 'capacity',
    instructorId: 'instructorId'
  };

  export type ClassSectionScalarFieldEnum = (typeof ClassSectionScalarFieldEnum)[keyof typeof ClassSectionScalarFieldEnum]


  export const ClassScheduleScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    day: 'day',
    startTime: 'startTime',
    endTime: 'endTime',
    roomId: 'roomId',
    courseId: 'courseId',
    instructorId: 'instructorId',
    termId: 'termId'
  };

  export type ClassScheduleScalarFieldEnum = (typeof ClassScheduleScalarFieldEnum)[keyof typeof ClassScheduleScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    sectionId: 'sectionId',
    grade: 'grade',
    enrolledAt: 'enrolledAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    termId: 'termId',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    amount: 'amount'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    amount: 'amount',
    slipUrl: 'slipUrl',
    paidAt: 'paidAt',
    verifiedAt: 'verifiedAt',
    verifiedBy: 'verifiedBy'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    imageUrl: 'imageUrl',
    content: 'content',
    target: 'target',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    linkUrl: 'linkUrl',
    isActive: 'isActive',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const AiSettingsScalarFieldEnum: {
    id: 'id',
    botName: 'botName',
    welcomeMessage: 'welcomeMessage',
    personality: 'personality',
    isActive: 'isActive',
    updatedAt: 'updatedAt'
  };

  export type AiSettingsScalarFieldEnum = (typeof AiSettingsScalarFieldEnum)[keyof typeof AiSettingsScalarFieldEnum]


  export const AiKnowledgeBaseScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiKnowledgeBaseScalarFieldEnum = (typeof AiKnowledgeBaseScalarFieldEnum)[keyof typeof AiKnowledgeBaseScalarFieldEnum]


  export const AiConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiConversationScalarFieldEnum = (typeof AiConversationScalarFieldEnum)[keyof typeof AiConversationScalarFieldEnum]


  export const AiMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AiMessageScalarFieldEnum = (typeof AiMessageScalarFieldEnum)[keyof typeof AiMessageScalarFieldEnum]


  export const HelpCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpCategoryScalarFieldEnum = (typeof HelpCategoryScalarFieldEnum)[keyof typeof HelpCategoryScalarFieldEnum]


  export const HelpArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    categoryId: 'categoryId',
    visibility: 'visibility',
    isPublished: 'isPublished',
    authorId: 'authorId',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpArticleScalarFieldEnum = (typeof HelpArticleScalarFieldEnum)[keyof typeof HelpArticleScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    universityName: 'universityName',
    universityNameTh: 'universityNameTh',
    logoUrl: 'logoUrl',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    backgroundColor: 'backgroundColor',
    studentIdFormat: 'studentIdFormat',
    defaultLanguage: 'defaultLanguage',
    smtpHost: 'smtpHost',
    smtpPort: 'smtpPort',
    smtpUser: 'smtpUser',
    smtpPassword: 'smtpPassword',
    smtpSecure: 'smtpSecure',
    smtpFromEmail: 'smtpFromEmail',
    smtpFromName: 'smtpFromName',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    details: 'details',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const TranslationScalarFieldEnum: {
    id: 'id',
    key: 'key',
    th: 'th',
    en: 'en',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TranslationScalarFieldEnum = (typeof TranslationScalarFieldEnum)[keyof typeof TranslationScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    building: 'building',
    floor: 'floor',
    capacity: 'capacity',
    roomType: 'roomType',
    facilities: 'facilities',
    isActive: 'isActive',
    isAvailable: 'isAvailable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const ExamScheduleScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    section: 'section',
    termId: 'termId',
    examType: 'examType',
    examDate: 'examDate',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    examFormat: 'examFormat',
    instructions: 'instructions',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScheduleScalarFieldEnum = (typeof ExamScheduleScalarFieldEnum)[keyof typeof ExamScheduleScalarFieldEnum]


  export const ExamSlotScalarFieldEnum: {
    id: 'id',
    examScheduleId: 'examScheduleId',
    roomId: 'roomId',
    capacity: 'capacity',
    assignedCount: 'assignedCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamSlotScalarFieldEnum = (typeof ExamSlotScalarFieldEnum)[keyof typeof ExamSlotScalarFieldEnum]


  export const ExamProctorScalarFieldEnum: {
    id: 'id',
    examSlotId: 'examSlotId',
    proctorId: 'proctorId',
    role: 'role',
    isConfirmed: 'isConfirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamProctorScalarFieldEnum = (typeof ExamProctorScalarFieldEnum)[keyof typeof ExamProctorScalarFieldEnum]


  export const TeachingLoadScalarFieldEnum: {
    id: 'id',
    instructorId: 'instructorId',
    termId: 'termId',
    lectureHours: 'lectureHours',
    labHours: 'labHours',
    totalHours: 'totalHours',
    courseCount: 'courseCount',
    isApproved: 'isApproved',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeachingLoadScalarFieldEnum = (typeof TeachingLoadScalarFieldEnum)[keyof typeof TeachingLoadScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    reason: 'reason',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    reviewNote: 'reviewNote',
    documentUrl: 'documentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DegreeLevel'
   */
  export type EnumDegreeLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DegreeLevel'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'StudentType'
   */
  export type EnumStudentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentType'>
    


  /**
   * Reference to a field of type 'StudentStatus'
   */
  export type EnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus'>
    


  /**
   * Reference to a field of type 'DayOfWeek'
   */
  export type EnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'AnnouncementTarget'
   */
  export type EnumAnnouncementTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnouncementTarget'>
    


  /**
   * Reference to a field of type 'HelpArticleVisibility'
   */
  export type EnumHelpArticleVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HelpArticleVisibility'>
    


  /**
   * Reference to a field of type 'RoomType'
   */
  export type EnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType'>
    


  /**
   * Reference to a field of type 'ExamType'
   */
  export type EnumExamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamType'>
    


  /**
   * Reference to a field of type 'ExamFormat'
   */
  export type EnumExamFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamFormat'>
    


  /**
   * Reference to a field of type 'ProctorRole'
   */
  export type EnumProctorRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProctorRole'>
    


  /**
   * Reference to a field of type 'LeaveRequestStatus'
   */
  export type EnumLeaveRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveRequestStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    personnelProfile?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    studentProfile?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    applicantProfile?: XOR<ApplicantNullableRelationFilter, ApplicantWhereInput> | null
    logs?: SystemLogListRelationFilter
    announcements?: AnnouncementListRelationFilter
    helpArticles?: HelpArticleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    personnelProfile?: PersonnelOrderByWithRelationInput
    studentProfile?: StudentOrderByWithRelationInput
    applicantProfile?: ApplicantOrderByWithRelationInput
    logs?: SystemLogOrderByRelationAggregateInput
    announcements?: AnnouncementOrderByRelationAggregateInput
    helpArticles?: HelpArticleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    personnelProfile?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    studentProfile?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    applicantProfile?: XOR<ApplicantNullableRelationFilter, ApplicantWhereInput> | null
    logs?: SystemLogListRelationFilter
    announcements?: AnnouncementListRelationFilter
    helpArticles?: HelpArticleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorBackupCodes?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type PersonnelWhereInput = {
    AND?: PersonnelWhereInput | PersonnelWhereInput[]
    OR?: PersonnelWhereInput[]
    NOT?: PersonnelWhereInput | PersonnelWhereInput[]
    id?: StringFilter<"Personnel"> | string
    userId?: StringFilter<"Personnel"> | string
    firstName?: StringFilter<"Personnel"> | string
    lastName?: StringFilter<"Personnel"> | string
    title?: StringNullableFilter<"Personnel"> | string | null
    position?: StringNullableFilter<"Personnel"> | string | null
    phone?: StringNullableFilter<"Personnel"> | string | null
    profileImageUrl?: StringNullableFilter<"Personnel"> | string | null
    facultyId?: StringNullableFilter<"Personnel"> | string | null
    departmentId?: StringNullableFilter<"Personnel"> | string | null
    bio?: StringNullableFilter<"Personnel"> | string | null
    expertise?: StringNullableFilter<"Personnel"> | string | null
    education?: StringNullableFilter<"Personnel"> | string | null
    publications?: StringNullableFilter<"Personnel"> | string | null
    officeHours?: StringNullableFilter<"Personnel"> | string | null
    officeLocation?: StringNullableFilter<"Personnel"> | string | null
    isProfilePublic?: BoolFilter<"Personnel"> | boolean
    createdAt?: DateTimeFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeFilter<"Personnel"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    faculty?: XOR<FacultyNullableRelationFilter, FacultyWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    instructedSections?: ClassSectionListRelationFilter
    interviewSlots?: InterviewSlotInterviewerListRelationFilter
    teachingSchedules?: ClassScheduleListRelationFilter
    teachingLoads?: TeachingLoadListRelationFilter
    proctorDuties?: ExamProctorListRelationFilter
    advisorGroups?: StudentGroupListRelationFilter
    reviewedLeaveRequests?: LeaveRequestListRelationFilter
  }

  export type PersonnelOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    title?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    publications?: SortOrderInput | SortOrder
    officeHours?: SortOrderInput | SortOrder
    officeLocation?: SortOrderInput | SortOrder
    isProfilePublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    instructedSections?: ClassSectionOrderByRelationAggregateInput
    interviewSlots?: InterviewSlotInterviewerOrderByRelationAggregateInput
    teachingSchedules?: ClassScheduleOrderByRelationAggregateInput
    teachingLoads?: TeachingLoadOrderByRelationAggregateInput
    proctorDuties?: ExamProctorOrderByRelationAggregateInput
    advisorGroups?: StudentGroupOrderByRelationAggregateInput
    reviewedLeaveRequests?: LeaveRequestOrderByRelationAggregateInput
  }

  export type PersonnelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PersonnelWhereInput | PersonnelWhereInput[]
    OR?: PersonnelWhereInput[]
    NOT?: PersonnelWhereInput | PersonnelWhereInput[]
    firstName?: StringFilter<"Personnel"> | string
    lastName?: StringFilter<"Personnel"> | string
    title?: StringNullableFilter<"Personnel"> | string | null
    position?: StringNullableFilter<"Personnel"> | string | null
    phone?: StringNullableFilter<"Personnel"> | string | null
    profileImageUrl?: StringNullableFilter<"Personnel"> | string | null
    facultyId?: StringNullableFilter<"Personnel"> | string | null
    departmentId?: StringNullableFilter<"Personnel"> | string | null
    bio?: StringNullableFilter<"Personnel"> | string | null
    expertise?: StringNullableFilter<"Personnel"> | string | null
    education?: StringNullableFilter<"Personnel"> | string | null
    publications?: StringNullableFilter<"Personnel"> | string | null
    officeHours?: StringNullableFilter<"Personnel"> | string | null
    officeLocation?: StringNullableFilter<"Personnel"> | string | null
    isProfilePublic?: BoolFilter<"Personnel"> | boolean
    createdAt?: DateTimeFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeFilter<"Personnel"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    faculty?: XOR<FacultyNullableRelationFilter, FacultyWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    instructedSections?: ClassSectionListRelationFilter
    interviewSlots?: InterviewSlotInterviewerListRelationFilter
    teachingSchedules?: ClassScheduleListRelationFilter
    teachingLoads?: TeachingLoadListRelationFilter
    proctorDuties?: ExamProctorListRelationFilter
    advisorGroups?: StudentGroupListRelationFilter
    reviewedLeaveRequests?: LeaveRequestListRelationFilter
  }, "id" | "userId">

  export type PersonnelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    title?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    publications?: SortOrderInput | SortOrder
    officeHours?: SortOrderInput | SortOrder
    officeLocation?: SortOrderInput | SortOrder
    isProfilePublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonnelCountOrderByAggregateInput
    _max?: PersonnelMaxOrderByAggregateInput
    _min?: PersonnelMinOrderByAggregateInput
  }

  export type PersonnelScalarWhereWithAggregatesInput = {
    AND?: PersonnelScalarWhereWithAggregatesInput | PersonnelScalarWhereWithAggregatesInput[]
    OR?: PersonnelScalarWhereWithAggregatesInput[]
    NOT?: PersonnelScalarWhereWithAggregatesInput | PersonnelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Personnel"> | string
    userId?: StringWithAggregatesFilter<"Personnel"> | string
    firstName?: StringWithAggregatesFilter<"Personnel"> | string
    lastName?: StringWithAggregatesFilter<"Personnel"> | string
    title?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    position?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    facultyId?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    expertise?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    education?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    publications?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    officeHours?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    officeLocation?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    isProfilePublic?: BoolWithAggregatesFilter<"Personnel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Personnel"> | Date | string
  }

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    id?: StringFilter<"Faculty"> | string
    code?: StringFilter<"Faculty"> | string
    nameTh?: StringFilter<"Faculty"> | string
    nameEn?: StringFilter<"Faculty"> | string
    description?: StringNullableFilter<"Faculty"> | string | null
    logoUrl?: StringNullableFilter<"Faculty"> | string | null
    departments?: DepartmentListRelationFilter
    programs?: ProgramListRelationFilter
    personnel?: PersonnelListRelationFilter
  }

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    programs?: ProgramOrderByRelationAggregateInput
    personnel?: PersonnelOrderByRelationAggregateInput
  }

  export type FacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    nameTh?: StringFilter<"Faculty"> | string
    nameEn?: StringFilter<"Faculty"> | string
    description?: StringNullableFilter<"Faculty"> | string | null
    logoUrl?: StringNullableFilter<"Faculty"> | string | null
    departments?: DepartmentListRelationFilter
    programs?: ProgramListRelationFilter
    personnel?: PersonnelListRelationFilter
  }, "id" | "code">

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    OR?: FacultyScalarWhereWithAggregatesInput[]
    NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Faculty"> | string
    code?: StringWithAggregatesFilter<"Faculty"> | string
    nameTh?: StringWithAggregatesFilter<"Faculty"> | string
    nameEn?: StringWithAggregatesFilter<"Faculty"> | string
    description?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    nameTh?: StringFilter<"Department"> | string
    nameEn?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    facultyId?: StringFilter<"Department"> | string
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
    programs?: ProgramListRelationFilter
    personnel?: PersonnelListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    facultyId?: SortOrder
    faculty?: FacultyOrderByWithRelationInput
    programs?: ProgramOrderByRelationAggregateInput
    personnel?: PersonnelOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    nameTh?: StringFilter<"Department"> | string
    nameEn?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    facultyId?: StringFilter<"Department"> | string
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
    programs?: ProgramListRelationFilter
    personnel?: PersonnelListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    facultyId?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    nameTh?: StringWithAggregatesFilter<"Department"> | string
    nameEn?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    facultyId?: StringWithAggregatesFilter<"Department"> | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    nameTh?: StringFilter<"Program"> | string
    nameEn?: StringFilter<"Program"> | string
    degreeLevel?: EnumDegreeLevelFilter<"Program"> | $Enums.DegreeLevel
    description?: StringNullableFilter<"Program"> | string | null
    isAcceptingApplications?: BoolFilter<"Program"> | boolean
    credits?: IntNullableFilter<"Program"> | number | null
    duration?: StringNullableFilter<"Program"> | string | null
    objectives?: StringNullableFilter<"Program"> | string | null
    structure?: StringNullableFilter<"Program"> | string | null
    admissionRequirements?: StringNullableFilter<"Program"> | string | null
    careerOpportunities?: StringNullableFilter<"Program"> | string | null
    facultyId?: StringFilter<"Program"> | string
    departmentId?: StringFilter<"Program"> | string
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    applications?: ApplicationListRelationFilter
    students?: StudentListRelationFilter
    interviewSlots?: InterviewSlotListRelationFilter
    courses?: ProgramCourseListRelationFilter
    admissionTracks?: AdmissionTrackListRelationFilter
    studentGroups?: StudentGroupListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    degreeLevel?: SortOrder
    description?: SortOrderInput | SortOrder
    isAcceptingApplications?: SortOrder
    credits?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    structure?: SortOrderInput | SortOrder
    admissionRequirements?: SortOrderInput | SortOrder
    careerOpportunities?: SortOrderInput | SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    faculty?: FacultyOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    applications?: ApplicationOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    interviewSlots?: InterviewSlotOrderByRelationAggregateInput
    courses?: ProgramCourseOrderByRelationAggregateInput
    admissionTracks?: AdmissionTrackOrderByRelationAggregateInput
    studentGroups?: StudentGroupOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    nameTh?: StringFilter<"Program"> | string
    nameEn?: StringFilter<"Program"> | string
    degreeLevel?: EnumDegreeLevelFilter<"Program"> | $Enums.DegreeLevel
    description?: StringNullableFilter<"Program"> | string | null
    isAcceptingApplications?: BoolFilter<"Program"> | boolean
    credits?: IntNullableFilter<"Program"> | number | null
    duration?: StringNullableFilter<"Program"> | string | null
    objectives?: StringNullableFilter<"Program"> | string | null
    structure?: StringNullableFilter<"Program"> | string | null
    admissionRequirements?: StringNullableFilter<"Program"> | string | null
    careerOpportunities?: StringNullableFilter<"Program"> | string | null
    facultyId?: StringFilter<"Program"> | string
    departmentId?: StringFilter<"Program"> | string
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    applications?: ApplicationListRelationFilter
    students?: StudentListRelationFilter
    interviewSlots?: InterviewSlotListRelationFilter
    courses?: ProgramCourseListRelationFilter
    admissionTracks?: AdmissionTrackListRelationFilter
    studentGroups?: StudentGroupListRelationFilter
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    degreeLevel?: SortOrder
    description?: SortOrderInput | SortOrder
    isAcceptingApplications?: SortOrder
    credits?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    structure?: SortOrderInput | SortOrder
    admissionRequirements?: SortOrderInput | SortOrder
    careerOpportunities?: SortOrderInput | SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    nameTh?: StringWithAggregatesFilter<"Program"> | string
    nameEn?: StringWithAggregatesFilter<"Program"> | string
    degreeLevel?: EnumDegreeLevelWithAggregatesFilter<"Program"> | $Enums.DegreeLevel
    description?: StringNullableWithAggregatesFilter<"Program"> | string | null
    isAcceptingApplications?: BoolWithAggregatesFilter<"Program"> | boolean
    credits?: IntNullableWithAggregatesFilter<"Program"> | number | null
    duration?: StringNullableWithAggregatesFilter<"Program"> | string | null
    objectives?: StringNullableWithAggregatesFilter<"Program"> | string | null
    structure?: StringNullableWithAggregatesFilter<"Program"> | string | null
    admissionRequirements?: StringNullableWithAggregatesFilter<"Program"> | string | null
    careerOpportunities?: StringNullableWithAggregatesFilter<"Program"> | string | null
    facultyId?: StringWithAggregatesFilter<"Program"> | string
    departmentId?: StringWithAggregatesFilter<"Program"> | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    nameTh?: StringFilter<"Course"> | string
    nameEn?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    description?: StringNullableFilter<"Course"> | string | null
    learningOutcomes?: StringNullableFilter<"Course"> | string | null
    syllabusUrl?: StringNullableFilter<"Course"> | string | null
    minYearLevel?: IntNullableFilter<"Course"> | number | null
    allowedStudentTypes?: StringNullableFilter<"Course"> | string | null
    allowedPrograms?: StringNullableFilter<"Course"> | string | null
    minGpax?: FloatNullableFilter<"Course"> | number | null
    prerequisiteCourses?: StringNullableFilter<"Course"> | string | null
    maxEnrollment?: IntNullableFilter<"Course"> | number | null
    requiresApproval?: BoolFilter<"Course"> | boolean
    sections?: ClassSectionListRelationFilter
    programs?: ProgramCourseListRelationFilter
    schedules?: ClassScheduleListRelationFilter
    examSchedules?: ExamScheduleListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    credits?: SortOrder
    description?: SortOrderInput | SortOrder
    learningOutcomes?: SortOrderInput | SortOrder
    syllabusUrl?: SortOrderInput | SortOrder
    minYearLevel?: SortOrderInput | SortOrder
    allowedStudentTypes?: SortOrderInput | SortOrder
    allowedPrograms?: SortOrderInput | SortOrder
    minGpax?: SortOrderInput | SortOrder
    prerequisiteCourses?: SortOrderInput | SortOrder
    maxEnrollment?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    sections?: ClassSectionOrderByRelationAggregateInput
    programs?: ProgramCourseOrderByRelationAggregateInput
    schedules?: ClassScheduleOrderByRelationAggregateInput
    examSchedules?: ExamScheduleOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    nameTh?: StringFilter<"Course"> | string
    nameEn?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    description?: StringNullableFilter<"Course"> | string | null
    learningOutcomes?: StringNullableFilter<"Course"> | string | null
    syllabusUrl?: StringNullableFilter<"Course"> | string | null
    minYearLevel?: IntNullableFilter<"Course"> | number | null
    allowedStudentTypes?: StringNullableFilter<"Course"> | string | null
    allowedPrograms?: StringNullableFilter<"Course"> | string | null
    minGpax?: FloatNullableFilter<"Course"> | number | null
    prerequisiteCourses?: StringNullableFilter<"Course"> | string | null
    maxEnrollment?: IntNullableFilter<"Course"> | number | null
    requiresApproval?: BoolFilter<"Course"> | boolean
    sections?: ClassSectionListRelationFilter
    programs?: ProgramCourseListRelationFilter
    schedules?: ClassScheduleListRelationFilter
    examSchedules?: ExamScheduleListRelationFilter
  }, "id" | "code">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    credits?: SortOrder
    description?: SortOrderInput | SortOrder
    learningOutcomes?: SortOrderInput | SortOrder
    syllabusUrl?: SortOrderInput | SortOrder
    minYearLevel?: SortOrderInput | SortOrder
    allowedStudentTypes?: SortOrderInput | SortOrder
    allowedPrograms?: SortOrderInput | SortOrder
    minGpax?: SortOrderInput | SortOrder
    prerequisiteCourses?: SortOrderInput | SortOrder
    maxEnrollment?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    code?: StringWithAggregatesFilter<"Course"> | string
    nameTh?: StringWithAggregatesFilter<"Course"> | string
    nameEn?: StringWithAggregatesFilter<"Course"> | string
    credits?: IntWithAggregatesFilter<"Course"> | number
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    learningOutcomes?: StringNullableWithAggregatesFilter<"Course"> | string | null
    syllabusUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    minYearLevel?: IntNullableWithAggregatesFilter<"Course"> | number | null
    allowedStudentTypes?: StringNullableWithAggregatesFilter<"Course"> | string | null
    allowedPrograms?: StringNullableWithAggregatesFilter<"Course"> | string | null
    minGpax?: FloatNullableWithAggregatesFilter<"Course"> | number | null
    prerequisiteCourses?: StringNullableWithAggregatesFilter<"Course"> | string | null
    maxEnrollment?: IntNullableWithAggregatesFilter<"Course"> | number | null
    requiresApproval?: BoolWithAggregatesFilter<"Course"> | boolean
  }

  export type ProgramCourseWhereInput = {
    AND?: ProgramCourseWhereInput | ProgramCourseWhereInput[]
    OR?: ProgramCourseWhereInput[]
    NOT?: ProgramCourseWhereInput | ProgramCourseWhereInput[]
    id?: StringFilter<"ProgramCourse"> | string
    programId?: StringFilter<"ProgramCourse"> | string
    courseId?: StringFilter<"ProgramCourse"> | string
    isRequired?: BoolFilter<"ProgramCourse"> | boolean
    semester?: IntNullableFilter<"ProgramCourse"> | number | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type ProgramCourseOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    courseId?: SortOrder
    isRequired?: SortOrder
    semester?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type ProgramCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    programId_courseId?: ProgramCourseProgramIdCourseIdCompoundUniqueInput
    AND?: ProgramCourseWhereInput | ProgramCourseWhereInput[]
    OR?: ProgramCourseWhereInput[]
    NOT?: ProgramCourseWhereInput | ProgramCourseWhereInput[]
    programId?: StringFilter<"ProgramCourse"> | string
    courseId?: StringFilter<"ProgramCourse"> | string
    isRequired?: BoolFilter<"ProgramCourse"> | boolean
    semester?: IntNullableFilter<"ProgramCourse"> | number | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "programId_courseId">

  export type ProgramCourseOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    courseId?: SortOrder
    isRequired?: SortOrder
    semester?: SortOrderInput | SortOrder
    _count?: ProgramCourseCountOrderByAggregateInput
    _avg?: ProgramCourseAvgOrderByAggregateInput
    _max?: ProgramCourseMaxOrderByAggregateInput
    _min?: ProgramCourseMinOrderByAggregateInput
    _sum?: ProgramCourseSumOrderByAggregateInput
  }

  export type ProgramCourseScalarWhereWithAggregatesInput = {
    AND?: ProgramCourseScalarWhereWithAggregatesInput | ProgramCourseScalarWhereWithAggregatesInput[]
    OR?: ProgramCourseScalarWhereWithAggregatesInput[]
    NOT?: ProgramCourseScalarWhereWithAggregatesInput | ProgramCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramCourse"> | string
    programId?: StringWithAggregatesFilter<"ProgramCourse"> | string
    courseId?: StringWithAggregatesFilter<"ProgramCourse"> | string
    isRequired?: BoolWithAggregatesFilter<"ProgramCourse"> | boolean
    semester?: IntNullableWithAggregatesFilter<"ProgramCourse"> | number | null
  }

  export type AcademicTermWhereInput = {
    AND?: AcademicTermWhereInput | AcademicTermWhereInput[]
    OR?: AcademicTermWhereInput[]
    NOT?: AcademicTermWhereInput | AcademicTermWhereInput[]
    id?: StringFilter<"AcademicTerm"> | string
    year?: IntFilter<"AcademicTerm"> | number
    semester?: IntFilter<"AcademicTerm"> | number
    startDate?: DateTimeFilter<"AcademicTerm"> | Date | string
    endDate?: DateTimeFilter<"AcademicTerm"> | Date | string
    isCurrent?: BoolFilter<"AcademicTerm"> | boolean
    sections?: ClassSectionListRelationFilter
    invoices?: InvoiceListRelationFilter
    examSchedules?: ExamScheduleListRelationFilter
    teachingLoads?: TeachingLoadListRelationFilter
    schedules?: ClassScheduleListRelationFilter
  }

  export type AcademicTermOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    sections?: ClassSectionOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    examSchedules?: ExamScheduleOrderByRelationAggregateInput
    teachingLoads?: TeachingLoadOrderByRelationAggregateInput
    schedules?: ClassScheduleOrderByRelationAggregateInput
  }

  export type AcademicTermWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    year_semester?: AcademicTermYearSemesterCompoundUniqueInput
    AND?: AcademicTermWhereInput | AcademicTermWhereInput[]
    OR?: AcademicTermWhereInput[]
    NOT?: AcademicTermWhereInput | AcademicTermWhereInput[]
    year?: IntFilter<"AcademicTerm"> | number
    semester?: IntFilter<"AcademicTerm"> | number
    startDate?: DateTimeFilter<"AcademicTerm"> | Date | string
    endDate?: DateTimeFilter<"AcademicTerm"> | Date | string
    isCurrent?: BoolFilter<"AcademicTerm"> | boolean
    sections?: ClassSectionListRelationFilter
    invoices?: InvoiceListRelationFilter
    examSchedules?: ExamScheduleListRelationFilter
    teachingLoads?: TeachingLoadListRelationFilter
    schedules?: ClassScheduleListRelationFilter
  }, "id" | "year_semester">

  export type AcademicTermOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    _count?: AcademicTermCountOrderByAggregateInput
    _avg?: AcademicTermAvgOrderByAggregateInput
    _max?: AcademicTermMaxOrderByAggregateInput
    _min?: AcademicTermMinOrderByAggregateInput
    _sum?: AcademicTermSumOrderByAggregateInput
  }

  export type AcademicTermScalarWhereWithAggregatesInput = {
    AND?: AcademicTermScalarWhereWithAggregatesInput | AcademicTermScalarWhereWithAggregatesInput[]
    OR?: AcademicTermScalarWhereWithAggregatesInput[]
    NOT?: AcademicTermScalarWhereWithAggregatesInput | AcademicTermScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicTerm"> | string
    year?: IntWithAggregatesFilter<"AcademicTerm"> | number
    semester?: IntWithAggregatesFilter<"AcademicTerm"> | number
    startDate?: DateTimeWithAggregatesFilter<"AcademicTerm"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicTerm"> | Date | string
    isCurrent?: BoolWithAggregatesFilter<"AcademicTerm"> | boolean
  }

  export type ApplicantWhereInput = {
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    id?: StringFilter<"Applicant"> | string
    userId?: StringFilter<"Applicant"> | string
    firstName?: StringFilter<"Applicant"> | string
    lastName?: StringFilter<"Applicant"> | string
    firstNameTh?: StringNullableFilter<"Applicant"> | string | null
    lastNameTh?: StringNullableFilter<"Applicant"> | string | null
    nationality?: StringNullableFilter<"Applicant"> | string | null
    title?: StringNullableFilter<"Applicant"> | string | null
    citizenId?: StringNullableFilter<"Applicant"> | string | null
    birthDate?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Applicant"> | $Enums.Gender | null
    phone?: StringNullableFilter<"Applicant"> | string | null
    address?: StringNullableFilter<"Applicant"> | string | null
    subDistrict?: StringNullableFilter<"Applicant"> | string | null
    district?: StringNullableFilter<"Applicant"> | string | null
    province?: StringNullableFilter<"Applicant"> | string | null
    zipCode?: StringNullableFilter<"Applicant"> | string | null
    profileImageUrl?: StringNullableFilter<"Applicant"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    educationHistory?: EducationHistoryListRelationFilter
    applications?: ApplicationListRelationFilter
  }

  export type ApplicantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrderInput | SortOrder
    lastNameTh?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    citizenId?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    educationHistory?: EducationHistoryOrderByRelationAggregateInput
    applications?: ApplicationOrderByRelationAggregateInput
  }

  export type ApplicantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    citizenId?: string
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    firstName?: StringFilter<"Applicant"> | string
    lastName?: StringFilter<"Applicant"> | string
    firstNameTh?: StringNullableFilter<"Applicant"> | string | null
    lastNameTh?: StringNullableFilter<"Applicant"> | string | null
    nationality?: StringNullableFilter<"Applicant"> | string | null
    title?: StringNullableFilter<"Applicant"> | string | null
    birthDate?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Applicant"> | $Enums.Gender | null
    phone?: StringNullableFilter<"Applicant"> | string | null
    address?: StringNullableFilter<"Applicant"> | string | null
    subDistrict?: StringNullableFilter<"Applicant"> | string | null
    district?: StringNullableFilter<"Applicant"> | string | null
    province?: StringNullableFilter<"Applicant"> | string | null
    zipCode?: StringNullableFilter<"Applicant"> | string | null
    profileImageUrl?: StringNullableFilter<"Applicant"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    educationHistory?: EducationHistoryListRelationFilter
    applications?: ApplicationListRelationFilter
  }, "id" | "userId" | "citizenId">

  export type ApplicantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrderInput | SortOrder
    lastNameTh?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    citizenId?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    _count?: ApplicantCountOrderByAggregateInput
    _max?: ApplicantMaxOrderByAggregateInput
    _min?: ApplicantMinOrderByAggregateInput
  }

  export type ApplicantScalarWhereWithAggregatesInput = {
    AND?: ApplicantScalarWhereWithAggregatesInput | ApplicantScalarWhereWithAggregatesInput[]
    OR?: ApplicantScalarWhereWithAggregatesInput[]
    NOT?: ApplicantScalarWhereWithAggregatesInput | ApplicantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Applicant"> | string
    userId?: StringWithAggregatesFilter<"Applicant"> | string
    firstName?: StringWithAggregatesFilter<"Applicant"> | string
    lastName?: StringWithAggregatesFilter<"Applicant"> | string
    firstNameTh?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    lastNameTh?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    title?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    citizenId?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Applicant"> | Date | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"Applicant"> | $Enums.Gender | null
    phone?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    address?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    subDistrict?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    district?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    province?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
  }

  export type EducationHistoryWhereInput = {
    AND?: EducationHistoryWhereInput | EducationHistoryWhereInput[]
    OR?: EducationHistoryWhereInput[]
    NOT?: EducationHistoryWhereInput | EducationHistoryWhereInput[]
    id?: StringFilter<"EducationHistory"> | string
    applicantId?: StringFilter<"EducationHistory"> | string
    level?: StringFilter<"EducationHistory"> | string
    degreeName?: StringFilter<"EducationHistory"> | string
    institution?: StringFilter<"EducationHistory"> | string
    gpa?: StringNullableFilter<"EducationHistory"> | string | null
    graduationYear?: IntNullableFilter<"EducationHistory"> | number | null
    applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput>
  }

  export type EducationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    applicantId?: SortOrder
    level?: SortOrder
    degreeName?: SortOrder
    institution?: SortOrder
    gpa?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    applicant?: ApplicantOrderByWithRelationInput
  }

  export type EducationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EducationHistoryWhereInput | EducationHistoryWhereInput[]
    OR?: EducationHistoryWhereInput[]
    NOT?: EducationHistoryWhereInput | EducationHistoryWhereInput[]
    applicantId?: StringFilter<"EducationHistory"> | string
    level?: StringFilter<"EducationHistory"> | string
    degreeName?: StringFilter<"EducationHistory"> | string
    institution?: StringFilter<"EducationHistory"> | string
    gpa?: StringNullableFilter<"EducationHistory"> | string | null
    graduationYear?: IntNullableFilter<"EducationHistory"> | number | null
    applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput>
  }, "id">

  export type EducationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    applicantId?: SortOrder
    level?: SortOrder
    degreeName?: SortOrder
    institution?: SortOrder
    gpa?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    _count?: EducationHistoryCountOrderByAggregateInput
    _avg?: EducationHistoryAvgOrderByAggregateInput
    _max?: EducationHistoryMaxOrderByAggregateInput
    _min?: EducationHistoryMinOrderByAggregateInput
    _sum?: EducationHistorySumOrderByAggregateInput
  }

  export type EducationHistoryScalarWhereWithAggregatesInput = {
    AND?: EducationHistoryScalarWhereWithAggregatesInput | EducationHistoryScalarWhereWithAggregatesInput[]
    OR?: EducationHistoryScalarWhereWithAggregatesInput[]
    NOT?: EducationHistoryScalarWhereWithAggregatesInput | EducationHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EducationHistory"> | string
    applicantId?: StringWithAggregatesFilter<"EducationHistory"> | string
    level?: StringWithAggregatesFilter<"EducationHistory"> | string
    degreeName?: StringWithAggregatesFilter<"EducationHistory"> | string
    institution?: StringWithAggregatesFilter<"EducationHistory"> | string
    gpa?: StringNullableWithAggregatesFilter<"EducationHistory"> | string | null
    graduationYear?: IntNullableWithAggregatesFilter<"EducationHistory"> | number | null
  }

  export type AdmissionTrackTypeWhereInput = {
    AND?: AdmissionTrackTypeWhereInput | AdmissionTrackTypeWhereInput[]
    OR?: AdmissionTrackTypeWhereInput[]
    NOT?: AdmissionTrackTypeWhereInput | AdmissionTrackTypeWhereInput[]
    id?: StringFilter<"AdmissionTrackType"> | string
    code?: StringFilter<"AdmissionTrackType"> | string
    nameTh?: StringFilter<"AdmissionTrackType"> | string
    nameEn?: StringFilter<"AdmissionTrackType"> | string
    description?: StringNullableFilter<"AdmissionTrackType"> | string | null
    color?: StringFilter<"AdmissionTrackType"> | string
    icon?: StringFilter<"AdmissionTrackType"> | string
    displayOrder?: IntFilter<"AdmissionTrackType"> | number
    isActive?: BoolFilter<"AdmissionTrackType"> | boolean
    isSystem?: BoolFilter<"AdmissionTrackType"> | boolean
    createdAt?: DateTimeFilter<"AdmissionTrackType"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionTrackType"> | Date | string
    tracks?: AdmissionTrackListRelationFilter
  }

  export type AdmissionTrackTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tracks?: AdmissionTrackOrderByRelationAggregateInput
  }

  export type AdmissionTrackTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AdmissionTrackTypeWhereInput | AdmissionTrackTypeWhereInput[]
    OR?: AdmissionTrackTypeWhereInput[]
    NOT?: AdmissionTrackTypeWhereInput | AdmissionTrackTypeWhereInput[]
    nameTh?: StringFilter<"AdmissionTrackType"> | string
    nameEn?: StringFilter<"AdmissionTrackType"> | string
    description?: StringNullableFilter<"AdmissionTrackType"> | string | null
    color?: StringFilter<"AdmissionTrackType"> | string
    icon?: StringFilter<"AdmissionTrackType"> | string
    displayOrder?: IntFilter<"AdmissionTrackType"> | number
    isActive?: BoolFilter<"AdmissionTrackType"> | boolean
    isSystem?: BoolFilter<"AdmissionTrackType"> | boolean
    createdAt?: DateTimeFilter<"AdmissionTrackType"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionTrackType"> | Date | string
    tracks?: AdmissionTrackListRelationFilter
  }, "id" | "code">

  export type AdmissionTrackTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionTrackTypeCountOrderByAggregateInput
    _avg?: AdmissionTrackTypeAvgOrderByAggregateInput
    _max?: AdmissionTrackTypeMaxOrderByAggregateInput
    _min?: AdmissionTrackTypeMinOrderByAggregateInput
    _sum?: AdmissionTrackTypeSumOrderByAggregateInput
  }

  export type AdmissionTrackTypeScalarWhereWithAggregatesInput = {
    AND?: AdmissionTrackTypeScalarWhereWithAggregatesInput | AdmissionTrackTypeScalarWhereWithAggregatesInput[]
    OR?: AdmissionTrackTypeScalarWhereWithAggregatesInput[]
    NOT?: AdmissionTrackTypeScalarWhereWithAggregatesInput | AdmissionTrackTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmissionTrackType"> | string
    code?: StringWithAggregatesFilter<"AdmissionTrackType"> | string
    nameTh?: StringWithAggregatesFilter<"AdmissionTrackType"> | string
    nameEn?: StringWithAggregatesFilter<"AdmissionTrackType"> | string
    description?: StringNullableWithAggregatesFilter<"AdmissionTrackType"> | string | null
    color?: StringWithAggregatesFilter<"AdmissionTrackType"> | string
    icon?: StringWithAggregatesFilter<"AdmissionTrackType"> | string
    displayOrder?: IntWithAggregatesFilter<"AdmissionTrackType"> | number
    isActive?: BoolWithAggregatesFilter<"AdmissionTrackType"> | boolean
    isSystem?: BoolWithAggregatesFilter<"AdmissionTrackType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdmissionTrackType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdmissionTrackType"> | Date | string
  }

  export type AdmissionTrackWhereInput = {
    AND?: AdmissionTrackWhereInput | AdmissionTrackWhereInput[]
    OR?: AdmissionTrackWhereInput[]
    NOT?: AdmissionTrackWhereInput | AdmissionTrackWhereInput[]
    id?: StringFilter<"AdmissionTrack"> | string
    code?: StringFilter<"AdmissionTrack"> | string
    nameTh?: StringFilter<"AdmissionTrack"> | string
    nameEn?: StringFilter<"AdmissionTrack"> | string
    description?: StringNullableFilter<"AdmissionTrack"> | string | null
    typeId?: StringFilter<"AdmissionTrack"> | string
    programId?: StringFilter<"AdmissionTrack"> | string
    academicYear?: StringFilter<"AdmissionTrack"> | string
    openDate?: DateTimeFilter<"AdmissionTrack"> | Date | string
    closeDate?: DateTimeFilter<"AdmissionTrack"> | Date | string
    announceDate?: DateTimeNullableFilter<"AdmissionTrack"> | Date | string | null
    totalSeats?: IntFilter<"AdmissionTrack"> | number
    filledSeats?: IntFilter<"AdmissionTrack"> | number
    reservedSeats?: IntNullableFilter<"AdmissionTrack"> | number | null
    enableWaitlist?: BoolFilter<"AdmissionTrack"> | boolean
    requirements?: StringNullableFilter<"AdmissionTrack"> | string | null
    applicationFee?: FloatNullableFilter<"AdmissionTrack"> | number | null
    isActive?: BoolFilter<"AdmissionTrack"> | boolean
    isPublished?: BoolFilter<"AdmissionTrack"> | boolean
    displayOrder?: IntFilter<"AdmissionTrack"> | number
    createdAt?: DateTimeFilter<"AdmissionTrack"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionTrack"> | Date | string
    type?: XOR<AdmissionTrackTypeRelationFilter, AdmissionTrackTypeWhereInput>
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    applications?: ApplicationListRelationFilter
  }

  export type AdmissionTrackOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    typeId?: SortOrder
    programId?: SortOrder
    academicYear?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    announceDate?: SortOrderInput | SortOrder
    totalSeats?: SortOrder
    filledSeats?: SortOrder
    reservedSeats?: SortOrderInput | SortOrder
    enableWaitlist?: SortOrder
    requirements?: SortOrderInput | SortOrder
    applicationFee?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: AdmissionTrackTypeOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    applications?: ApplicationOrderByRelationAggregateInput
  }

  export type AdmissionTrackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AdmissionTrackWhereInput | AdmissionTrackWhereInput[]
    OR?: AdmissionTrackWhereInput[]
    NOT?: AdmissionTrackWhereInput | AdmissionTrackWhereInput[]
    nameTh?: StringFilter<"AdmissionTrack"> | string
    nameEn?: StringFilter<"AdmissionTrack"> | string
    description?: StringNullableFilter<"AdmissionTrack"> | string | null
    typeId?: StringFilter<"AdmissionTrack"> | string
    programId?: StringFilter<"AdmissionTrack"> | string
    academicYear?: StringFilter<"AdmissionTrack"> | string
    openDate?: DateTimeFilter<"AdmissionTrack"> | Date | string
    closeDate?: DateTimeFilter<"AdmissionTrack"> | Date | string
    announceDate?: DateTimeNullableFilter<"AdmissionTrack"> | Date | string | null
    totalSeats?: IntFilter<"AdmissionTrack"> | number
    filledSeats?: IntFilter<"AdmissionTrack"> | number
    reservedSeats?: IntNullableFilter<"AdmissionTrack"> | number | null
    enableWaitlist?: BoolFilter<"AdmissionTrack"> | boolean
    requirements?: StringNullableFilter<"AdmissionTrack"> | string | null
    applicationFee?: FloatNullableFilter<"AdmissionTrack"> | number | null
    isActive?: BoolFilter<"AdmissionTrack"> | boolean
    isPublished?: BoolFilter<"AdmissionTrack"> | boolean
    displayOrder?: IntFilter<"AdmissionTrack"> | number
    createdAt?: DateTimeFilter<"AdmissionTrack"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionTrack"> | Date | string
    type?: XOR<AdmissionTrackTypeRelationFilter, AdmissionTrackTypeWhereInput>
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    applications?: ApplicationListRelationFilter
  }, "id" | "code">

  export type AdmissionTrackOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrderInput | SortOrder
    typeId?: SortOrder
    programId?: SortOrder
    academicYear?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    announceDate?: SortOrderInput | SortOrder
    totalSeats?: SortOrder
    filledSeats?: SortOrder
    reservedSeats?: SortOrderInput | SortOrder
    enableWaitlist?: SortOrder
    requirements?: SortOrderInput | SortOrder
    applicationFee?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionTrackCountOrderByAggregateInput
    _avg?: AdmissionTrackAvgOrderByAggregateInput
    _max?: AdmissionTrackMaxOrderByAggregateInput
    _min?: AdmissionTrackMinOrderByAggregateInput
    _sum?: AdmissionTrackSumOrderByAggregateInput
  }

  export type AdmissionTrackScalarWhereWithAggregatesInput = {
    AND?: AdmissionTrackScalarWhereWithAggregatesInput | AdmissionTrackScalarWhereWithAggregatesInput[]
    OR?: AdmissionTrackScalarWhereWithAggregatesInput[]
    NOT?: AdmissionTrackScalarWhereWithAggregatesInput | AdmissionTrackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmissionTrack"> | string
    code?: StringWithAggregatesFilter<"AdmissionTrack"> | string
    nameTh?: StringWithAggregatesFilter<"AdmissionTrack"> | string
    nameEn?: StringWithAggregatesFilter<"AdmissionTrack"> | string
    description?: StringNullableWithAggregatesFilter<"AdmissionTrack"> | string | null
    typeId?: StringWithAggregatesFilter<"AdmissionTrack"> | string
    programId?: StringWithAggregatesFilter<"AdmissionTrack"> | string
    academicYear?: StringWithAggregatesFilter<"AdmissionTrack"> | string
    openDate?: DateTimeWithAggregatesFilter<"AdmissionTrack"> | Date | string
    closeDate?: DateTimeWithAggregatesFilter<"AdmissionTrack"> | Date | string
    announceDate?: DateTimeNullableWithAggregatesFilter<"AdmissionTrack"> | Date | string | null
    totalSeats?: IntWithAggregatesFilter<"AdmissionTrack"> | number
    filledSeats?: IntWithAggregatesFilter<"AdmissionTrack"> | number
    reservedSeats?: IntNullableWithAggregatesFilter<"AdmissionTrack"> | number | null
    enableWaitlist?: BoolWithAggregatesFilter<"AdmissionTrack"> | boolean
    requirements?: StringNullableWithAggregatesFilter<"AdmissionTrack"> | string | null
    applicationFee?: FloatNullableWithAggregatesFilter<"AdmissionTrack"> | number | null
    isActive?: BoolWithAggregatesFilter<"AdmissionTrack"> | boolean
    isPublished?: BoolWithAggregatesFilter<"AdmissionTrack"> | boolean
    displayOrder?: IntWithAggregatesFilter<"AdmissionTrack"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AdmissionTrack"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdmissionTrack"> | Date | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: StringFilter<"Application"> | string
    applicantId?: StringFilter<"Application"> | string
    trackId?: StringNullableFilter<"Application"> | string | null
    programId?: StringFilter<"Application"> | string
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    submittedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput>
    track?: XOR<AdmissionTrackNullableRelationFilter, AdmissionTrackWhereInput> | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    documents?: DocumentListRelationFilter
    interview?: XOR<InterviewResultNullableRelationFilter, InterviewResultWhereInput> | null
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    applicantId?: SortOrder
    trackId?: SortOrderInput | SortOrder
    programId?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicant?: ApplicantOrderByWithRelationInput
    track?: AdmissionTrackOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    interview?: InterviewResultOrderByWithRelationInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    applicantId?: StringFilter<"Application"> | string
    trackId?: StringNullableFilter<"Application"> | string | null
    programId?: StringFilter<"Application"> | string
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    submittedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput>
    track?: XOR<AdmissionTrackNullableRelationFilter, AdmissionTrackWhereInput> | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    documents?: DocumentListRelationFilter
    interview?: XOR<InterviewResultNullableRelationFilter, InterviewResultWhereInput> | null
  }, "id">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    applicantId?: SortOrder
    trackId?: SortOrderInput | SortOrder
    programId?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Application"> | string
    applicantId?: StringWithAggregatesFilter<"Application"> | string
    trackId?: StringNullableWithAggregatesFilter<"Application"> | string | null
    programId?: StringWithAggregatesFilter<"Application"> | string
    status?: EnumApplicationStatusWithAggregatesFilter<"Application"> | $Enums.ApplicationStatus
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    applicationId?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
    application?: ApplicationOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    applicationId?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    applicationId?: StringWithAggregatesFilter<"Document"> | string
    type?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type InterviewSlotWhereInput = {
    AND?: InterviewSlotWhereInput | InterviewSlotWhereInput[]
    OR?: InterviewSlotWhereInput[]
    NOT?: InterviewSlotWhereInput | InterviewSlotWhereInput[]
    id?: StringFilter<"InterviewSlot"> | string
    startTime?: DateTimeFilter<"InterviewSlot"> | Date | string
    endTime?: DateTimeFilter<"InterviewSlot"> | Date | string
    location?: StringNullableFilter<"InterviewSlot"> | string | null
    coordinatorName?: StringNullableFilter<"InterviewSlot"> | string | null
    coordinatorPhone?: StringNullableFilter<"InterviewSlot"> | string | null
    description?: StringNullableFilter<"InterviewSlot"> | string | null
    programId?: StringNullableFilter<"InterviewSlot"> | string | null
    program?: XOR<ProgramNullableRelationFilter, ProgramWhereInput> | null
    interviewResults?: InterviewResultListRelationFilter
    interviewers?: InterviewSlotInterviewerListRelationFilter
  }

  export type InterviewSlotOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    coordinatorName?: SortOrderInput | SortOrder
    coordinatorPhone?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    interviewResults?: InterviewResultOrderByRelationAggregateInput
    interviewers?: InterviewSlotInterviewerOrderByRelationAggregateInput
  }

  export type InterviewSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterviewSlotWhereInput | InterviewSlotWhereInput[]
    OR?: InterviewSlotWhereInput[]
    NOT?: InterviewSlotWhereInput | InterviewSlotWhereInput[]
    startTime?: DateTimeFilter<"InterviewSlot"> | Date | string
    endTime?: DateTimeFilter<"InterviewSlot"> | Date | string
    location?: StringNullableFilter<"InterviewSlot"> | string | null
    coordinatorName?: StringNullableFilter<"InterviewSlot"> | string | null
    coordinatorPhone?: StringNullableFilter<"InterviewSlot"> | string | null
    description?: StringNullableFilter<"InterviewSlot"> | string | null
    programId?: StringNullableFilter<"InterviewSlot"> | string | null
    program?: XOR<ProgramNullableRelationFilter, ProgramWhereInput> | null
    interviewResults?: InterviewResultListRelationFilter
    interviewers?: InterviewSlotInterviewerListRelationFilter
  }, "id">

  export type InterviewSlotOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    coordinatorName?: SortOrderInput | SortOrder
    coordinatorPhone?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    _count?: InterviewSlotCountOrderByAggregateInput
    _max?: InterviewSlotMaxOrderByAggregateInput
    _min?: InterviewSlotMinOrderByAggregateInput
  }

  export type InterviewSlotScalarWhereWithAggregatesInput = {
    AND?: InterviewSlotScalarWhereWithAggregatesInput | InterviewSlotScalarWhereWithAggregatesInput[]
    OR?: InterviewSlotScalarWhereWithAggregatesInput[]
    NOT?: InterviewSlotScalarWhereWithAggregatesInput | InterviewSlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewSlot"> | string
    startTime?: DateTimeWithAggregatesFilter<"InterviewSlot"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"InterviewSlot"> | Date | string
    location?: StringNullableWithAggregatesFilter<"InterviewSlot"> | string | null
    coordinatorName?: StringNullableWithAggregatesFilter<"InterviewSlot"> | string | null
    coordinatorPhone?: StringNullableWithAggregatesFilter<"InterviewSlot"> | string | null
    description?: StringNullableWithAggregatesFilter<"InterviewSlot"> | string | null
    programId?: StringNullableWithAggregatesFilter<"InterviewSlot"> | string | null
  }

  export type InterviewSlotInterviewerWhereInput = {
    AND?: InterviewSlotInterviewerWhereInput | InterviewSlotInterviewerWhereInput[]
    OR?: InterviewSlotInterviewerWhereInput[]
    NOT?: InterviewSlotInterviewerWhereInput | InterviewSlotInterviewerWhereInput[]
    id?: StringFilter<"InterviewSlotInterviewer"> | string
    slotId?: StringFilter<"InterviewSlotInterviewer"> | string
    interviewerId?: StringFilter<"InterviewSlotInterviewer"> | string
    slot?: XOR<InterviewSlotRelationFilter, InterviewSlotWhereInput>
    interviewer?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type InterviewSlotInterviewerOrderByWithRelationInput = {
    id?: SortOrder
    slotId?: SortOrder
    interviewerId?: SortOrder
    slot?: InterviewSlotOrderByWithRelationInput
    interviewer?: PersonnelOrderByWithRelationInput
  }

  export type InterviewSlotInterviewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slotId_interviewerId?: InterviewSlotInterviewerSlotIdInterviewerIdCompoundUniqueInput
    AND?: InterviewSlotInterviewerWhereInput | InterviewSlotInterviewerWhereInput[]
    OR?: InterviewSlotInterviewerWhereInput[]
    NOT?: InterviewSlotInterviewerWhereInput | InterviewSlotInterviewerWhereInput[]
    slotId?: StringFilter<"InterviewSlotInterviewer"> | string
    interviewerId?: StringFilter<"InterviewSlotInterviewer"> | string
    slot?: XOR<InterviewSlotRelationFilter, InterviewSlotWhereInput>
    interviewer?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "id" | "slotId_interviewerId">

  export type InterviewSlotInterviewerOrderByWithAggregationInput = {
    id?: SortOrder
    slotId?: SortOrder
    interviewerId?: SortOrder
    _count?: InterviewSlotInterviewerCountOrderByAggregateInput
    _max?: InterviewSlotInterviewerMaxOrderByAggregateInput
    _min?: InterviewSlotInterviewerMinOrderByAggregateInput
  }

  export type InterviewSlotInterviewerScalarWhereWithAggregatesInput = {
    AND?: InterviewSlotInterviewerScalarWhereWithAggregatesInput | InterviewSlotInterviewerScalarWhereWithAggregatesInput[]
    OR?: InterviewSlotInterviewerScalarWhereWithAggregatesInput[]
    NOT?: InterviewSlotInterviewerScalarWhereWithAggregatesInput | InterviewSlotInterviewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewSlotInterviewer"> | string
    slotId?: StringWithAggregatesFilter<"InterviewSlotInterviewer"> | string
    interviewerId?: StringWithAggregatesFilter<"InterviewSlotInterviewer"> | string
  }

  export type InterviewResultWhereInput = {
    AND?: InterviewResultWhereInput | InterviewResultWhereInput[]
    OR?: InterviewResultWhereInput[]
    NOT?: InterviewResultWhereInput | InterviewResultWhereInput[]
    id?: StringFilter<"InterviewResult"> | string
    applicationId?: StringFilter<"InterviewResult"> | string
    slotId?: StringFilter<"InterviewResult"> | string
    score?: IntNullableFilter<"InterviewResult"> | number | null
    comments?: StringNullableFilter<"InterviewResult"> | string | null
    isPassed?: BoolNullableFilter<"InterviewResult"> | boolean | null
    confirmedAt?: DateTimeNullableFilter<"InterviewResult"> | Date | string | null
    rescheduleRequested?: BoolFilter<"InterviewResult"> | boolean
    rescheduleReason?: StringNullableFilter<"InterviewResult"> | string | null
    checkedInAt?: DateTimeNullableFilter<"InterviewResult"> | Date | string | null
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
    slot?: XOR<InterviewSlotRelationFilter, InterviewSlotWhereInput>
    feedback?: XOR<InterviewFeedbackNullableRelationFilter, InterviewFeedbackWhereInput> | null
  }

  export type InterviewResultOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    slotId?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    isPassed?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    rescheduleRequested?: SortOrder
    rescheduleReason?: SortOrderInput | SortOrder
    checkedInAt?: SortOrderInput | SortOrder
    application?: ApplicationOrderByWithRelationInput
    slot?: InterviewSlotOrderByWithRelationInput
    feedback?: InterviewFeedbackOrderByWithRelationInput
  }

  export type InterviewResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicationId?: string
    AND?: InterviewResultWhereInput | InterviewResultWhereInput[]
    OR?: InterviewResultWhereInput[]
    NOT?: InterviewResultWhereInput | InterviewResultWhereInput[]
    slotId?: StringFilter<"InterviewResult"> | string
    score?: IntNullableFilter<"InterviewResult"> | number | null
    comments?: StringNullableFilter<"InterviewResult"> | string | null
    isPassed?: BoolNullableFilter<"InterviewResult"> | boolean | null
    confirmedAt?: DateTimeNullableFilter<"InterviewResult"> | Date | string | null
    rescheduleRequested?: BoolFilter<"InterviewResult"> | boolean
    rescheduleReason?: StringNullableFilter<"InterviewResult"> | string | null
    checkedInAt?: DateTimeNullableFilter<"InterviewResult"> | Date | string | null
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
    slot?: XOR<InterviewSlotRelationFilter, InterviewSlotWhereInput>
    feedback?: XOR<InterviewFeedbackNullableRelationFilter, InterviewFeedbackWhereInput> | null
  }, "id" | "applicationId">

  export type InterviewResultOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    slotId?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    isPassed?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    rescheduleRequested?: SortOrder
    rescheduleReason?: SortOrderInput | SortOrder
    checkedInAt?: SortOrderInput | SortOrder
    _count?: InterviewResultCountOrderByAggregateInput
    _avg?: InterviewResultAvgOrderByAggregateInput
    _max?: InterviewResultMaxOrderByAggregateInput
    _min?: InterviewResultMinOrderByAggregateInput
    _sum?: InterviewResultSumOrderByAggregateInput
  }

  export type InterviewResultScalarWhereWithAggregatesInput = {
    AND?: InterviewResultScalarWhereWithAggregatesInput | InterviewResultScalarWhereWithAggregatesInput[]
    OR?: InterviewResultScalarWhereWithAggregatesInput[]
    NOT?: InterviewResultScalarWhereWithAggregatesInput | InterviewResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewResult"> | string
    applicationId?: StringWithAggregatesFilter<"InterviewResult"> | string
    slotId?: StringWithAggregatesFilter<"InterviewResult"> | string
    score?: IntNullableWithAggregatesFilter<"InterviewResult"> | number | null
    comments?: StringNullableWithAggregatesFilter<"InterviewResult"> | string | null
    isPassed?: BoolNullableWithAggregatesFilter<"InterviewResult"> | boolean | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"InterviewResult"> | Date | string | null
    rescheduleRequested?: BoolWithAggregatesFilter<"InterviewResult"> | boolean
    rescheduleReason?: StringNullableWithAggregatesFilter<"InterviewResult"> | string | null
    checkedInAt?: DateTimeNullableWithAggregatesFilter<"InterviewResult"> | Date | string | null
  }

  export type InterviewFeedbackWhereInput = {
    AND?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    OR?: InterviewFeedbackWhereInput[]
    NOT?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    id?: StringFilter<"InterviewFeedback"> | string
    interviewResultId?: StringFilter<"InterviewFeedback"> | string
    rating?: IntFilter<"InterviewFeedback"> | number
    comment?: StringNullableFilter<"InterviewFeedback"> | string | null
    createdAt?: DateTimeFilter<"InterviewFeedback"> | Date | string
    interviewResult?: XOR<InterviewResultRelationFilter, InterviewResultWhereInput>
  }

  export type InterviewFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    interviewResultId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    interviewResult?: InterviewResultOrderByWithRelationInput
  }

  export type InterviewFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    interviewResultId?: string
    AND?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    OR?: InterviewFeedbackWhereInput[]
    NOT?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    rating?: IntFilter<"InterviewFeedback"> | number
    comment?: StringNullableFilter<"InterviewFeedback"> | string | null
    createdAt?: DateTimeFilter<"InterviewFeedback"> | Date | string
    interviewResult?: XOR<InterviewResultRelationFilter, InterviewResultWhereInput>
  }, "id" | "interviewResultId">

  export type InterviewFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    interviewResultId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InterviewFeedbackCountOrderByAggregateInput
    _avg?: InterviewFeedbackAvgOrderByAggregateInput
    _max?: InterviewFeedbackMaxOrderByAggregateInput
    _min?: InterviewFeedbackMinOrderByAggregateInput
    _sum?: InterviewFeedbackSumOrderByAggregateInput
  }

  export type InterviewFeedbackScalarWhereWithAggregatesInput = {
    AND?: InterviewFeedbackScalarWhereWithAggregatesInput | InterviewFeedbackScalarWhereWithAggregatesInput[]
    OR?: InterviewFeedbackScalarWhereWithAggregatesInput[]
    NOT?: InterviewFeedbackScalarWhereWithAggregatesInput | InterviewFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewFeedback"> | string
    interviewResultId?: StringWithAggregatesFilter<"InterviewFeedback"> | string
    rating?: IntWithAggregatesFilter<"InterviewFeedback"> | number
    comment?: StringNullableWithAggregatesFilter<"InterviewFeedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InterviewFeedback"> | Date | string
  }

  export type StudentGroupWhereInput = {
    AND?: StudentGroupWhereInput | StudentGroupWhereInput[]
    OR?: StudentGroupWhereInput[]
    NOT?: StudentGroupWhereInput | StudentGroupWhereInput[]
    id?: StringFilter<"StudentGroup"> | string
    name?: StringFilter<"StudentGroup"> | string
    admissionYear?: IntFilter<"StudentGroup"> | number
    programId?: StringFilter<"StudentGroup"> | string
    advisorId?: StringNullableFilter<"StudentGroup"> | string | null
    createdAt?: DateTimeFilter<"StudentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"StudentGroup"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    advisor?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    students?: StudentListRelationFilter
    sections?: ClassSectionListRelationFilter
  }

  export type StudentGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    admissionYear?: SortOrder
    programId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: ProgramOrderByWithRelationInput
    advisor?: PersonnelOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    sections?: ClassSectionOrderByRelationAggregateInput
  }

  export type StudentGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    programId_admissionYear_name?: StudentGroupProgramIdAdmissionYearNameCompoundUniqueInput
    AND?: StudentGroupWhereInput | StudentGroupWhereInput[]
    OR?: StudentGroupWhereInput[]
    NOT?: StudentGroupWhereInput | StudentGroupWhereInput[]
    name?: StringFilter<"StudentGroup"> | string
    admissionYear?: IntFilter<"StudentGroup"> | number
    programId?: StringFilter<"StudentGroup"> | string
    advisorId?: StringNullableFilter<"StudentGroup"> | string | null
    createdAt?: DateTimeFilter<"StudentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"StudentGroup"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    advisor?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    students?: StudentListRelationFilter
    sections?: ClassSectionListRelationFilter
  }, "id" | "programId_admissionYear_name">

  export type StudentGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    admissionYear?: SortOrder
    programId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentGroupCountOrderByAggregateInput
    _avg?: StudentGroupAvgOrderByAggregateInput
    _max?: StudentGroupMaxOrderByAggregateInput
    _min?: StudentGroupMinOrderByAggregateInput
    _sum?: StudentGroupSumOrderByAggregateInput
  }

  export type StudentGroupScalarWhereWithAggregatesInput = {
    AND?: StudentGroupScalarWhereWithAggregatesInput | StudentGroupScalarWhereWithAggregatesInput[]
    OR?: StudentGroupScalarWhereWithAggregatesInput[]
    NOT?: StudentGroupScalarWhereWithAggregatesInput | StudentGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentGroup"> | string
    name?: StringWithAggregatesFilter<"StudentGroup"> | string
    admissionYear?: IntWithAggregatesFilter<"StudentGroup"> | number
    programId?: StringWithAggregatesFilter<"StudentGroup"> | string
    advisorId?: StringNullableWithAggregatesFilter<"StudentGroup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentGroup"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    title?: StringNullableFilter<"Student"> | string | null
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    firstNameTh?: StringNullableFilter<"Student"> | string | null
    lastNameTh?: StringNullableFilter<"Student"> | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    citizenId?: StringNullableFilter<"Student"> | string | null
    birthDate?: DateTimeFilter<"Student"> | Date | string
    gender?: EnumGenderNullableFilter<"Student"> | $Enums.Gender | null
    phone?: StringNullableFilter<"Student"> | string | null
    profileImageUrl?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    subDistrict?: StringNullableFilter<"Student"> | string | null
    district?: StringNullableFilter<"Student"> | string | null
    province?: StringNullableFilter<"Student"> | string | null
    zipCode?: StringNullableFilter<"Student"> | string | null
    programId?: StringFilter<"Student"> | string
    studentType?: EnumStudentTypeFilter<"Student"> | $Enums.StudentType
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    gpax?: FloatFilter<"Student"> | number
    bio?: StringNullableFilter<"Student"> | string | null
    interests?: StringNullableFilter<"Student"> | string | null
    skills?: StringNullableFilter<"Student"> | string | null
    socialLinks?: StringNullableFilter<"Student"> | string | null
    isProfilePublic?: BoolFilter<"Student"> | boolean
    showGPA?: BoolFilter<"Student"> | boolean
    admissionYear?: IntNullableFilter<"Student"> | number | null
    studentGroupId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    studentGroup?: XOR<StudentGroupNullableRelationFilter, StudentGroupWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrderInput | SortOrder
    lastNameTh?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    citizenId?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    programId?: SortOrder
    studentType?: SortOrder
    status?: SortOrder
    gpax?: SortOrder
    bio?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    isProfilePublic?: SortOrder
    showGPA?: SortOrder
    admissionYear?: SortOrderInput | SortOrder
    studentGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    studentGroup?: StudentGroupOrderByWithRelationInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    leaveRequests?: LeaveRequestOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    userId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    title?: StringNullableFilter<"Student"> | string | null
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    firstNameTh?: StringNullableFilter<"Student"> | string | null
    lastNameTh?: StringNullableFilter<"Student"> | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    citizenId?: StringNullableFilter<"Student"> | string | null
    birthDate?: DateTimeFilter<"Student"> | Date | string
    gender?: EnumGenderNullableFilter<"Student"> | $Enums.Gender | null
    phone?: StringNullableFilter<"Student"> | string | null
    profileImageUrl?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    subDistrict?: StringNullableFilter<"Student"> | string | null
    district?: StringNullableFilter<"Student"> | string | null
    province?: StringNullableFilter<"Student"> | string | null
    zipCode?: StringNullableFilter<"Student"> | string | null
    programId?: StringFilter<"Student"> | string
    studentType?: EnumStudentTypeFilter<"Student"> | $Enums.StudentType
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    gpax?: FloatFilter<"Student"> | number
    bio?: StringNullableFilter<"Student"> | string | null
    interests?: StringNullableFilter<"Student"> | string | null
    skills?: StringNullableFilter<"Student"> | string | null
    socialLinks?: StringNullableFilter<"Student"> | string | null
    isProfilePublic?: BoolFilter<"Student"> | boolean
    showGPA?: BoolFilter<"Student"> | boolean
    admissionYear?: IntNullableFilter<"Student"> | number | null
    studentGroupId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    studentGroup?: XOR<StudentGroupNullableRelationFilter, StudentGroupWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
  }, "id" | "studentId" | "userId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrderInput | SortOrder
    lastNameTh?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    citizenId?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    programId?: SortOrder
    studentType?: SortOrder
    status?: SortOrder
    gpax?: SortOrder
    bio?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    isProfilePublic?: SortOrder
    showGPA?: SortOrder
    admissionYear?: SortOrderInput | SortOrder
    studentGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    studentId?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    title?: StringNullableWithAggregatesFilter<"Student"> | string | null
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    firstNameTh?: StringNullableWithAggregatesFilter<"Student"> | string | null
    lastNameTh?: StringNullableWithAggregatesFilter<"Student"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Student"> | string | null
    citizenId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    gender?: EnumGenderNullableWithAggregatesFilter<"Student"> | $Enums.Gender | null
    phone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"Student"> | string | null
    address?: StringNullableWithAggregatesFilter<"Student"> | string | null
    subDistrict?: StringNullableWithAggregatesFilter<"Student"> | string | null
    district?: StringNullableWithAggregatesFilter<"Student"> | string | null
    province?: StringNullableWithAggregatesFilter<"Student"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Student"> | string | null
    programId?: StringWithAggregatesFilter<"Student"> | string
    studentType?: EnumStudentTypeWithAggregatesFilter<"Student"> | $Enums.StudentType
    status?: EnumStudentStatusWithAggregatesFilter<"Student"> | $Enums.StudentStatus
    gpax?: FloatWithAggregatesFilter<"Student"> | number
    bio?: StringNullableWithAggregatesFilter<"Student"> | string | null
    interests?: StringNullableWithAggregatesFilter<"Student"> | string | null
    skills?: StringNullableWithAggregatesFilter<"Student"> | string | null
    socialLinks?: StringNullableWithAggregatesFilter<"Student"> | string | null
    isProfilePublic?: BoolWithAggregatesFilter<"Student"> | boolean
    showGPA?: BoolWithAggregatesFilter<"Student"> | boolean
    admissionYear?: IntNullableWithAggregatesFilter<"Student"> | number | null
    studentGroupId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ClassSectionWhereInput = {
    AND?: ClassSectionWhereInput | ClassSectionWhereInput[]
    OR?: ClassSectionWhereInput[]
    NOT?: ClassSectionWhereInput | ClassSectionWhereInput[]
    id?: StringFilter<"ClassSection"> | string
    courseId?: StringFilter<"ClassSection"> | string
    termId?: StringFilter<"ClassSection"> | string
    sectionNumber?: StringFilter<"ClassSection"> | string
    capacity?: IntFilter<"ClassSection"> | number
    instructorId?: StringNullableFilter<"ClassSection"> | string | null
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
    instructor?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    schedules?: ClassScheduleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    studentGroups?: StudentGroupListRelationFilter
  }

  export type ClassSectionOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    termId?: SortOrder
    sectionNumber?: SortOrder
    capacity?: SortOrder
    instructorId?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    term?: AcademicTermOrderByWithRelationInput
    instructor?: PersonnelOrderByWithRelationInput
    schedules?: ClassScheduleOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    studentGroups?: StudentGroupOrderByRelationAggregateInput
  }

  export type ClassSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassSectionWhereInput | ClassSectionWhereInput[]
    OR?: ClassSectionWhereInput[]
    NOT?: ClassSectionWhereInput | ClassSectionWhereInput[]
    courseId?: StringFilter<"ClassSection"> | string
    termId?: StringFilter<"ClassSection"> | string
    sectionNumber?: StringFilter<"ClassSection"> | string
    capacity?: IntFilter<"ClassSection"> | number
    instructorId?: StringNullableFilter<"ClassSection"> | string | null
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
    instructor?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    schedules?: ClassScheduleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    studentGroups?: StudentGroupListRelationFilter
  }, "id">

  export type ClassSectionOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    termId?: SortOrder
    sectionNumber?: SortOrder
    capacity?: SortOrder
    instructorId?: SortOrderInput | SortOrder
    _count?: ClassSectionCountOrderByAggregateInput
    _avg?: ClassSectionAvgOrderByAggregateInput
    _max?: ClassSectionMaxOrderByAggregateInput
    _min?: ClassSectionMinOrderByAggregateInput
    _sum?: ClassSectionSumOrderByAggregateInput
  }

  export type ClassSectionScalarWhereWithAggregatesInput = {
    AND?: ClassSectionScalarWhereWithAggregatesInput | ClassSectionScalarWhereWithAggregatesInput[]
    OR?: ClassSectionScalarWhereWithAggregatesInput[]
    NOT?: ClassSectionScalarWhereWithAggregatesInput | ClassSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassSection"> | string
    courseId?: StringWithAggregatesFilter<"ClassSection"> | string
    termId?: StringWithAggregatesFilter<"ClassSection"> | string
    sectionNumber?: StringWithAggregatesFilter<"ClassSection"> | string
    capacity?: IntWithAggregatesFilter<"ClassSection"> | number
    instructorId?: StringNullableWithAggregatesFilter<"ClassSection"> | string | null
  }

  export type ClassScheduleWhereInput = {
    AND?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    OR?: ClassScheduleWhereInput[]
    NOT?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    id?: StringFilter<"ClassSchedule"> | string
    sectionId?: StringFilter<"ClassSchedule"> | string
    day?: EnumDayOfWeekFilter<"ClassSchedule"> | $Enums.DayOfWeek
    startTime?: StringFilter<"ClassSchedule"> | string
    endTime?: StringFilter<"ClassSchedule"> | string
    roomId?: StringNullableFilter<"ClassSchedule"> | string | null
    courseId?: StringNullableFilter<"ClassSchedule"> | string | null
    instructorId?: StringNullableFilter<"ClassSchedule"> | string | null
    termId?: StringNullableFilter<"ClassSchedule"> | string | null
    section?: XOR<ClassSectionRelationFilter, ClassSectionWhereInput>
    room?: XOR<RoomNullableRelationFilter, RoomWhereInput> | null
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    instructor?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    term?: XOR<AcademicTermNullableRelationFilter, AcademicTermWhereInput> | null
  }

  export type ClassScheduleOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    roomId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    instructorId?: SortOrderInput | SortOrder
    termId?: SortOrderInput | SortOrder
    section?: ClassSectionOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    instructor?: PersonnelOrderByWithRelationInput
    term?: AcademicTermOrderByWithRelationInput
  }

  export type ClassScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    OR?: ClassScheduleWhereInput[]
    NOT?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    sectionId?: StringFilter<"ClassSchedule"> | string
    day?: EnumDayOfWeekFilter<"ClassSchedule"> | $Enums.DayOfWeek
    startTime?: StringFilter<"ClassSchedule"> | string
    endTime?: StringFilter<"ClassSchedule"> | string
    roomId?: StringNullableFilter<"ClassSchedule"> | string | null
    courseId?: StringNullableFilter<"ClassSchedule"> | string | null
    instructorId?: StringNullableFilter<"ClassSchedule"> | string | null
    termId?: StringNullableFilter<"ClassSchedule"> | string | null
    section?: XOR<ClassSectionRelationFilter, ClassSectionWhereInput>
    room?: XOR<RoomNullableRelationFilter, RoomWhereInput> | null
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    instructor?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    term?: XOR<AcademicTermNullableRelationFilter, AcademicTermWhereInput> | null
  }, "id">

  export type ClassScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    roomId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    instructorId?: SortOrderInput | SortOrder
    termId?: SortOrderInput | SortOrder
    _count?: ClassScheduleCountOrderByAggregateInput
    _max?: ClassScheduleMaxOrderByAggregateInput
    _min?: ClassScheduleMinOrderByAggregateInput
  }

  export type ClassScheduleScalarWhereWithAggregatesInput = {
    AND?: ClassScheduleScalarWhereWithAggregatesInput | ClassScheduleScalarWhereWithAggregatesInput[]
    OR?: ClassScheduleScalarWhereWithAggregatesInput[]
    NOT?: ClassScheduleScalarWhereWithAggregatesInput | ClassScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassSchedule"> | string
    sectionId?: StringWithAggregatesFilter<"ClassSchedule"> | string
    day?: EnumDayOfWeekWithAggregatesFilter<"ClassSchedule"> | $Enums.DayOfWeek
    startTime?: StringWithAggregatesFilter<"ClassSchedule"> | string
    endTime?: StringWithAggregatesFilter<"ClassSchedule"> | string
    roomId?: StringNullableWithAggregatesFilter<"ClassSchedule"> | string | null
    courseId?: StringNullableWithAggregatesFilter<"ClassSchedule"> | string | null
    instructorId?: StringNullableWithAggregatesFilter<"ClassSchedule"> | string | null
    termId?: StringNullableWithAggregatesFilter<"ClassSchedule"> | string | null
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    sectionId?: StringFilter<"Enrollment"> | string
    grade?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    section?: XOR<ClassSectionRelationFilter, ClassSectionWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    grade?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    section?: ClassSectionOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_sectionId?: EnrollmentStudentIdSectionIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    studentId?: StringFilter<"Enrollment"> | string
    sectionId?: StringFilter<"Enrollment"> | string
    grade?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    section?: XOR<ClassSectionRelationFilter, ClassSectionWhereInput>
  }, "id" | "studentId_sectionId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    grade?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    studentId?: StringWithAggregatesFilter<"Enrollment"> | string
    sectionId?: StringWithAggregatesFilter<"Enrollment"> | string
    grade?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    studentId?: StringFilter<"Invoice"> | string
    termId?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    termId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    term?: AcademicTermOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    studentId?: StringFilter<"Invoice"> | string
    termId?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    termId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    studentId?: StringWithAggregatesFilter<"Invoice"> | string
    termId?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    amount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    slipUrl?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verifiedBy?: StringNullableFilter<"Payment"> | string | null
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    slipUrl?: SortOrderInput | SortOrder
    paidAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    slipUrl?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verifiedBy?: StringNullableFilter<"Payment"> | string | null
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    slipUrl?: SortOrderInput | SortOrder
    paidAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    slipUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paidAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    imageUrl?: StringNullableFilter<"Announcement"> | string | null
    content?: StringFilter<"Announcement"> | string
    target?: EnumAnnouncementTargetFilter<"Announcement"> | $Enums.AnnouncementTarget
    isPublished?: BoolFilter<"Announcement"> | boolean
    publishedAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    authorId?: StringFilter<"Announcement"> | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    content?: SortOrder
    target?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    imageUrl?: StringNullableFilter<"Announcement"> | string | null
    content?: StringFilter<"Announcement"> | string
    target?: EnumAnnouncementTargetFilter<"Announcement"> | $Enums.AnnouncementTarget
    isPublished?: BoolFilter<"Announcement"> | boolean
    publishedAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    authorId?: StringFilter<"Announcement"> | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    content?: SortOrder
    target?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    content?: StringWithAggregatesFilter<"Announcement"> | string
    target?: EnumAnnouncementTargetWithAggregatesFilter<"Announcement"> | $Enums.AnnouncementTarget
    isPublished?: BoolWithAggregatesFilter<"Announcement"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
    authorId?: StringWithAggregatesFilter<"Announcement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    title?: StringFilter<"Banner"> | string
    description?: StringNullableFilter<"Banner"> | string | null
    imageUrl?: StringFilter<"Banner"> | string
    linkUrl?: StringNullableFilter<"Banner"> | string | null
    isActive?: BoolFilter<"Banner"> | boolean
    order?: IntFilter<"Banner"> | number
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    title?: StringFilter<"Banner"> | string
    description?: StringNullableFilter<"Banner"> | string | null
    imageUrl?: StringFilter<"Banner"> | string
    linkUrl?: StringNullableFilter<"Banner"> | string | null
    isActive?: BoolFilter<"Banner"> | boolean
    order?: IntFilter<"Banner"> | number
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    title?: StringWithAggregatesFilter<"Banner"> | string
    description?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    imageUrl?: StringWithAggregatesFilter<"Banner"> | string
    linkUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    isActive?: BoolWithAggregatesFilter<"Banner"> | boolean
    order?: IntWithAggregatesFilter<"Banner"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type AiSettingsWhereInput = {
    AND?: AiSettingsWhereInput | AiSettingsWhereInput[]
    OR?: AiSettingsWhereInput[]
    NOT?: AiSettingsWhereInput | AiSettingsWhereInput[]
    id?: StringFilter<"AiSettings"> | string
    botName?: StringFilter<"AiSettings"> | string
    welcomeMessage?: StringFilter<"AiSettings"> | string
    personality?: StringFilter<"AiSettings"> | string
    isActive?: BoolFilter<"AiSettings"> | boolean
    updatedAt?: DateTimeFilter<"AiSettings"> | Date | string
  }

  export type AiSettingsOrderByWithRelationInput = {
    id?: SortOrder
    botName?: SortOrder
    welcomeMessage?: SortOrder
    personality?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiSettingsWhereInput | AiSettingsWhereInput[]
    OR?: AiSettingsWhereInput[]
    NOT?: AiSettingsWhereInput | AiSettingsWhereInput[]
    botName?: StringFilter<"AiSettings"> | string
    welcomeMessage?: StringFilter<"AiSettings"> | string
    personality?: StringFilter<"AiSettings"> | string
    isActive?: BoolFilter<"AiSettings"> | boolean
    updatedAt?: DateTimeFilter<"AiSettings"> | Date | string
  }, "id">

  export type AiSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    botName?: SortOrder
    welcomeMessage?: SortOrder
    personality?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    _count?: AiSettingsCountOrderByAggregateInput
    _max?: AiSettingsMaxOrderByAggregateInput
    _min?: AiSettingsMinOrderByAggregateInput
  }

  export type AiSettingsScalarWhereWithAggregatesInput = {
    AND?: AiSettingsScalarWhereWithAggregatesInput | AiSettingsScalarWhereWithAggregatesInput[]
    OR?: AiSettingsScalarWhereWithAggregatesInput[]
    NOT?: AiSettingsScalarWhereWithAggregatesInput | AiSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiSettings"> | string
    botName?: StringWithAggregatesFilter<"AiSettings"> | string
    welcomeMessage?: StringWithAggregatesFilter<"AiSettings"> | string
    personality?: StringWithAggregatesFilter<"AiSettings"> | string
    isActive?: BoolWithAggregatesFilter<"AiSettings"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"AiSettings"> | Date | string
  }

  export type AiKnowledgeBaseWhereInput = {
    AND?: AiKnowledgeBaseWhereInput | AiKnowledgeBaseWhereInput[]
    OR?: AiKnowledgeBaseWhereInput[]
    NOT?: AiKnowledgeBaseWhereInput | AiKnowledgeBaseWhereInput[]
    id?: StringFilter<"AiKnowledgeBase"> | string
    question?: StringFilter<"AiKnowledgeBase"> | string
    answer?: StringFilter<"AiKnowledgeBase"> | string
    category?: StringNullableFilter<"AiKnowledgeBase"> | string | null
    isActive?: BoolFilter<"AiKnowledgeBase"> | boolean
    createdAt?: DateTimeFilter<"AiKnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"AiKnowledgeBase"> | Date | string
  }

  export type AiKnowledgeBaseOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiKnowledgeBaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiKnowledgeBaseWhereInput | AiKnowledgeBaseWhereInput[]
    OR?: AiKnowledgeBaseWhereInput[]
    NOT?: AiKnowledgeBaseWhereInput | AiKnowledgeBaseWhereInput[]
    question?: StringFilter<"AiKnowledgeBase"> | string
    answer?: StringFilter<"AiKnowledgeBase"> | string
    category?: StringNullableFilter<"AiKnowledgeBase"> | string | null
    isActive?: BoolFilter<"AiKnowledgeBase"> | boolean
    createdAt?: DateTimeFilter<"AiKnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"AiKnowledgeBase"> | Date | string
  }, "id">

  export type AiKnowledgeBaseOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiKnowledgeBaseCountOrderByAggregateInput
    _max?: AiKnowledgeBaseMaxOrderByAggregateInput
    _min?: AiKnowledgeBaseMinOrderByAggregateInput
  }

  export type AiKnowledgeBaseScalarWhereWithAggregatesInput = {
    AND?: AiKnowledgeBaseScalarWhereWithAggregatesInput | AiKnowledgeBaseScalarWhereWithAggregatesInput[]
    OR?: AiKnowledgeBaseScalarWhereWithAggregatesInput[]
    NOT?: AiKnowledgeBaseScalarWhereWithAggregatesInput | AiKnowledgeBaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiKnowledgeBase"> | string
    question?: StringWithAggregatesFilter<"AiKnowledgeBase"> | string
    answer?: StringWithAggregatesFilter<"AiKnowledgeBase"> | string
    category?: StringNullableWithAggregatesFilter<"AiKnowledgeBase"> | string | null
    isActive?: BoolWithAggregatesFilter<"AiKnowledgeBase"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AiKnowledgeBase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiKnowledgeBase"> | Date | string
  }

  export type AiConversationWhereInput = {
    AND?: AiConversationWhereInput | AiConversationWhereInput[]
    OR?: AiConversationWhereInput[]
    NOT?: AiConversationWhereInput | AiConversationWhereInput[]
    id?: StringFilter<"AiConversation"> | string
    userId?: StringNullableFilter<"AiConversation"> | string | null
    sessionId?: StringNullableFilter<"AiConversation"> | string | null
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
    messages?: AiMessageListRelationFilter
  }

  export type AiConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: AiMessageOrderByRelationAggregateInput
  }

  export type AiConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiConversationWhereInput | AiConversationWhereInput[]
    OR?: AiConversationWhereInput[]
    NOT?: AiConversationWhereInput | AiConversationWhereInput[]
    userId?: StringNullableFilter<"AiConversation"> | string | null
    sessionId?: StringNullableFilter<"AiConversation"> | string | null
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
    messages?: AiMessageListRelationFilter
  }, "id">

  export type AiConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiConversationCountOrderByAggregateInput
    _max?: AiConversationMaxOrderByAggregateInput
    _min?: AiConversationMinOrderByAggregateInput
  }

  export type AiConversationScalarWhereWithAggregatesInput = {
    AND?: AiConversationScalarWhereWithAggregatesInput | AiConversationScalarWhereWithAggregatesInput[]
    OR?: AiConversationScalarWhereWithAggregatesInput[]
    NOT?: AiConversationScalarWhereWithAggregatesInput | AiConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiConversation"> | string
    userId?: StringNullableWithAggregatesFilter<"AiConversation"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AiConversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiConversation"> | Date | string
  }

  export type AiMessageWhereInput = {
    AND?: AiMessageWhereInput | AiMessageWhereInput[]
    OR?: AiMessageWhereInput[]
    NOT?: AiMessageWhereInput | AiMessageWhereInput[]
    id?: StringFilter<"AiMessage"> | string
    conversationId?: StringFilter<"AiMessage"> | string
    role?: StringFilter<"AiMessage"> | string
    content?: StringFilter<"AiMessage"> | string
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
    conversation?: XOR<AiConversationRelationFilter, AiConversationWhereInput>
  }

  export type AiMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversation?: AiConversationOrderByWithRelationInput
  }

  export type AiMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiMessageWhereInput | AiMessageWhereInput[]
    OR?: AiMessageWhereInput[]
    NOT?: AiMessageWhereInput | AiMessageWhereInput[]
    conversationId?: StringFilter<"AiMessage"> | string
    role?: StringFilter<"AiMessage"> | string
    content?: StringFilter<"AiMessage"> | string
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
    conversation?: XOR<AiConversationRelationFilter, AiConversationWhereInput>
  }, "id">

  export type AiMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: AiMessageCountOrderByAggregateInput
    _max?: AiMessageMaxOrderByAggregateInput
    _min?: AiMessageMinOrderByAggregateInput
  }

  export type AiMessageScalarWhereWithAggregatesInput = {
    AND?: AiMessageScalarWhereWithAggregatesInput | AiMessageScalarWhereWithAggregatesInput[]
    OR?: AiMessageScalarWhereWithAggregatesInput[]
    NOT?: AiMessageScalarWhereWithAggregatesInput | AiMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiMessage"> | string
    conversationId?: StringWithAggregatesFilter<"AiMessage"> | string
    role?: StringWithAggregatesFilter<"AiMessage"> | string
    content?: StringWithAggregatesFilter<"AiMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AiMessage"> | Date | string
  }

  export type HelpCategoryWhereInput = {
    AND?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    OR?: HelpCategoryWhereInput[]
    NOT?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    id?: StringFilter<"HelpCategory"> | string
    name?: StringFilter<"HelpCategory"> | string
    description?: StringNullableFilter<"HelpCategory"> | string | null
    order?: IntFilter<"HelpCategory"> | number
    createdAt?: DateTimeFilter<"HelpCategory"> | Date | string
    updatedAt?: DateTimeFilter<"HelpCategory"> | Date | string
    articles?: HelpArticleListRelationFilter
  }

  export type HelpCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articles?: HelpArticleOrderByRelationAggregateInput
  }

  export type HelpCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    OR?: HelpCategoryWhereInput[]
    NOT?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    name?: StringFilter<"HelpCategory"> | string
    description?: StringNullableFilter<"HelpCategory"> | string | null
    order?: IntFilter<"HelpCategory"> | number
    createdAt?: DateTimeFilter<"HelpCategory"> | Date | string
    updatedAt?: DateTimeFilter<"HelpCategory"> | Date | string
    articles?: HelpArticleListRelationFilter
  }, "id">

  export type HelpCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelpCategoryCountOrderByAggregateInput
    _avg?: HelpCategoryAvgOrderByAggregateInput
    _max?: HelpCategoryMaxOrderByAggregateInput
    _min?: HelpCategoryMinOrderByAggregateInput
    _sum?: HelpCategorySumOrderByAggregateInput
  }

  export type HelpCategoryScalarWhereWithAggregatesInput = {
    AND?: HelpCategoryScalarWhereWithAggregatesInput | HelpCategoryScalarWhereWithAggregatesInput[]
    OR?: HelpCategoryScalarWhereWithAggregatesInput[]
    NOT?: HelpCategoryScalarWhereWithAggregatesInput | HelpCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HelpCategory"> | string
    name?: StringWithAggregatesFilter<"HelpCategory"> | string
    description?: StringNullableWithAggregatesFilter<"HelpCategory"> | string | null
    order?: IntWithAggregatesFilter<"HelpCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"HelpCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelpCategory"> | Date | string
  }

  export type HelpArticleWhereInput = {
    AND?: HelpArticleWhereInput | HelpArticleWhereInput[]
    OR?: HelpArticleWhereInput[]
    NOT?: HelpArticleWhereInput | HelpArticleWhereInput[]
    id?: StringFilter<"HelpArticle"> | string
    title?: StringFilter<"HelpArticle"> | string
    content?: StringFilter<"HelpArticle"> | string
    categoryId?: StringFilter<"HelpArticle"> | string
    visibility?: EnumHelpArticleVisibilityFilter<"HelpArticle"> | $Enums.HelpArticleVisibility
    isPublished?: BoolFilter<"HelpArticle"> | boolean
    authorId?: StringFilter<"HelpArticle"> | string
    views?: IntFilter<"HelpArticle"> | number
    createdAt?: DateTimeFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HelpArticle"> | Date | string
    category?: XOR<HelpCategoryRelationFilter, HelpCategoryWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HelpArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    visibility?: SortOrder
    isPublished?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: HelpCategoryOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type HelpArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HelpArticleWhereInput | HelpArticleWhereInput[]
    OR?: HelpArticleWhereInput[]
    NOT?: HelpArticleWhereInput | HelpArticleWhereInput[]
    title?: StringFilter<"HelpArticle"> | string
    content?: StringFilter<"HelpArticle"> | string
    categoryId?: StringFilter<"HelpArticle"> | string
    visibility?: EnumHelpArticleVisibilityFilter<"HelpArticle"> | $Enums.HelpArticleVisibility
    isPublished?: BoolFilter<"HelpArticle"> | boolean
    authorId?: StringFilter<"HelpArticle"> | string
    views?: IntFilter<"HelpArticle"> | number
    createdAt?: DateTimeFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HelpArticle"> | Date | string
    category?: XOR<HelpCategoryRelationFilter, HelpCategoryWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type HelpArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    visibility?: SortOrder
    isPublished?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelpArticleCountOrderByAggregateInput
    _avg?: HelpArticleAvgOrderByAggregateInput
    _max?: HelpArticleMaxOrderByAggregateInput
    _min?: HelpArticleMinOrderByAggregateInput
    _sum?: HelpArticleSumOrderByAggregateInput
  }

  export type HelpArticleScalarWhereWithAggregatesInput = {
    AND?: HelpArticleScalarWhereWithAggregatesInput | HelpArticleScalarWhereWithAggregatesInput[]
    OR?: HelpArticleScalarWhereWithAggregatesInput[]
    NOT?: HelpArticleScalarWhereWithAggregatesInput | HelpArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HelpArticle"> | string
    title?: StringWithAggregatesFilter<"HelpArticle"> | string
    content?: StringWithAggregatesFilter<"HelpArticle"> | string
    categoryId?: StringWithAggregatesFilter<"HelpArticle"> | string
    visibility?: EnumHelpArticleVisibilityWithAggregatesFilter<"HelpArticle"> | $Enums.HelpArticleVisibility
    isPublished?: BoolWithAggregatesFilter<"HelpArticle"> | boolean
    authorId?: StringWithAggregatesFilter<"HelpArticle"> | string
    views?: IntWithAggregatesFilter<"HelpArticle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelpArticle"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    universityName?: StringFilter<"SystemSettings"> | string
    universityNameTh?: StringFilter<"SystemSettings"> | string
    logoUrl?: StringNullableFilter<"SystemSettings"> | string | null
    primaryColor?: StringFilter<"SystemSettings"> | string
    secondaryColor?: StringFilter<"SystemSettings"> | string
    backgroundColor?: StringFilter<"SystemSettings"> | string
    studentIdFormat?: StringFilter<"SystemSettings"> | string
    defaultLanguage?: StringFilter<"SystemSettings"> | string
    smtpHost?: StringNullableFilter<"SystemSettings"> | string | null
    smtpPort?: IntFilter<"SystemSettings"> | number
    smtpUser?: StringNullableFilter<"SystemSettings"> | string | null
    smtpPassword?: StringNullableFilter<"SystemSettings"> | string | null
    smtpSecure?: BoolFilter<"SystemSettings"> | boolean
    smtpFromEmail?: StringFilter<"SystemSettings"> | string
    smtpFromName?: StringFilter<"SystemSettings"> | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    universityName?: SortOrder
    universityNameTh?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    backgroundColor?: SortOrder
    studentIdFormat?: SortOrder
    defaultLanguage?: SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    smtpSecure?: SortOrder
    smtpFromEmail?: SortOrder
    smtpFromName?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    universityName?: StringFilter<"SystemSettings"> | string
    universityNameTh?: StringFilter<"SystemSettings"> | string
    logoUrl?: StringNullableFilter<"SystemSettings"> | string | null
    primaryColor?: StringFilter<"SystemSettings"> | string
    secondaryColor?: StringFilter<"SystemSettings"> | string
    backgroundColor?: StringFilter<"SystemSettings"> | string
    studentIdFormat?: StringFilter<"SystemSettings"> | string
    defaultLanguage?: StringFilter<"SystemSettings"> | string
    smtpHost?: StringNullableFilter<"SystemSettings"> | string | null
    smtpPort?: IntFilter<"SystemSettings"> | number
    smtpUser?: StringNullableFilter<"SystemSettings"> | string | null
    smtpPassword?: StringNullableFilter<"SystemSettings"> | string | null
    smtpSecure?: BoolFilter<"SystemSettings"> | boolean
    smtpFromEmail?: StringFilter<"SystemSettings"> | string
    smtpFromName?: StringFilter<"SystemSettings"> | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    universityName?: SortOrder
    universityNameTh?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    backgroundColor?: SortOrder
    studentIdFormat?: SortOrder
    defaultLanguage?: SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    smtpSecure?: SortOrder
    smtpFromEmail?: SortOrder
    smtpFromName?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _avg?: SystemSettingsAvgOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
    _sum?: SystemSettingsSumOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    universityName?: StringWithAggregatesFilter<"SystemSettings"> | string
    universityNameTh?: StringWithAggregatesFilter<"SystemSettings"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    primaryColor?: StringWithAggregatesFilter<"SystemSettings"> | string
    secondaryColor?: StringWithAggregatesFilter<"SystemSettings"> | string
    backgroundColor?: StringWithAggregatesFilter<"SystemSettings"> | string
    studentIdFormat?: StringWithAggregatesFilter<"SystemSettings"> | string
    defaultLanguage?: StringWithAggregatesFilter<"SystemSettings"> | string
    smtpHost?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    smtpPort?: IntWithAggregatesFilter<"SystemSettings"> | number
    smtpUser?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    smtpPassword?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    smtpSecure?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    smtpFromEmail?: StringWithAggregatesFilter<"SystemSettings"> | string
    smtpFromName?: StringWithAggregatesFilter<"SystemSettings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    userId?: StringNullableFilter<"SystemLog"> | string | null
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    userId?: StringNullableFilter<"SystemLog"> | string | null
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLog"> | string
    userId?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    action?: StringWithAggregatesFilter<"SystemLog"> | string
    details?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
  }

  export type TranslationWhereInput = {
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    id?: StringFilter<"Translation"> | string
    key?: StringFilter<"Translation"> | string
    th?: StringFilter<"Translation"> | string
    en?: StringFilter<"Translation"> | string
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
  }

  export type TranslationOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    th?: SortOrder
    en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    th?: StringFilter<"Translation"> | string
    en?: StringFilter<"Translation"> | string
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
  }, "id" | "key">

  export type TranslationOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    th?: SortOrder
    en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TranslationCountOrderByAggregateInput
    _max?: TranslationMaxOrderByAggregateInput
    _min?: TranslationMinOrderByAggregateInput
  }

  export type TranslationScalarWhereWithAggregatesInput = {
    AND?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    OR?: TranslationScalarWhereWithAggregatesInput[]
    NOT?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Translation"> | string
    key?: StringWithAggregatesFilter<"Translation"> | string
    th?: StringWithAggregatesFilter<"Translation"> | string
    en?: StringWithAggregatesFilter<"Translation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    code?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    building?: StringFilter<"Room"> | string
    floor?: IntFilter<"Room"> | number
    capacity?: IntFilter<"Room"> | number
    roomType?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    facilities?: StringNullableFilter<"Room"> | string | null
    isActive?: BoolFilter<"Room"> | boolean
    isAvailable?: BoolFilter<"Room"> | boolean
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    schedules?: ClassScheduleListRelationFilter
    examSlots?: ExamSlotListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    building?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    roomType?: SortOrder
    facilities?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schedules?: ClassScheduleOrderByRelationAggregateInput
    examSlots?: ExamSlotOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    name?: StringFilter<"Room"> | string
    building?: StringFilter<"Room"> | string
    floor?: IntFilter<"Room"> | number
    capacity?: IntFilter<"Room"> | number
    roomType?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    facilities?: StringNullableFilter<"Room"> | string | null
    isActive?: BoolFilter<"Room"> | boolean
    isAvailable?: BoolFilter<"Room"> | boolean
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    schedules?: ClassScheduleListRelationFilter
    examSlots?: ExamSlotListRelationFilter
  }, "id" | "code">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    building?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    roomType?: SortOrder
    facilities?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    code?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    building?: StringWithAggregatesFilter<"Room"> | string
    floor?: IntWithAggregatesFilter<"Room"> | number
    capacity?: IntWithAggregatesFilter<"Room"> | number
    roomType?: EnumRoomTypeWithAggregatesFilter<"Room"> | $Enums.RoomType
    facilities?: StringNullableWithAggregatesFilter<"Room"> | string | null
    isActive?: BoolWithAggregatesFilter<"Room"> | boolean
    isAvailable?: BoolWithAggregatesFilter<"Room"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type ExamScheduleWhereInput = {
    AND?: ExamScheduleWhereInput | ExamScheduleWhereInput[]
    OR?: ExamScheduleWhereInput[]
    NOT?: ExamScheduleWhereInput | ExamScheduleWhereInput[]
    id?: StringFilter<"ExamSchedule"> | string
    courseId?: StringFilter<"ExamSchedule"> | string
    section?: StringFilter<"ExamSchedule"> | string
    termId?: StringFilter<"ExamSchedule"> | string
    examType?: EnumExamTypeFilter<"ExamSchedule"> | $Enums.ExamType
    examDate?: DateTimeFilter<"ExamSchedule"> | Date | string
    startTime?: StringFilter<"ExamSchedule"> | string
    endTime?: StringFilter<"ExamSchedule"> | string
    duration?: IntFilter<"ExamSchedule"> | number
    examFormat?: EnumExamFormatFilter<"ExamSchedule"> | $Enums.ExamFormat
    instructions?: StringNullableFilter<"ExamSchedule"> | string | null
    isPublished?: BoolFilter<"ExamSchedule"> | boolean
    createdAt?: DateTimeFilter<"ExamSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSchedule"> | Date | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
    examSlots?: ExamSlotListRelationFilter
  }

  export type ExamScheduleOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    section?: SortOrder
    termId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    examFormat?: SortOrder
    instructions?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    term?: AcademicTermOrderByWithRelationInput
    examSlots?: ExamSlotOrderByRelationAggregateInput
  }

  export type ExamScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_section_termId_examType?: ExamScheduleCourseIdSectionTermIdExamTypeCompoundUniqueInput
    AND?: ExamScheduleWhereInput | ExamScheduleWhereInput[]
    OR?: ExamScheduleWhereInput[]
    NOT?: ExamScheduleWhereInput | ExamScheduleWhereInput[]
    courseId?: StringFilter<"ExamSchedule"> | string
    section?: StringFilter<"ExamSchedule"> | string
    termId?: StringFilter<"ExamSchedule"> | string
    examType?: EnumExamTypeFilter<"ExamSchedule"> | $Enums.ExamType
    examDate?: DateTimeFilter<"ExamSchedule"> | Date | string
    startTime?: StringFilter<"ExamSchedule"> | string
    endTime?: StringFilter<"ExamSchedule"> | string
    duration?: IntFilter<"ExamSchedule"> | number
    examFormat?: EnumExamFormatFilter<"ExamSchedule"> | $Enums.ExamFormat
    instructions?: StringNullableFilter<"ExamSchedule"> | string | null
    isPublished?: BoolFilter<"ExamSchedule"> | boolean
    createdAt?: DateTimeFilter<"ExamSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSchedule"> | Date | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
    examSlots?: ExamSlotListRelationFilter
  }, "id" | "courseId_section_termId_examType">

  export type ExamScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    section?: SortOrder
    termId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    examFormat?: SortOrder
    instructions?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamScheduleCountOrderByAggregateInput
    _avg?: ExamScheduleAvgOrderByAggregateInput
    _max?: ExamScheduleMaxOrderByAggregateInput
    _min?: ExamScheduleMinOrderByAggregateInput
    _sum?: ExamScheduleSumOrderByAggregateInput
  }

  export type ExamScheduleScalarWhereWithAggregatesInput = {
    AND?: ExamScheduleScalarWhereWithAggregatesInput | ExamScheduleScalarWhereWithAggregatesInput[]
    OR?: ExamScheduleScalarWhereWithAggregatesInput[]
    NOT?: ExamScheduleScalarWhereWithAggregatesInput | ExamScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamSchedule"> | string
    courseId?: StringWithAggregatesFilter<"ExamSchedule"> | string
    section?: StringWithAggregatesFilter<"ExamSchedule"> | string
    termId?: StringWithAggregatesFilter<"ExamSchedule"> | string
    examType?: EnumExamTypeWithAggregatesFilter<"ExamSchedule"> | $Enums.ExamType
    examDate?: DateTimeWithAggregatesFilter<"ExamSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"ExamSchedule"> | string
    endTime?: StringWithAggregatesFilter<"ExamSchedule"> | string
    duration?: IntWithAggregatesFilter<"ExamSchedule"> | number
    examFormat?: EnumExamFormatWithAggregatesFilter<"ExamSchedule"> | $Enums.ExamFormat
    instructions?: StringNullableWithAggregatesFilter<"ExamSchedule"> | string | null
    isPublished?: BoolWithAggregatesFilter<"ExamSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExamSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamSchedule"> | Date | string
  }

  export type ExamSlotWhereInput = {
    AND?: ExamSlotWhereInput | ExamSlotWhereInput[]
    OR?: ExamSlotWhereInput[]
    NOT?: ExamSlotWhereInput | ExamSlotWhereInput[]
    id?: StringFilter<"ExamSlot"> | string
    examScheduleId?: StringFilter<"ExamSlot"> | string
    roomId?: StringFilter<"ExamSlot"> | string
    capacity?: IntFilter<"ExamSlot"> | number
    assignedCount?: IntFilter<"ExamSlot"> | number
    createdAt?: DateTimeFilter<"ExamSlot"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSlot"> | Date | string
    examSchedule?: XOR<ExamScheduleRelationFilter, ExamScheduleWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    proctors?: ExamProctorListRelationFilter
  }

  export type ExamSlotOrderByWithRelationInput = {
    id?: SortOrder
    examScheduleId?: SortOrder
    roomId?: SortOrder
    capacity?: SortOrder
    assignedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examSchedule?: ExamScheduleOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    proctors?: ExamProctorOrderByRelationAggregateInput
  }

  export type ExamSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamSlotWhereInput | ExamSlotWhereInput[]
    OR?: ExamSlotWhereInput[]
    NOT?: ExamSlotWhereInput | ExamSlotWhereInput[]
    examScheduleId?: StringFilter<"ExamSlot"> | string
    roomId?: StringFilter<"ExamSlot"> | string
    capacity?: IntFilter<"ExamSlot"> | number
    assignedCount?: IntFilter<"ExamSlot"> | number
    createdAt?: DateTimeFilter<"ExamSlot"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSlot"> | Date | string
    examSchedule?: XOR<ExamScheduleRelationFilter, ExamScheduleWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    proctors?: ExamProctorListRelationFilter
  }, "id">

  export type ExamSlotOrderByWithAggregationInput = {
    id?: SortOrder
    examScheduleId?: SortOrder
    roomId?: SortOrder
    capacity?: SortOrder
    assignedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamSlotCountOrderByAggregateInput
    _avg?: ExamSlotAvgOrderByAggregateInput
    _max?: ExamSlotMaxOrderByAggregateInput
    _min?: ExamSlotMinOrderByAggregateInput
    _sum?: ExamSlotSumOrderByAggregateInput
  }

  export type ExamSlotScalarWhereWithAggregatesInput = {
    AND?: ExamSlotScalarWhereWithAggregatesInput | ExamSlotScalarWhereWithAggregatesInput[]
    OR?: ExamSlotScalarWhereWithAggregatesInput[]
    NOT?: ExamSlotScalarWhereWithAggregatesInput | ExamSlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamSlot"> | string
    examScheduleId?: StringWithAggregatesFilter<"ExamSlot"> | string
    roomId?: StringWithAggregatesFilter<"ExamSlot"> | string
    capacity?: IntWithAggregatesFilter<"ExamSlot"> | number
    assignedCount?: IntWithAggregatesFilter<"ExamSlot"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExamSlot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamSlot"> | Date | string
  }

  export type ExamProctorWhereInput = {
    AND?: ExamProctorWhereInput | ExamProctorWhereInput[]
    OR?: ExamProctorWhereInput[]
    NOT?: ExamProctorWhereInput | ExamProctorWhereInput[]
    id?: StringFilter<"ExamProctor"> | string
    examSlotId?: StringFilter<"ExamProctor"> | string
    proctorId?: StringFilter<"ExamProctor"> | string
    role?: EnumProctorRoleFilter<"ExamProctor"> | $Enums.ProctorRole
    isConfirmed?: BoolFilter<"ExamProctor"> | boolean
    createdAt?: DateTimeFilter<"ExamProctor"> | Date | string
    updatedAt?: DateTimeFilter<"ExamProctor"> | Date | string
    examSlot?: XOR<ExamSlotRelationFilter, ExamSlotWhereInput>
    proctor?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type ExamProctorOrderByWithRelationInput = {
    id?: SortOrder
    examSlotId?: SortOrder
    proctorId?: SortOrder
    role?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examSlot?: ExamSlotOrderByWithRelationInput
    proctor?: PersonnelOrderByWithRelationInput
  }

  export type ExamProctorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    examSlotId_proctorId?: ExamProctorExamSlotIdProctorIdCompoundUniqueInput
    AND?: ExamProctorWhereInput | ExamProctorWhereInput[]
    OR?: ExamProctorWhereInput[]
    NOT?: ExamProctorWhereInput | ExamProctorWhereInput[]
    examSlotId?: StringFilter<"ExamProctor"> | string
    proctorId?: StringFilter<"ExamProctor"> | string
    role?: EnumProctorRoleFilter<"ExamProctor"> | $Enums.ProctorRole
    isConfirmed?: BoolFilter<"ExamProctor"> | boolean
    createdAt?: DateTimeFilter<"ExamProctor"> | Date | string
    updatedAt?: DateTimeFilter<"ExamProctor"> | Date | string
    examSlot?: XOR<ExamSlotRelationFilter, ExamSlotWhereInput>
    proctor?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "id" | "examSlotId_proctorId">

  export type ExamProctorOrderByWithAggregationInput = {
    id?: SortOrder
    examSlotId?: SortOrder
    proctorId?: SortOrder
    role?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamProctorCountOrderByAggregateInput
    _max?: ExamProctorMaxOrderByAggregateInput
    _min?: ExamProctorMinOrderByAggregateInput
  }

  export type ExamProctorScalarWhereWithAggregatesInput = {
    AND?: ExamProctorScalarWhereWithAggregatesInput | ExamProctorScalarWhereWithAggregatesInput[]
    OR?: ExamProctorScalarWhereWithAggregatesInput[]
    NOT?: ExamProctorScalarWhereWithAggregatesInput | ExamProctorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamProctor"> | string
    examSlotId?: StringWithAggregatesFilter<"ExamProctor"> | string
    proctorId?: StringWithAggregatesFilter<"ExamProctor"> | string
    role?: EnumProctorRoleWithAggregatesFilter<"ExamProctor"> | $Enums.ProctorRole
    isConfirmed?: BoolWithAggregatesFilter<"ExamProctor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExamProctor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamProctor"> | Date | string
  }

  export type TeachingLoadWhereInput = {
    AND?: TeachingLoadWhereInput | TeachingLoadWhereInput[]
    OR?: TeachingLoadWhereInput[]
    NOT?: TeachingLoadWhereInput | TeachingLoadWhereInput[]
    id?: StringFilter<"TeachingLoad"> | string
    instructorId?: StringFilter<"TeachingLoad"> | string
    termId?: StringFilter<"TeachingLoad"> | string
    lectureHours?: FloatFilter<"TeachingLoad"> | number
    labHours?: FloatFilter<"TeachingLoad"> | number
    totalHours?: FloatFilter<"TeachingLoad"> | number
    courseCount?: IntFilter<"TeachingLoad"> | number
    isApproved?: BoolFilter<"TeachingLoad"> | boolean
    approvedBy?: StringNullableFilter<"TeachingLoad"> | string | null
    approvedAt?: DateTimeNullableFilter<"TeachingLoad"> | Date | string | null
    createdAt?: DateTimeFilter<"TeachingLoad"> | Date | string
    updatedAt?: DateTimeFilter<"TeachingLoad"> | Date | string
    instructor?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
  }

  export type TeachingLoadOrderByWithRelationInput = {
    id?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
    lectureHours?: SortOrder
    labHours?: SortOrder
    totalHours?: SortOrder
    courseCount?: SortOrder
    isApproved?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instructor?: PersonnelOrderByWithRelationInput
    term?: AcademicTermOrderByWithRelationInput
  }

  export type TeachingLoadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instructorId_termId?: TeachingLoadInstructorIdTermIdCompoundUniqueInput
    AND?: TeachingLoadWhereInput | TeachingLoadWhereInput[]
    OR?: TeachingLoadWhereInput[]
    NOT?: TeachingLoadWhereInput | TeachingLoadWhereInput[]
    instructorId?: StringFilter<"TeachingLoad"> | string
    termId?: StringFilter<"TeachingLoad"> | string
    lectureHours?: FloatFilter<"TeachingLoad"> | number
    labHours?: FloatFilter<"TeachingLoad"> | number
    totalHours?: FloatFilter<"TeachingLoad"> | number
    courseCount?: IntFilter<"TeachingLoad"> | number
    isApproved?: BoolFilter<"TeachingLoad"> | boolean
    approvedBy?: StringNullableFilter<"TeachingLoad"> | string | null
    approvedAt?: DateTimeNullableFilter<"TeachingLoad"> | Date | string | null
    createdAt?: DateTimeFilter<"TeachingLoad"> | Date | string
    updatedAt?: DateTimeFilter<"TeachingLoad"> | Date | string
    instructor?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    term?: XOR<AcademicTermRelationFilter, AcademicTermWhereInput>
  }, "id" | "instructorId_termId">

  export type TeachingLoadOrderByWithAggregationInput = {
    id?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
    lectureHours?: SortOrder
    labHours?: SortOrder
    totalHours?: SortOrder
    courseCount?: SortOrder
    isApproved?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeachingLoadCountOrderByAggregateInput
    _avg?: TeachingLoadAvgOrderByAggregateInput
    _max?: TeachingLoadMaxOrderByAggregateInput
    _min?: TeachingLoadMinOrderByAggregateInput
    _sum?: TeachingLoadSumOrderByAggregateInput
  }

  export type TeachingLoadScalarWhereWithAggregatesInput = {
    AND?: TeachingLoadScalarWhereWithAggregatesInput | TeachingLoadScalarWhereWithAggregatesInput[]
    OR?: TeachingLoadScalarWhereWithAggregatesInput[]
    NOT?: TeachingLoadScalarWhereWithAggregatesInput | TeachingLoadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeachingLoad"> | string
    instructorId?: StringWithAggregatesFilter<"TeachingLoad"> | string
    termId?: StringWithAggregatesFilter<"TeachingLoad"> | string
    lectureHours?: FloatWithAggregatesFilter<"TeachingLoad"> | number
    labHours?: FloatWithAggregatesFilter<"TeachingLoad"> | number
    totalHours?: FloatWithAggregatesFilter<"TeachingLoad"> | number
    courseCount?: IntWithAggregatesFilter<"TeachingLoad"> | number
    isApproved?: BoolWithAggregatesFilter<"TeachingLoad"> | boolean
    approvedBy?: StringNullableWithAggregatesFilter<"TeachingLoad"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"TeachingLoad"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TeachingLoad"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeachingLoad"> | Date | string
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    studentId?: StringFilter<"LeaveRequest"> | string
    reason?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveRequestStatusFilter<"LeaveRequest"> | $Enums.LeaveRequestStatus
    reviewedBy?: StringNullableFilter<"LeaveRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    reviewNote?: StringNullableFilter<"LeaveRequest"> | string | null
    documentUrl?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    reviewer?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNote?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    reviewer?: PersonnelOrderByWithRelationInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    studentId?: StringFilter<"LeaveRequest"> | string
    reason?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveRequestStatusFilter<"LeaveRequest"> | $Enums.LeaveRequestStatus
    reviewedBy?: StringNullableFilter<"LeaveRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    reviewNote?: StringNullableFilter<"LeaveRequest"> | string | null
    documentUrl?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    reviewer?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNote?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    studentId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    reason?: StringWithAggregatesFilter<"LeaveRequest"> | string
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveRequestStatusWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveRequestStatus
    reviewedBy?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
    reviewNote?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    documentUrl?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelCreateNestedOneWithoutUserInput
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantCreateNestedOneWithoutUserInput
    logs?: SystemLogCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantUncheckedCreateNestedOneWithoutUserInput
    logs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUpdateOneWithoutUserNestedInput
    logs?: SystemLogUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUncheckedUpdateOneWithoutUserNestedInput
    logs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnelCreateInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelCreateManyInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonnelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    departments?: DepartmentCreateNestedManyWithoutFacultyInput
    programs?: ProgramCreateNestedManyWithoutFacultyInput
    personnel?: PersonnelCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacultyInput
    programs?: ProgramUncheckedCreateNestedManyWithoutFacultyInput
    personnel?: PersonnelUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUpdateManyWithoutFacultyNestedInput
    programs?: ProgramUpdateManyWithoutFacultyNestedInput
    personnel?: PersonnelUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutFacultyNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutFacultyNestedInput
    personnel?: PersonnelUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateManyInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
  }

  export type FacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentCreateInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    faculty: FacultyCreateNestedOneWithoutDepartmentsInput
    programs?: ProgramCreateNestedManyWithoutDepartmentInput
    personnel?: PersonnelCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    facultyId: string
    programs?: ProgramUncheckedCreateNestedManyWithoutDepartmentInput
    personnel?: PersonnelUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutDepartmentsNestedInput
    programs?: ProgramUpdateManyWithoutDepartmentNestedInput
    personnel?: PersonnelUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    programs?: ProgramUncheckedUpdateManyWithoutDepartmentNestedInput
    personnel?: PersonnelUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    facultyId: string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramCreateInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    department: DepartmentCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    students?: StudentCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionCreateNestedManyWithoutCourseInput
    programs?: ProgramCourseCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutCourseInput
    programs?: ProgramCourseUncheckedCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutCourseNestedInput
    programs?: ProgramCourseUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutCourseNestedInput
    programs?: ProgramCourseUncheckedUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgramCourseCreateInput = {
    id?: string
    isRequired?: boolean
    semester?: number | null
    program: ProgramCreateNestedOneWithoutCoursesInput
    course: CourseCreateNestedOneWithoutProgramsInput
  }

  export type ProgramCourseUncheckedCreateInput = {
    id?: string
    programId: string
    courseId: string
    isRequired?: boolean
    semester?: number | null
  }

  export type ProgramCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutProgramsNestedInput
  }

  export type ProgramCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramCourseCreateManyInput = {
    id?: string
    programId: string
    courseId: string
    isRequired?: boolean
    semester?: number | null
  }

  export type ProgramCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AcademicTermCreateInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionCreateNestedManyWithoutTermInput
    invoices?: InvoiceCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleCreateNestedManyWithoutTermInput
  }

  export type AcademicTermUncheckedCreateInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutTermInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutTermInput
  }

  export type AcademicTermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUpdateManyWithoutTermNestedInput
  }

  export type AcademicTermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutTermNestedInput
  }

  export type AcademicTermCreateManyInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
  }

  export type AcademicTermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AcademicTermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApplicantCreateInput = {
    id?: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    user: UserCreateNestedOneWithoutApplicantProfileInput
    educationHistory?: EducationHistoryCreateNestedManyWithoutApplicantInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    educationHistory?: EducationHistoryUncheckedCreateNestedManyWithoutApplicantInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutApplicantProfileNestedInput
    educationHistory?: EducationHistoryUpdateManyWithoutApplicantNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationHistory?: EducationHistoryUncheckedUpdateManyWithoutApplicantNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantCreateManyInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
  }

  export type ApplicantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationHistoryCreateInput = {
    id?: string
    level: string
    degreeName: string
    institution: string
    gpa?: string | null
    graduationYear?: number | null
    applicant: ApplicantCreateNestedOneWithoutEducationHistoryInput
  }

  export type EducationHistoryUncheckedCreateInput = {
    id?: string
    applicantId: string
    level: string
    degreeName: string
    institution: string
    gpa?: string | null
    graduationYear?: number | null
  }

  export type EducationHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    applicant?: ApplicantUpdateOneRequiredWithoutEducationHistoryNestedInput
  }

  export type EducationHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EducationHistoryCreateManyInput = {
    id?: string
    applicantId: string
    level: string
    degreeName: string
    institution: string
    gpa?: string | null
    graduationYear?: number | null
  }

  export type EducationHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EducationHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdmissionTrackTypeCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    color?: string
    icon?: string
    displayOrder?: number
    isActive?: boolean
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tracks?: AdmissionTrackCreateNestedManyWithoutTypeInput
  }

  export type AdmissionTrackTypeUncheckedCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    color?: string
    icon?: string
    displayOrder?: number
    isActive?: boolean
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tracks?: AdmissionTrackUncheckedCreateNestedManyWithoutTypeInput
  }

  export type AdmissionTrackTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tracks?: AdmissionTrackUpdateManyWithoutTypeNestedInput
  }

  export type AdmissionTrackTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tracks?: AdmissionTrackUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type AdmissionTrackTypeCreateManyInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    color?: string
    icon?: string
    displayOrder?: number
    isActive?: boolean
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionTrackTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionTrackTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionTrackCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: AdmissionTrackTypeCreateNestedOneWithoutTracksInput
    program: ProgramCreateNestedOneWithoutAdmissionTracksInput
    applications?: ApplicationCreateNestedManyWithoutTrackInput
  }

  export type AdmissionTrackUncheckedCreateInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    typeId: string
    programId: string
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutTrackInput
  }

  export type AdmissionTrackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: AdmissionTrackTypeUpdateOneRequiredWithoutTracksNestedInput
    program?: ProgramUpdateOneRequiredWithoutAdmissionTracksNestedInput
    applications?: ApplicationUpdateManyWithoutTrackNestedInput
  }

  export type AdmissionTrackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutTrackNestedInput
  }

  export type AdmissionTrackCreateManyInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    typeId: string
    programId: string
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionTrackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionTrackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutApplicationsInput
    track?: AdmissionTrackCreateNestedOneWithoutApplicationsInput
    program: ProgramCreateNestedOneWithoutApplicationsInput
    documents?: DocumentCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    applicantId: string
    trackId?: string | null
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutApplicationsNestedInput
    track?: AdmissionTrackUpdateOneWithoutApplicationsNestedInput
    program?: ProgramUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: DocumentUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationCreateManyInput = {
    id?: string
    applicantId: string
    trackId?: string | null
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    type: string
    url: string
    uploadedAt?: Date | string
    application: ApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    applicationId: string
    type: string
    url: string
    uploadedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: ApplicationUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    applicationId: string
    type: string
    url: string
    uploadedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSlotCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    program?: ProgramCreateNestedOneWithoutInterviewSlotsInput
    interviewResults?: InterviewResultCreateNestedManyWithoutSlotInput
    interviewers?: InterviewSlotInterviewerCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotUncheckedCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    programId?: string | null
    interviewResults?: InterviewResultUncheckedCreateNestedManyWithoutSlotInput
    interviewers?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneWithoutInterviewSlotsNestedInput
    interviewResults?: InterviewResultUpdateManyWithoutSlotNestedInput
    interviewers?: InterviewSlotInterviewerUpdateManyWithoutSlotNestedInput
  }

  export type InterviewSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    interviewResults?: InterviewResultUncheckedUpdateManyWithoutSlotNestedInput
    interviewers?: InterviewSlotInterviewerUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type InterviewSlotCreateManyInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    programId?: string | null
  }

  export type InterviewSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewSlotInterviewerCreateInput = {
    id?: string
    slot: InterviewSlotCreateNestedOneWithoutInterviewersInput
    interviewer: PersonnelCreateNestedOneWithoutInterviewSlotsInput
  }

  export type InterviewSlotInterviewerUncheckedCreateInput = {
    id?: string
    slotId: string
    interviewerId: string
  }

  export type InterviewSlotInterviewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: InterviewSlotUpdateOneRequiredWithoutInterviewersNestedInput
    interviewer?: PersonnelUpdateOneRequiredWithoutInterviewSlotsNestedInput
  }

  export type InterviewSlotInterviewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    interviewerId?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewSlotInterviewerCreateManyInput = {
    id?: string
    slotId: string
    interviewerId: string
  }

  export type InterviewSlotInterviewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewSlotInterviewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    interviewerId?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewResultCreateInput = {
    id?: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
    application: ApplicationCreateNestedOneWithoutInterviewInput
    slot: InterviewSlotCreateNestedOneWithoutInterviewResultsInput
    feedback?: InterviewFeedbackCreateNestedOneWithoutInterviewResultInput
  }

  export type InterviewResultUncheckedCreateInput = {
    id?: string
    applicationId: string
    slotId: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
    feedback?: InterviewFeedbackUncheckedCreateNestedOneWithoutInterviewResultInput
  }

  export type InterviewResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    application?: ApplicationUpdateOneRequiredWithoutInterviewNestedInput
    slot?: InterviewSlotUpdateOneRequiredWithoutInterviewResultsNestedInput
    feedback?: InterviewFeedbackUpdateOneWithoutInterviewResultNestedInput
  }

  export type InterviewResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: InterviewFeedbackUncheckedUpdateOneWithoutInterviewResultNestedInput
  }

  export type InterviewResultCreateManyInput = {
    id?: string
    applicationId: string
    slotId: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
  }

  export type InterviewResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InterviewResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InterviewFeedbackCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    interviewResult: InterviewResultCreateNestedOneWithoutFeedbackInput
  }

  export type InterviewFeedbackUncheckedCreateInput = {
    id?: string
    interviewResultId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type InterviewFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviewResult?: InterviewResultUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type InterviewFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewResultId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewFeedbackCreateManyInput = {
    id?: string
    interviewResultId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type InterviewFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewResultId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGroupCreateInput = {
    id?: string
    name: string
    admissionYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutStudentGroupsInput
    advisor?: PersonnelCreateNestedOneWithoutAdvisorGroupsInput
    students?: StudentCreateNestedManyWithoutStudentGroupInput
    sections?: ClassSectionCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupUncheckedCreateInput = {
    id?: string
    name: string
    admissionYear: number
    programId: string
    advisorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutStudentGroupInput
    sections?: ClassSectionUncheckedCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutStudentGroupsNestedInput
    advisor?: PersonnelUpdateOneWithoutAdvisorGroupsNestedInput
    students?: StudentUpdateManyWithoutStudentGroupNestedInput
    sections?: ClassSectionUpdateManyWithoutStudentGroupsNestedInput
  }

  export type StudentGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutStudentGroupNestedInput
    sections?: ClassSectionUncheckedUpdateManyWithoutStudentGroupsNestedInput
  }

  export type StudentGroupCreateManyInput = {
    id?: string
    name: string
    admissionYear: number
    programId: string
    advisorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    studentGroup?: StudentGroupCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    studentGroup?: StudentGroupUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSectionCreateInput = {
    id?: string
    sectionNumber: string
    capacity: number
    course: CourseCreateNestedOneWithoutSectionsInput
    term: AcademicTermCreateNestedOneWithoutSectionsInput
    instructor?: PersonnelCreateNestedOneWithoutInstructedSectionsInput
    schedules?: ClassScheduleCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionUncheckedCreateInput = {
    id?: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonnelUpdateOneWithoutInstructedSectionsNestedInput
    schedules?: ClassScheduleUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    schedules?: ClassScheduleUncheckedUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionCreateManyInput = {
    id?: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
  }

  export type ClassSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassScheduleCreateInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    section: ClassSectionCreateNestedOneWithoutSchedulesInput
    room?: RoomCreateNestedOneWithoutSchedulesInput
    course?: CourseCreateNestedOneWithoutSchedulesInput
    instructor?: PersonnelCreateNestedOneWithoutTeachingSchedulesInput
    term?: AcademicTermCreateNestedOneWithoutSchedulesInput
  }

  export type ClassScheduleUncheckedCreateInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type ClassScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    section?: ClassSectionUpdateOneRequiredWithoutSchedulesNestedInput
    room?: RoomUpdateOneWithoutSchedulesNestedInput
    course?: CourseUpdateOneWithoutSchedulesNestedInput
    instructor?: PersonnelUpdateOneWithoutTeachingSchedulesNestedInput
    term?: AcademicTermUpdateOneWithoutSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassScheduleCreateManyInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type ClassScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentCreateInput = {
    id?: string
    grade?: string | null
    enrolledAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    section: ClassSectionCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    sectionId: string
    grade?: string | null
    enrolledAt?: Date | string
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    section?: ClassSectionUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    studentId: string
    sectionId: string
    grade?: string | null
    enrolledAt?: Date | string
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutInvoicesInput
    term: AcademicTermCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    studentId: string
    termId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    studentId: string
    termId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    slipUrl?: string | null
    paidAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    slipUrl?: string | null
    paidAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    slipUrl?: string | null
    paidAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    imageUrl?: string | null
    content: string
    target?: $Enums.AnnouncementTarget
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    imageUrl?: string | null
    content: string
    target?: $Enums.AnnouncementTarget
    isPublished?: boolean
    publishedAt?: Date | string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    target?: EnumAnnouncementTargetFieldUpdateOperationsInput | $Enums.AnnouncementTarget
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    target?: EnumAnnouncementTargetFieldUpdateOperationsInput | $Enums.AnnouncementTarget
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    imageUrl?: string | null
    content: string
    target?: $Enums.AnnouncementTarget
    isPublished?: boolean
    publishedAt?: Date | string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    target?: EnumAnnouncementTargetFieldUpdateOperationsInput | $Enums.AnnouncementTarget
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    target?: EnumAnnouncementTargetFieldUpdateOperationsInput | $Enums.AnnouncementTarget
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl: string
    linkUrl?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl: string
    linkUrl?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl: string
    linkUrl?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSettingsCreateInput = {
    id?: string
    botName?: string
    welcomeMessage?: string
    personality?: string
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type AiSettingsUncheckedCreateInput = {
    id?: string
    botName?: string
    welcomeMessage?: string
    personality?: string
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type AiSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botName?: StringFieldUpdateOperationsInput | string
    welcomeMessage?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botName?: StringFieldUpdateOperationsInput | string
    welcomeMessage?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSettingsCreateManyInput = {
    id?: string
    botName?: string
    welcomeMessage?: string
    personality?: string
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type AiSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    botName?: StringFieldUpdateOperationsInput | string
    welcomeMessage?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botName?: StringFieldUpdateOperationsInput | string
    welcomeMessage?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiKnowledgeBaseCreateInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiKnowledgeBaseUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiKnowledgeBaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiKnowledgeBaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiKnowledgeBaseCreateManyInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiKnowledgeBaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiKnowledgeBaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationCreateInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationCreateManyInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
    conversation: AiConversationCreateNestedOneWithoutMessagesInput
  }

  export type AiMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AiMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: AiConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AiMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateManyInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AiMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: HelpArticleCreateNestedManyWithoutCategoryInput
  }

  export type HelpCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: HelpArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type HelpCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: HelpArticleUpdateManyWithoutCategoryNestedInput
  }

  export type HelpCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: HelpArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type HelpCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleCreateInput = {
    id?: string
    title: string
    content: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: HelpCategoryCreateNestedOneWithoutArticlesInput
    author: UserCreateNestedOneWithoutHelpArticlesInput
  }

  export type HelpArticleUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    authorId: string
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HelpCategoryUpdateOneRequiredWithoutArticlesNestedInput
    author?: UserUpdateOneRequiredWithoutHelpArticlesNestedInput
  }

  export type HelpArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleCreateManyInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    authorId: string
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    id?: string
    universityName?: string
    universityNameTh?: string
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    backgroundColor?: string
    studentIdFormat?: string
    defaultLanguage?: string
    smtpHost?: string | null
    smtpPort?: number
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpSecure?: boolean
    smtpFromEmail?: string
    smtpFromName?: string
    updatedAt?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    universityName?: string
    universityNameTh?: string
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    backgroundColor?: string
    studentIdFormat?: string
    defaultLanguage?: string
    smtpHost?: string | null
    smtpPort?: number
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpSecure?: boolean
    smtpFromEmail?: string
    smtpFromName?: string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityName?: StringFieldUpdateOperationsInput | string
    universityNameTh?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    studentIdFormat?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpFromEmail?: StringFieldUpdateOperationsInput | string
    smtpFromName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityName?: StringFieldUpdateOperationsInput | string
    universityNameTh?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    studentIdFormat?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpFromEmail?: StringFieldUpdateOperationsInput | string
    smtpFromName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    universityName?: string
    universityNameTh?: string
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    backgroundColor?: string
    studentIdFormat?: string
    defaultLanguage?: string
    smtpHost?: string | null
    smtpPort?: number
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpSecure?: boolean
    smtpFromEmail?: string
    smtpFromName?: string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityName?: StringFieldUpdateOperationsInput | string
    universityNameTh?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    studentIdFormat?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpFromEmail?: StringFieldUpdateOperationsInput | string
    smtpFromName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityName?: StringFieldUpdateOperationsInput | string
    universityNameTh?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    studentIdFormat?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpFromEmail?: StringFieldUpdateOperationsInput | string
    smtpFromName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateInput = {
    id?: string
    action: string
    details?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type SystemLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    details?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    details?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateInput = {
    id?: string
    key: string
    th: string
    en: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUncheckedCreateInput = {
    id?: string
    key: string
    th: string
    en: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    th?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    th?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateManyInput = {
    id?: string
    key: string
    th: string
    en: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    th?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    th?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ClassScheduleCreateNestedManyWithoutRoomInput
    examSlots?: ExamSlotCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutRoomInput
    examSlots?: ExamSlotUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ClassScheduleUpdateManyWithoutRoomNestedInput
    examSlots?: ExamSlotUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
    examSlots?: ExamSlotUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScheduleCreateInput = {
    id?: string
    section: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutExamSchedulesInput
    term: AcademicTermCreateNestedOneWithoutExamSchedulesInput
    examSlots?: ExamSlotCreateNestedManyWithoutExamScheduleInput
  }

  export type ExamScheduleUncheckedCreateInput = {
    id?: string
    courseId: string
    section: string
    termId: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examSlots?: ExamSlotUncheckedCreateNestedManyWithoutExamScheduleInput
  }

  export type ExamScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutExamSchedulesNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutExamSchedulesNestedInput
    examSlots?: ExamSlotUpdateManyWithoutExamScheduleNestedInput
  }

  export type ExamScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSlots?: ExamSlotUncheckedUpdateManyWithoutExamScheduleNestedInput
  }

  export type ExamScheduleCreateManyInput = {
    id?: string
    courseId: string
    section: string
    termId: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSlotCreateInput = {
    id?: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examSchedule: ExamScheduleCreateNestedOneWithoutExamSlotsInput
    room: RoomCreateNestedOneWithoutExamSlotsInput
    proctors?: ExamProctorCreateNestedManyWithoutExamSlotInput
  }

  export type ExamSlotUncheckedCreateInput = {
    id?: string
    examScheduleId: string
    roomId: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proctors?: ExamProctorUncheckedCreateNestedManyWithoutExamSlotInput
  }

  export type ExamSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSchedule?: ExamScheduleUpdateOneRequiredWithoutExamSlotsNestedInput
    room?: RoomUpdateOneRequiredWithoutExamSlotsNestedInput
    proctors?: ExamProctorUpdateManyWithoutExamSlotNestedInput
  }

  export type ExamSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examScheduleId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proctors?: ExamProctorUncheckedUpdateManyWithoutExamSlotNestedInput
  }

  export type ExamSlotCreateManyInput = {
    id?: string
    examScheduleId: string
    roomId: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examScheduleId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamProctorCreateInput = {
    id?: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examSlot: ExamSlotCreateNestedOneWithoutProctorsInput
    proctor: PersonnelCreateNestedOneWithoutProctorDutiesInput
  }

  export type ExamProctorUncheckedCreateInput = {
    id?: string
    examSlotId: string
    proctorId: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamProctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSlot?: ExamSlotUpdateOneRequiredWithoutProctorsNestedInput
    proctor?: PersonnelUpdateOneRequiredWithoutProctorDutiesNestedInput
  }

  export type ExamProctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examSlotId?: StringFieldUpdateOperationsInput | string
    proctorId?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamProctorCreateManyInput = {
    id?: string
    examSlotId: string
    proctorId: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamProctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamProctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examSlotId?: StringFieldUpdateOperationsInput | string
    proctorId?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingLoadCreateInput = {
    id?: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor: PersonnelCreateNestedOneWithoutTeachingLoadsInput
    term: AcademicTermCreateNestedOneWithoutTeachingLoadsInput
  }

  export type TeachingLoadUncheckedCreateInput = {
    id?: string
    instructorId: string
    termId: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingLoadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: PersonnelUpdateOneRequiredWithoutTeachingLoadsNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutTeachingLoadsNestedInput
  }

  export type TeachingLoadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingLoadCreateManyInput = {
    id?: string
    instructorId: string
    termId: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingLoadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingLoadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateInput = {
    id?: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLeaveRequestsInput
    reviewer?: PersonnelCreateNestedOneWithoutReviewedLeaveRequestsInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    studentId: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLeaveRequestsNestedInput
    reviewer?: PersonnelUpdateOneWithoutReviewedLeaveRequestsNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateManyInput = {
    id?: string
    studentId: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PersonnelNullableRelationFilter = {
    is?: PersonnelWhereInput | null
    isNot?: PersonnelWhereInput | null
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ApplicantNullableRelationFilter = {
    is?: ApplicantWhereInput | null
    isNot?: ApplicantWhereInput | null
  }

  export type SystemLogListRelationFilter = {
    every?: SystemLogWhereInput
    some?: SystemLogWhereInput
    none?: SystemLogWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type HelpArticleListRelationFilter = {
    every?: HelpArticleWhereInput
    some?: HelpArticleWhereInput
    none?: HelpArticleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SystemLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FacultyNullableRelationFilter = {
    is?: FacultyWhereInput | null
    isNot?: FacultyWhereInput | null
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type ClassSectionListRelationFilter = {
    every?: ClassSectionWhereInput
    some?: ClassSectionWhereInput
    none?: ClassSectionWhereInput
  }

  export type InterviewSlotInterviewerListRelationFilter = {
    every?: InterviewSlotInterviewerWhereInput
    some?: InterviewSlotInterviewerWhereInput
    none?: InterviewSlotInterviewerWhereInput
  }

  export type ClassScheduleListRelationFilter = {
    every?: ClassScheduleWhereInput
    some?: ClassScheduleWhereInput
    none?: ClassScheduleWhereInput
  }

  export type TeachingLoadListRelationFilter = {
    every?: TeachingLoadWhereInput
    some?: TeachingLoadWhereInput
    none?: TeachingLoadWhereInput
  }

  export type ExamProctorListRelationFilter = {
    every?: ExamProctorWhereInput
    some?: ExamProctorWhereInput
    none?: ExamProctorWhereInput
  }

  export type StudentGroupListRelationFilter = {
    every?: StudentGroupWhereInput
    some?: StudentGroupWhereInput
    none?: StudentGroupWhereInput
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type ClassSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewSlotInterviewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeachingLoadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamProctorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonnelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    title?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    bio?: SortOrder
    expertise?: SortOrder
    education?: SortOrder
    publications?: SortOrder
    officeHours?: SortOrder
    officeLocation?: SortOrder
    isProfilePublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonnelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    title?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    bio?: SortOrder
    expertise?: SortOrder
    education?: SortOrder
    publications?: SortOrder
    officeHours?: SortOrder
    officeLocation?: SortOrder
    isProfilePublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonnelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    title?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    bio?: SortOrder
    expertise?: SortOrder
    education?: SortOrder
    publications?: SortOrder
    officeHours?: SortOrder
    officeLocation?: SortOrder
    isProfilePublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type PersonnelListRelationFilter = {
    every?: PersonnelWhereInput
    some?: PersonnelWhereInput
    none?: PersonnelWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonnelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
  }

  export type FacultyRelationFilter = {
    is?: FacultyWhereInput
    isNot?: FacultyWhereInput
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    facultyId?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    facultyId?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    facultyId?: SortOrder
  }

  export type EnumDegreeLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeLevel | EnumDegreeLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeLevel[]
    notIn?: $Enums.DegreeLevel[]
    not?: NestedEnumDegreeLevelFilter<$PrismaModel> | $Enums.DegreeLevel
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DepartmentRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type InterviewSlotListRelationFilter = {
    every?: InterviewSlotWhereInput
    some?: InterviewSlotWhereInput
    none?: InterviewSlotWhereInput
  }

  export type ProgramCourseListRelationFilter = {
    every?: ProgramCourseWhereInput
    some?: ProgramCourseWhereInput
    none?: ProgramCourseWhereInput
  }

  export type AdmissionTrackListRelationFilter = {
    every?: AdmissionTrackWhereInput
    some?: AdmissionTrackWhereInput
    none?: AdmissionTrackWhereInput
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionTrackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    degreeLevel?: SortOrder
    description?: SortOrder
    isAcceptingApplications?: SortOrder
    credits?: SortOrder
    duration?: SortOrder
    objectives?: SortOrder
    structure?: SortOrder
    admissionRequirements?: SortOrder
    careerOpportunities?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    degreeLevel?: SortOrder
    description?: SortOrder
    isAcceptingApplications?: SortOrder
    credits?: SortOrder
    duration?: SortOrder
    objectives?: SortOrder
    structure?: SortOrder
    admissionRequirements?: SortOrder
    careerOpportunities?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    degreeLevel?: SortOrder
    description?: SortOrder
    isAcceptingApplications?: SortOrder
    credits?: SortOrder
    duration?: SortOrder
    objectives?: SortOrder
    structure?: SortOrder
    admissionRequirements?: SortOrder
    careerOpportunities?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type EnumDegreeLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeLevel | EnumDegreeLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeLevel[]
    notIn?: $Enums.DegreeLevel[]
    not?: NestedEnumDegreeLevelWithAggregatesFilter<$PrismaModel> | $Enums.DegreeLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDegreeLevelFilter<$PrismaModel>
    _max?: NestedEnumDegreeLevelFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ExamScheduleListRelationFilter = {
    every?: ExamScheduleWhereInput
    some?: ExamScheduleWhereInput
    none?: ExamScheduleWhereInput
  }

  export type ExamScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    learningOutcomes?: SortOrder
    syllabusUrl?: SortOrder
    minYearLevel?: SortOrder
    allowedStudentTypes?: SortOrder
    allowedPrograms?: SortOrder
    minGpax?: SortOrder
    prerequisiteCourses?: SortOrder
    maxEnrollment?: SortOrder
    requiresApproval?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    credits?: SortOrder
    minYearLevel?: SortOrder
    minGpax?: SortOrder
    maxEnrollment?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    learningOutcomes?: SortOrder
    syllabusUrl?: SortOrder
    minYearLevel?: SortOrder
    allowedStudentTypes?: SortOrder
    allowedPrograms?: SortOrder
    minGpax?: SortOrder
    prerequisiteCourses?: SortOrder
    maxEnrollment?: SortOrder
    requiresApproval?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    learningOutcomes?: SortOrder
    syllabusUrl?: SortOrder
    minYearLevel?: SortOrder
    allowedStudentTypes?: SortOrder
    allowedPrograms?: SortOrder
    minGpax?: SortOrder
    prerequisiteCourses?: SortOrder
    maxEnrollment?: SortOrder
    requiresApproval?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    credits?: SortOrder
    minYearLevel?: SortOrder
    minGpax?: SortOrder
    maxEnrollment?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProgramRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type ProgramCourseProgramIdCourseIdCompoundUniqueInput = {
    programId: string
    courseId: string
  }

  export type ProgramCourseCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    courseId?: SortOrder
    isRequired?: SortOrder
    semester?: SortOrder
  }

  export type ProgramCourseAvgOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type ProgramCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    courseId?: SortOrder
    isRequired?: SortOrder
    semester?: SortOrder
  }

  export type ProgramCourseMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    courseId?: SortOrder
    isRequired?: SortOrder
    semester?: SortOrder
  }

  export type ProgramCourseSumOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicTermYearSemesterCompoundUniqueInput = {
    year: number
    semester: number
  }

  export type AcademicTermCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
  }

  export type AcademicTermAvgOrderByAggregateInput = {
    year?: SortOrder
    semester?: SortOrder
  }

  export type AcademicTermMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
  }

  export type AcademicTermMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
  }

  export type AcademicTermSumOrderByAggregateInput = {
    year?: SortOrder
    semester?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EducationHistoryListRelationFilter = {
    every?: EducationHistoryWhereInput
    some?: EducationHistoryWhereInput
    none?: EducationHistoryWhereInput
  }

  export type EducationHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    nationality?: SortOrder
    title?: SortOrder
    citizenId?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    zipCode?: SortOrder
    profileImageUrl?: SortOrder
  }

  export type ApplicantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    nationality?: SortOrder
    title?: SortOrder
    citizenId?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    zipCode?: SortOrder
    profileImageUrl?: SortOrder
  }

  export type ApplicantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    nationality?: SortOrder
    title?: SortOrder
    citizenId?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    zipCode?: SortOrder
    profileImageUrl?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type ApplicantRelationFilter = {
    is?: ApplicantWhereInput
    isNot?: ApplicantWhereInput
  }

  export type EducationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    level?: SortOrder
    degreeName?: SortOrder
    institution?: SortOrder
    gpa?: SortOrder
    graduationYear?: SortOrder
  }

  export type EducationHistoryAvgOrderByAggregateInput = {
    graduationYear?: SortOrder
  }

  export type EducationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    level?: SortOrder
    degreeName?: SortOrder
    institution?: SortOrder
    gpa?: SortOrder
    graduationYear?: SortOrder
  }

  export type EducationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    level?: SortOrder
    degreeName?: SortOrder
    institution?: SortOrder
    gpa?: SortOrder
    graduationYear?: SortOrder
  }

  export type EducationHistorySumOrderByAggregateInput = {
    graduationYear?: SortOrder
  }

  export type AdmissionTrackTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionTrackTypeAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type AdmissionTrackTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionTrackTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionTrackTypeSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type AdmissionTrackTypeRelationFilter = {
    is?: AdmissionTrackTypeWhereInput
    isNot?: AdmissionTrackTypeWhereInput
  }

  export type AdmissionTrackCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    programId?: SortOrder
    academicYear?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    announceDate?: SortOrder
    totalSeats?: SortOrder
    filledSeats?: SortOrder
    reservedSeats?: SortOrder
    enableWaitlist?: SortOrder
    requirements?: SortOrder
    applicationFee?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionTrackAvgOrderByAggregateInput = {
    totalSeats?: SortOrder
    filledSeats?: SortOrder
    reservedSeats?: SortOrder
    applicationFee?: SortOrder
    displayOrder?: SortOrder
  }

  export type AdmissionTrackMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    programId?: SortOrder
    academicYear?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    announceDate?: SortOrder
    totalSeats?: SortOrder
    filledSeats?: SortOrder
    reservedSeats?: SortOrder
    enableWaitlist?: SortOrder
    requirements?: SortOrder
    applicationFee?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionTrackMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    programId?: SortOrder
    academicYear?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    announceDate?: SortOrder
    totalSeats?: SortOrder
    filledSeats?: SortOrder
    reservedSeats?: SortOrder
    enableWaitlist?: SortOrder
    requirements?: SortOrder
    applicationFee?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionTrackSumOrderByAggregateInput = {
    totalSeats?: SortOrder
    filledSeats?: SortOrder
    reservedSeats?: SortOrder
    applicationFee?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type AdmissionTrackNullableRelationFilter = {
    is?: AdmissionTrackWhereInput | null
    isNot?: AdmissionTrackWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type InterviewResultNullableRelationFilter = {
    is?: InterviewResultWhereInput | null
    isNot?: InterviewResultWhereInput | null
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    trackId?: SortOrder
    programId?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    trackId?: SortOrder
    programId?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    trackId?: SortOrder
    programId?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type ApplicationRelationFilter = {
    is?: ApplicationWhereInput
    isNot?: ApplicationWhereInput
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProgramNullableRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type InterviewResultListRelationFilter = {
    every?: InterviewResultWhereInput
    some?: InterviewResultWhereInput
    none?: InterviewResultWhereInput
  }

  export type InterviewResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewSlotCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    coordinatorName?: SortOrder
    coordinatorPhone?: SortOrder
    description?: SortOrder
    programId?: SortOrder
  }

  export type InterviewSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    coordinatorName?: SortOrder
    coordinatorPhone?: SortOrder
    description?: SortOrder
    programId?: SortOrder
  }

  export type InterviewSlotMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    coordinatorName?: SortOrder
    coordinatorPhone?: SortOrder
    description?: SortOrder
    programId?: SortOrder
  }

  export type InterviewSlotRelationFilter = {
    is?: InterviewSlotWhereInput
    isNot?: InterviewSlotWhereInput
  }

  export type PersonnelRelationFilter = {
    is?: PersonnelWhereInput
    isNot?: PersonnelWhereInput
  }

  export type InterviewSlotInterviewerSlotIdInterviewerIdCompoundUniqueInput = {
    slotId: string
    interviewerId: string
  }

  export type InterviewSlotInterviewerCountOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
    interviewerId?: SortOrder
  }

  export type InterviewSlotInterviewerMaxOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
    interviewerId?: SortOrder
  }

  export type InterviewSlotInterviewerMinOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
    interviewerId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type InterviewFeedbackNullableRelationFilter = {
    is?: InterviewFeedbackWhereInput | null
    isNot?: InterviewFeedbackWhereInput | null
  }

  export type InterviewResultCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    slotId?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    isPassed?: SortOrder
    confirmedAt?: SortOrder
    rescheduleRequested?: SortOrder
    rescheduleReason?: SortOrder
    checkedInAt?: SortOrder
  }

  export type InterviewResultAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type InterviewResultMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    slotId?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    isPassed?: SortOrder
    confirmedAt?: SortOrder
    rescheduleRequested?: SortOrder
    rescheduleReason?: SortOrder
    checkedInAt?: SortOrder
  }

  export type InterviewResultMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    slotId?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    isPassed?: SortOrder
    confirmedAt?: SortOrder
    rescheduleRequested?: SortOrder
    rescheduleReason?: SortOrder
    checkedInAt?: SortOrder
  }

  export type InterviewResultSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type InterviewResultRelationFilter = {
    is?: InterviewResultWhereInput
    isNot?: InterviewResultWhereInput
  }

  export type InterviewFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    interviewResultId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewFeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type InterviewFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    interviewResultId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    interviewResultId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewFeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type StudentGroupProgramIdAdmissionYearNameCompoundUniqueInput = {
    programId: string
    admissionYear: number
    name: string
  }

  export type StudentGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    admissionYear?: SortOrder
    programId?: SortOrder
    advisorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentGroupAvgOrderByAggregateInput = {
    admissionYear?: SortOrder
  }

  export type StudentGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    admissionYear?: SortOrder
    programId?: SortOrder
    advisorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    admissionYear?: SortOrder
    programId?: SortOrder
    advisorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentGroupSumOrderByAggregateInput = {
    admissionYear?: SortOrder
  }

  export type EnumStudentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeFilter<$PrismaModel> | $Enums.StudentType
  }

  export type EnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[]
    notIn?: $Enums.StudentStatus[]
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StudentGroupNullableRelationFilter = {
    is?: StudentGroupWhereInput | null
    isNot?: StudentGroupWhereInput | null
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    nationality?: SortOrder
    citizenId?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    zipCode?: SortOrder
    programId?: SortOrder
    studentType?: SortOrder
    status?: SortOrder
    gpax?: SortOrder
    bio?: SortOrder
    interests?: SortOrder
    skills?: SortOrder
    socialLinks?: SortOrder
    isProfilePublic?: SortOrder
    showGPA?: SortOrder
    admissionYear?: SortOrder
    studentGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    gpax?: SortOrder
    admissionYear?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    nationality?: SortOrder
    citizenId?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    zipCode?: SortOrder
    programId?: SortOrder
    studentType?: SortOrder
    status?: SortOrder
    gpax?: SortOrder
    bio?: SortOrder
    interests?: SortOrder
    skills?: SortOrder
    socialLinks?: SortOrder
    isProfilePublic?: SortOrder
    showGPA?: SortOrder
    admissionYear?: SortOrder
    studentGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    nationality?: SortOrder
    citizenId?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    profileImageUrl?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    zipCode?: SortOrder
    programId?: SortOrder
    studentType?: SortOrder
    status?: SortOrder
    gpax?: SortOrder
    bio?: SortOrder
    interests?: SortOrder
    skills?: SortOrder
    socialLinks?: SortOrder
    isProfilePublic?: SortOrder
    showGPA?: SortOrder
    admissionYear?: SortOrder
    studentGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    gpax?: SortOrder
    admissionYear?: SortOrder
  }

  export type EnumStudentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeWithAggregatesFilter<$PrismaModel> | $Enums.StudentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentTypeFilter<$PrismaModel>
    _max?: NestedEnumStudentTypeFilter<$PrismaModel>
  }

  export type EnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[]
    notIn?: $Enums.StudentStatus[]
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AcademicTermRelationFilter = {
    is?: AcademicTermWhereInput
    isNot?: AcademicTermWhereInput
  }

  export type ClassSectionCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    termId?: SortOrder
    sectionNumber?: SortOrder
    capacity?: SortOrder
    instructorId?: SortOrder
  }

  export type ClassSectionAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type ClassSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    termId?: SortOrder
    sectionNumber?: SortOrder
    capacity?: SortOrder
    instructorId?: SortOrder
  }

  export type ClassSectionMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    termId?: SortOrder
    sectionNumber?: SortOrder
    capacity?: SortOrder
    instructorId?: SortOrder
  }

  export type ClassSectionSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type EnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type ClassSectionRelationFilter = {
    is?: ClassSectionWhereInput
    isNot?: ClassSectionWhereInput
  }

  export type RoomNullableRelationFilter = {
    is?: RoomWhereInput | null
    isNot?: RoomWhereInput | null
  }

  export type CourseNullableRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type AcademicTermNullableRelationFilter = {
    is?: AcademicTermWhereInput | null
    isNot?: AcademicTermWhereInput | null
  }

  export type ClassScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    roomId?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
  }

  export type ClassScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    roomId?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
  }

  export type ClassScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    roomId?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
  }

  export type EnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type EnrollmentStudentIdSectionIdCompoundUniqueInput = {
    studentId: string
    sectionId: string
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    grade?: SortOrder
    enrolledAt?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    grade?: SortOrder
    enrolledAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    grade?: SortOrder
    enrolledAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[]
    notIn?: $Enums.InvoiceStatus[]
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    termId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    termId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    termId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[]
    notIn?: $Enums.InvoiceStatus[]
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    slipUrl?: SortOrder
    paidAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    slipUrl?: SortOrder
    paidAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    slipUrl?: SortOrder
    paidAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumAnnouncementTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementTarget | EnumAnnouncementTargetFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementTarget[]
    notIn?: $Enums.AnnouncementTarget[]
    not?: NestedEnumAnnouncementTargetFilter<$PrismaModel> | $Enums.AnnouncementTarget
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    content?: SortOrder
    target?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    content?: SortOrder
    target?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    content?: SortOrder
    target?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnnouncementTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementTarget | EnumAnnouncementTargetFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementTarget[]
    notIn?: $Enums.AnnouncementTarget[]
    not?: NestedEnumAnnouncementTargetWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementTargetFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementTargetFilter<$PrismaModel>
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkUrl?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkUrl?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkUrl?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AiSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    botName?: SortOrder
    welcomeMessage?: SortOrder
    personality?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    botName?: SortOrder
    welcomeMessage?: SortOrder
    personality?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    botName?: SortOrder
    welcomeMessage?: SortOrder
    personality?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiKnowledgeBaseCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiKnowledgeBaseMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiKnowledgeBaseMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiMessageListRelationFilter = {
    every?: AiMessageWhereInput
    some?: AiMessageWhereInput
    none?: AiMessageWhereInput
  }

  export type AiMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationRelationFilter = {
    is?: AiConversationWhereInput
    isNot?: AiConversationWhereInput
  }

  export type AiMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type HelpCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HelpCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumHelpArticleVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpArticleVisibility | EnumHelpArticleVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.HelpArticleVisibility[]
    notIn?: $Enums.HelpArticleVisibility[]
    not?: NestedEnumHelpArticleVisibilityFilter<$PrismaModel> | $Enums.HelpArticleVisibility
  }

  export type HelpCategoryRelationFilter = {
    is?: HelpCategoryWhereInput
    isNot?: HelpCategoryWhereInput
  }

  export type HelpArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    visibility?: SortOrder
    isPublished?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpArticleAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type HelpArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    visibility?: SortOrder
    isPublished?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    visibility?: SortOrder
    isPublished?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpArticleSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type EnumHelpArticleVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpArticleVisibility | EnumHelpArticleVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.HelpArticleVisibility[]
    notIn?: $Enums.HelpArticleVisibility[]
    not?: NestedEnumHelpArticleVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.HelpArticleVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHelpArticleVisibilityFilter<$PrismaModel>
    _max?: NestedEnumHelpArticleVisibilityFilter<$PrismaModel>
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    universityName?: SortOrder
    universityNameTh?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    backgroundColor?: SortOrder
    studentIdFormat?: SortOrder
    defaultLanguage?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpSecure?: SortOrder
    smtpFromEmail?: SortOrder
    smtpFromName?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsAvgOrderByAggregateInput = {
    smtpPort?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    universityName?: SortOrder
    universityNameTh?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    backgroundColor?: SortOrder
    studentIdFormat?: SortOrder
    defaultLanguage?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpSecure?: SortOrder
    smtpFromEmail?: SortOrder
    smtpFromName?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    universityName?: SortOrder
    universityNameTh?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    backgroundColor?: SortOrder
    studentIdFormat?: SortOrder
    defaultLanguage?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpSecure?: SortOrder
    smtpFromEmail?: SortOrder
    smtpFromName?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsSumOrderByAggregateInput = {
    smtpPort?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type TranslationCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    th?: SortOrder
    en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    th?: SortOrder
    en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranslationMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    th?: SortOrder
    en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type ExamSlotListRelationFilter = {
    every?: ExamSlotWhereInput
    some?: ExamSlotWhereInput
    none?: ExamSlotWhereInput
  }

  export type ExamSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    building?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    roomType?: SortOrder
    facilities?: SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    floor?: SortOrder
    capacity?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    building?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    roomType?: SortOrder
    facilities?: SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    building?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    roomType?: SortOrder
    facilities?: SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    floor?: SortOrder
    capacity?: SortOrder
  }

  export type EnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type EnumExamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamType[]
    notIn?: $Enums.ExamType[]
    not?: NestedEnumExamTypeFilter<$PrismaModel> | $Enums.ExamType
  }

  export type EnumExamFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamFormat | EnumExamFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExamFormat[]
    notIn?: $Enums.ExamFormat[]
    not?: NestedEnumExamFormatFilter<$PrismaModel> | $Enums.ExamFormat
  }

  export type ExamScheduleCourseIdSectionTermIdExamTypeCompoundUniqueInput = {
    courseId: string
    section: string
    termId: string
    examType: $Enums.ExamType
  }

  export type ExamScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    section?: SortOrder
    termId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    examFormat?: SortOrder
    instructions?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamScheduleAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ExamScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    section?: SortOrder
    termId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    examFormat?: SortOrder
    instructions?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    section?: SortOrder
    termId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    examFormat?: SortOrder
    instructions?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamScheduleSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumExamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamType[]
    notIn?: $Enums.ExamType[]
    not?: NestedEnumExamTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExamType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamTypeFilter<$PrismaModel>
    _max?: NestedEnumExamTypeFilter<$PrismaModel>
  }

  export type EnumExamFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamFormat | EnumExamFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExamFormat[]
    notIn?: $Enums.ExamFormat[]
    not?: NestedEnumExamFormatWithAggregatesFilter<$PrismaModel> | $Enums.ExamFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamFormatFilter<$PrismaModel>
    _max?: NestedEnumExamFormatFilter<$PrismaModel>
  }

  export type ExamScheduleRelationFilter = {
    is?: ExamScheduleWhereInput
    isNot?: ExamScheduleWhereInput
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type ExamSlotCountOrderByAggregateInput = {
    id?: SortOrder
    examScheduleId?: SortOrder
    roomId?: SortOrder
    capacity?: SortOrder
    assignedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSlotAvgOrderByAggregateInput = {
    capacity?: SortOrder
    assignedCount?: SortOrder
  }

  export type ExamSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    examScheduleId?: SortOrder
    roomId?: SortOrder
    capacity?: SortOrder
    assignedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSlotMinOrderByAggregateInput = {
    id?: SortOrder
    examScheduleId?: SortOrder
    roomId?: SortOrder
    capacity?: SortOrder
    assignedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSlotSumOrderByAggregateInput = {
    capacity?: SortOrder
    assignedCount?: SortOrder
  }

  export type EnumProctorRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProctorRole | EnumProctorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProctorRole[]
    notIn?: $Enums.ProctorRole[]
    not?: NestedEnumProctorRoleFilter<$PrismaModel> | $Enums.ProctorRole
  }

  export type ExamSlotRelationFilter = {
    is?: ExamSlotWhereInput
    isNot?: ExamSlotWhereInput
  }

  export type ExamProctorExamSlotIdProctorIdCompoundUniqueInput = {
    examSlotId: string
    proctorId: string
  }

  export type ExamProctorCountOrderByAggregateInput = {
    id?: SortOrder
    examSlotId?: SortOrder
    proctorId?: SortOrder
    role?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamProctorMaxOrderByAggregateInput = {
    id?: SortOrder
    examSlotId?: SortOrder
    proctorId?: SortOrder
    role?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamProctorMinOrderByAggregateInput = {
    id?: SortOrder
    examSlotId?: SortOrder
    proctorId?: SortOrder
    role?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProctorRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProctorRole | EnumProctorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProctorRole[]
    notIn?: $Enums.ProctorRole[]
    not?: NestedEnumProctorRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProctorRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProctorRoleFilter<$PrismaModel>
    _max?: NestedEnumProctorRoleFilter<$PrismaModel>
  }

  export type TeachingLoadInstructorIdTermIdCompoundUniqueInput = {
    instructorId: string
    termId: string
  }

  export type TeachingLoadCountOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
    lectureHours?: SortOrder
    labHours?: SortOrder
    totalHours?: SortOrder
    courseCount?: SortOrder
    isApproved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeachingLoadAvgOrderByAggregateInput = {
    lectureHours?: SortOrder
    labHours?: SortOrder
    totalHours?: SortOrder
    courseCount?: SortOrder
  }

  export type TeachingLoadMaxOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
    lectureHours?: SortOrder
    labHours?: SortOrder
    totalHours?: SortOrder
    courseCount?: SortOrder
    isApproved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeachingLoadMinOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    termId?: SortOrder
    lectureHours?: SortOrder
    labHours?: SortOrder
    totalHours?: SortOrder
    courseCount?: SortOrder
    isApproved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeachingLoadSumOrderByAggregateInput = {
    lectureHours?: SortOrder
    labHours?: SortOrder
    totalHours?: SortOrder
    courseCount?: SortOrder
  }

  export type EnumLeaveRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveRequestStatus | EnumLeaveRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveRequestStatus[]
    notIn?: $Enums.LeaveRequestStatus[]
    not?: NestedEnumLeaveRequestStatusFilter<$PrismaModel> | $Enums.LeaveRequestStatus
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNote?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNote?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNote?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeaveRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveRequestStatus | EnumLeaveRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveRequestStatus[]
    notIn?: $Enums.LeaveRequestStatus[]
    not?: NestedEnumLeaveRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveRequestStatusFilter<$PrismaModel>
  }

  export type PersonnelCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonnelCreateWithoutUserInput, PersonnelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutUserInput
    connect?: PersonnelWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ApplicantCreateNestedOneWithoutUserInput = {
    create?: XOR<ApplicantCreateWithoutUserInput, ApplicantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutUserInput
    connect?: ApplicantWhereUniqueInput
  }

  export type SystemLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type HelpArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<HelpArticleCreateWithoutAuthorInput, HelpArticleUncheckedCreateWithoutAuthorInput> | HelpArticleCreateWithoutAuthorInput[] | HelpArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutAuthorInput | HelpArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: HelpArticleCreateManyAuthorInputEnvelope
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
  }

  export type PersonnelUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonnelCreateWithoutUserInput, PersonnelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutUserInput
    connect?: PersonnelWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ApplicantUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ApplicantCreateWithoutUserInput, ApplicantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutUserInput
    connect?: ApplicantWhereUniqueInput
  }

  export type SystemLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type HelpArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<HelpArticleCreateWithoutAuthorInput, HelpArticleUncheckedCreateWithoutAuthorInput> | HelpArticleCreateWithoutAuthorInput[] | HelpArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutAuthorInput | HelpArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: HelpArticleCreateManyAuthorInputEnvelope
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonnelUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonnelCreateWithoutUserInput, PersonnelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutUserInput
    upsert?: PersonnelUpsertWithoutUserInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutUserInput, PersonnelUpdateWithoutUserInput>, PersonnelUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ApplicantUpdateOneWithoutUserNestedInput = {
    create?: XOR<ApplicantCreateWithoutUserInput, ApplicantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutUserInput
    upsert?: ApplicantUpsertWithoutUserInput
    disconnect?: ApplicantWhereInput | boolean
    delete?: ApplicantWhereInput | boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutUserInput, ApplicantUpdateWithoutUserInput>, ApplicantUncheckedUpdateWithoutUserInput>
  }

  export type SystemLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAuthorInput | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAuthorInput | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAuthorInput | AnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type HelpArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<HelpArticleCreateWithoutAuthorInput, HelpArticleUncheckedCreateWithoutAuthorInput> | HelpArticleCreateWithoutAuthorInput[] | HelpArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutAuthorInput | HelpArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: HelpArticleUpsertWithWhereUniqueWithoutAuthorInput | HelpArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: HelpArticleCreateManyAuthorInputEnvelope
    set?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    disconnect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    delete?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    update?: HelpArticleUpdateWithWhereUniqueWithoutAuthorInput | HelpArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: HelpArticleUpdateManyWithWhereWithoutAuthorInput | HelpArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
  }

  export type PersonnelUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonnelCreateWithoutUserInput, PersonnelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutUserInput
    upsert?: PersonnelUpsertWithoutUserInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutUserInput, PersonnelUpdateWithoutUserInput>, PersonnelUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ApplicantUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ApplicantCreateWithoutUserInput, ApplicantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutUserInput
    upsert?: ApplicantUpsertWithoutUserInput
    disconnect?: ApplicantWhereInput | boolean
    delete?: ApplicantWhereInput | boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutUserInput, ApplicantUpdateWithoutUserInput>, ApplicantUncheckedUpdateWithoutUserInput>
  }

  export type SystemLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAuthorInput | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAuthorInput | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAuthorInput | AnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type HelpArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<HelpArticleCreateWithoutAuthorInput, HelpArticleUncheckedCreateWithoutAuthorInput> | HelpArticleCreateWithoutAuthorInput[] | HelpArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutAuthorInput | HelpArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: HelpArticleUpsertWithWhereUniqueWithoutAuthorInput | HelpArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: HelpArticleCreateManyAuthorInputEnvelope
    set?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    disconnect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    delete?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    update?: HelpArticleUpdateWithWhereUniqueWithoutAuthorInput | HelpArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: HelpArticleUpdateManyWithWhereWithoutAuthorInput | HelpArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPersonnelProfileInput = {
    create?: XOR<UserCreateWithoutPersonnelProfileInput, UserUncheckedCreateWithoutPersonnelProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonnelProfileInput
    connect?: UserWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutPersonnelInput = {
    create?: XOR<FacultyCreateWithoutPersonnelInput, FacultyUncheckedCreateWithoutPersonnelInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutPersonnelInput
    connect?: FacultyWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutPersonnelInput = {
    create?: XOR<DepartmentCreateWithoutPersonnelInput, DepartmentUncheckedCreateWithoutPersonnelInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPersonnelInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ClassSectionCreateNestedManyWithoutInstructorInput = {
    create?: XOR<ClassSectionCreateWithoutInstructorInput, ClassSectionUncheckedCreateWithoutInstructorInput> | ClassSectionCreateWithoutInstructorInput[] | ClassSectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutInstructorInput | ClassSectionCreateOrConnectWithoutInstructorInput[]
    createMany?: ClassSectionCreateManyInstructorInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput> | InterviewSlotInterviewerCreateWithoutInterviewerInput[] | InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput | InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput[]
    createMany?: InterviewSlotInterviewerCreateManyInterviewerInputEnvelope
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
  }

  export type ClassScheduleCreateNestedManyWithoutInstructorInput = {
    create?: XOR<ClassScheduleCreateWithoutInstructorInput, ClassScheduleUncheckedCreateWithoutInstructorInput> | ClassScheduleCreateWithoutInstructorInput[] | ClassScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutInstructorInput | ClassScheduleCreateOrConnectWithoutInstructorInput[]
    createMany?: ClassScheduleCreateManyInstructorInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type TeachingLoadCreateNestedManyWithoutInstructorInput = {
    create?: XOR<TeachingLoadCreateWithoutInstructorInput, TeachingLoadUncheckedCreateWithoutInstructorInput> | TeachingLoadCreateWithoutInstructorInput[] | TeachingLoadUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutInstructorInput | TeachingLoadCreateOrConnectWithoutInstructorInput[]
    createMany?: TeachingLoadCreateManyInstructorInputEnvelope
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
  }

  export type ExamProctorCreateNestedManyWithoutProctorInput = {
    create?: XOR<ExamProctorCreateWithoutProctorInput, ExamProctorUncheckedCreateWithoutProctorInput> | ExamProctorCreateWithoutProctorInput[] | ExamProctorUncheckedCreateWithoutProctorInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutProctorInput | ExamProctorCreateOrConnectWithoutProctorInput[]
    createMany?: ExamProctorCreateManyProctorInputEnvelope
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
  }

  export type StudentGroupCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<StudentGroupCreateWithoutAdvisorInput, StudentGroupUncheckedCreateWithoutAdvisorInput> | StudentGroupCreateWithoutAdvisorInput[] | StudentGroupUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutAdvisorInput | StudentGroupCreateOrConnectWithoutAdvisorInput[]
    createMany?: StudentGroupCreateManyAdvisorInputEnvelope
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutReviewerInput = {
    create?: XOR<LeaveRequestCreateWithoutReviewerInput, LeaveRequestUncheckedCreateWithoutReviewerInput> | LeaveRequestCreateWithoutReviewerInput[] | LeaveRequestUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutReviewerInput | LeaveRequestCreateOrConnectWithoutReviewerInput[]
    createMany?: LeaveRequestCreateManyReviewerInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type ClassSectionUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<ClassSectionCreateWithoutInstructorInput, ClassSectionUncheckedCreateWithoutInstructorInput> | ClassSectionCreateWithoutInstructorInput[] | ClassSectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutInstructorInput | ClassSectionCreateOrConnectWithoutInstructorInput[]
    createMany?: ClassSectionCreateManyInstructorInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput> | InterviewSlotInterviewerCreateWithoutInterviewerInput[] | InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput | InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput[]
    createMany?: InterviewSlotInterviewerCreateManyInterviewerInputEnvelope
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<ClassScheduleCreateWithoutInstructorInput, ClassScheduleUncheckedCreateWithoutInstructorInput> | ClassScheduleCreateWithoutInstructorInput[] | ClassScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutInstructorInput | ClassScheduleCreateOrConnectWithoutInstructorInput[]
    createMany?: ClassScheduleCreateManyInstructorInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<TeachingLoadCreateWithoutInstructorInput, TeachingLoadUncheckedCreateWithoutInstructorInput> | TeachingLoadCreateWithoutInstructorInput[] | TeachingLoadUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutInstructorInput | TeachingLoadCreateOrConnectWithoutInstructorInput[]
    createMany?: TeachingLoadCreateManyInstructorInputEnvelope
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
  }

  export type ExamProctorUncheckedCreateNestedManyWithoutProctorInput = {
    create?: XOR<ExamProctorCreateWithoutProctorInput, ExamProctorUncheckedCreateWithoutProctorInput> | ExamProctorCreateWithoutProctorInput[] | ExamProctorUncheckedCreateWithoutProctorInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutProctorInput | ExamProctorCreateOrConnectWithoutProctorInput[]
    createMany?: ExamProctorCreateManyProctorInputEnvelope
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
  }

  export type StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<StudentGroupCreateWithoutAdvisorInput, StudentGroupUncheckedCreateWithoutAdvisorInput> | StudentGroupCreateWithoutAdvisorInput[] | StudentGroupUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutAdvisorInput | StudentGroupCreateOrConnectWithoutAdvisorInput[]
    createMany?: StudentGroupCreateManyAdvisorInputEnvelope
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<LeaveRequestCreateWithoutReviewerInput, LeaveRequestUncheckedCreateWithoutReviewerInput> | LeaveRequestCreateWithoutReviewerInput[] | LeaveRequestUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutReviewerInput | LeaveRequestCreateOrConnectWithoutReviewerInput[]
    createMany?: LeaveRequestCreateManyReviewerInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPersonnelProfileNestedInput = {
    create?: XOR<UserCreateWithoutPersonnelProfileInput, UserUncheckedCreateWithoutPersonnelProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonnelProfileInput
    upsert?: UserUpsertWithoutPersonnelProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonnelProfileInput, UserUpdateWithoutPersonnelProfileInput>, UserUncheckedUpdateWithoutPersonnelProfileInput>
  }

  export type FacultyUpdateOneWithoutPersonnelNestedInput = {
    create?: XOR<FacultyCreateWithoutPersonnelInput, FacultyUncheckedCreateWithoutPersonnelInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutPersonnelInput
    upsert?: FacultyUpsertWithoutPersonnelInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutPersonnelInput, FacultyUpdateWithoutPersonnelInput>, FacultyUncheckedUpdateWithoutPersonnelInput>
  }

  export type DepartmentUpdateOneWithoutPersonnelNestedInput = {
    create?: XOR<DepartmentCreateWithoutPersonnelInput, DepartmentUncheckedCreateWithoutPersonnelInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPersonnelInput
    upsert?: DepartmentUpsertWithoutPersonnelInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutPersonnelInput, DepartmentUpdateWithoutPersonnelInput>, DepartmentUncheckedUpdateWithoutPersonnelInput>
  }

  export type ClassSectionUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<ClassSectionCreateWithoutInstructorInput, ClassSectionUncheckedCreateWithoutInstructorInput> | ClassSectionCreateWithoutInstructorInput[] | ClassSectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutInstructorInput | ClassSectionCreateOrConnectWithoutInstructorInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutInstructorInput | ClassSectionUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: ClassSectionCreateManyInstructorInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutInstructorInput | ClassSectionUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutInstructorInput | ClassSectionUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput> | InterviewSlotInterviewerCreateWithoutInterviewerInput[] | InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput | InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput[]
    upsert?: InterviewSlotInterviewerUpsertWithWhereUniqueWithoutInterviewerInput | InterviewSlotInterviewerUpsertWithWhereUniqueWithoutInterviewerInput[]
    createMany?: InterviewSlotInterviewerCreateManyInterviewerInputEnvelope
    set?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    disconnect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    delete?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    update?: InterviewSlotInterviewerUpdateWithWhereUniqueWithoutInterviewerInput | InterviewSlotInterviewerUpdateWithWhereUniqueWithoutInterviewerInput[]
    updateMany?: InterviewSlotInterviewerUpdateManyWithWhereWithoutInterviewerInput | InterviewSlotInterviewerUpdateManyWithWhereWithoutInterviewerInput[]
    deleteMany?: InterviewSlotInterviewerScalarWhereInput | InterviewSlotInterviewerScalarWhereInput[]
  }

  export type ClassScheduleUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutInstructorInput, ClassScheduleUncheckedCreateWithoutInstructorInput> | ClassScheduleCreateWithoutInstructorInput[] | ClassScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutInstructorInput | ClassScheduleCreateOrConnectWithoutInstructorInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutInstructorInput | ClassScheduleUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: ClassScheduleCreateManyInstructorInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutInstructorInput | ClassScheduleUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutInstructorInput | ClassScheduleUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type TeachingLoadUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<TeachingLoadCreateWithoutInstructorInput, TeachingLoadUncheckedCreateWithoutInstructorInput> | TeachingLoadCreateWithoutInstructorInput[] | TeachingLoadUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutInstructorInput | TeachingLoadCreateOrConnectWithoutInstructorInput[]
    upsert?: TeachingLoadUpsertWithWhereUniqueWithoutInstructorInput | TeachingLoadUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: TeachingLoadCreateManyInstructorInputEnvelope
    set?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    disconnect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    delete?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    update?: TeachingLoadUpdateWithWhereUniqueWithoutInstructorInput | TeachingLoadUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: TeachingLoadUpdateManyWithWhereWithoutInstructorInput | TeachingLoadUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: TeachingLoadScalarWhereInput | TeachingLoadScalarWhereInput[]
  }

  export type ExamProctorUpdateManyWithoutProctorNestedInput = {
    create?: XOR<ExamProctorCreateWithoutProctorInput, ExamProctorUncheckedCreateWithoutProctorInput> | ExamProctorCreateWithoutProctorInput[] | ExamProctorUncheckedCreateWithoutProctorInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutProctorInput | ExamProctorCreateOrConnectWithoutProctorInput[]
    upsert?: ExamProctorUpsertWithWhereUniqueWithoutProctorInput | ExamProctorUpsertWithWhereUniqueWithoutProctorInput[]
    createMany?: ExamProctorCreateManyProctorInputEnvelope
    set?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    disconnect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    delete?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    update?: ExamProctorUpdateWithWhereUniqueWithoutProctorInput | ExamProctorUpdateWithWhereUniqueWithoutProctorInput[]
    updateMany?: ExamProctorUpdateManyWithWhereWithoutProctorInput | ExamProctorUpdateManyWithWhereWithoutProctorInput[]
    deleteMany?: ExamProctorScalarWhereInput | ExamProctorScalarWhereInput[]
  }

  export type StudentGroupUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<StudentGroupCreateWithoutAdvisorInput, StudentGroupUncheckedCreateWithoutAdvisorInput> | StudentGroupCreateWithoutAdvisorInput[] | StudentGroupUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutAdvisorInput | StudentGroupCreateOrConnectWithoutAdvisorInput[]
    upsert?: StudentGroupUpsertWithWhereUniqueWithoutAdvisorInput | StudentGroupUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: StudentGroupCreateManyAdvisorInputEnvelope
    set?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    disconnect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    delete?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    update?: StudentGroupUpdateWithWhereUniqueWithoutAdvisorInput | StudentGroupUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: StudentGroupUpdateManyWithWhereWithoutAdvisorInput | StudentGroupUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutReviewerInput, LeaveRequestUncheckedCreateWithoutReviewerInput> | LeaveRequestCreateWithoutReviewerInput[] | LeaveRequestUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutReviewerInput | LeaveRequestCreateOrConnectWithoutReviewerInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutReviewerInput | LeaveRequestUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: LeaveRequestCreateManyReviewerInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutReviewerInput | LeaveRequestUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutReviewerInput | LeaveRequestUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<ClassSectionCreateWithoutInstructorInput, ClassSectionUncheckedCreateWithoutInstructorInput> | ClassSectionCreateWithoutInstructorInput[] | ClassSectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutInstructorInput | ClassSectionCreateOrConnectWithoutInstructorInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutInstructorInput | ClassSectionUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: ClassSectionCreateManyInstructorInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutInstructorInput | ClassSectionUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutInstructorInput | ClassSectionUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput> | InterviewSlotInterviewerCreateWithoutInterviewerInput[] | InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput | InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput[]
    upsert?: InterviewSlotInterviewerUpsertWithWhereUniqueWithoutInterviewerInput | InterviewSlotInterviewerUpsertWithWhereUniqueWithoutInterviewerInput[]
    createMany?: InterviewSlotInterviewerCreateManyInterviewerInputEnvelope
    set?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    disconnect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    delete?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    update?: InterviewSlotInterviewerUpdateWithWhereUniqueWithoutInterviewerInput | InterviewSlotInterviewerUpdateWithWhereUniqueWithoutInterviewerInput[]
    updateMany?: InterviewSlotInterviewerUpdateManyWithWhereWithoutInterviewerInput | InterviewSlotInterviewerUpdateManyWithWhereWithoutInterviewerInput[]
    deleteMany?: InterviewSlotInterviewerScalarWhereInput | InterviewSlotInterviewerScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutInstructorInput, ClassScheduleUncheckedCreateWithoutInstructorInput> | ClassScheduleCreateWithoutInstructorInput[] | ClassScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutInstructorInput | ClassScheduleCreateOrConnectWithoutInstructorInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutInstructorInput | ClassScheduleUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: ClassScheduleCreateManyInstructorInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutInstructorInput | ClassScheduleUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutInstructorInput | ClassScheduleUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<TeachingLoadCreateWithoutInstructorInput, TeachingLoadUncheckedCreateWithoutInstructorInput> | TeachingLoadCreateWithoutInstructorInput[] | TeachingLoadUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutInstructorInput | TeachingLoadCreateOrConnectWithoutInstructorInput[]
    upsert?: TeachingLoadUpsertWithWhereUniqueWithoutInstructorInput | TeachingLoadUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: TeachingLoadCreateManyInstructorInputEnvelope
    set?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    disconnect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    delete?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    update?: TeachingLoadUpdateWithWhereUniqueWithoutInstructorInput | TeachingLoadUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: TeachingLoadUpdateManyWithWhereWithoutInstructorInput | TeachingLoadUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: TeachingLoadScalarWhereInput | TeachingLoadScalarWhereInput[]
  }

  export type ExamProctorUncheckedUpdateManyWithoutProctorNestedInput = {
    create?: XOR<ExamProctorCreateWithoutProctorInput, ExamProctorUncheckedCreateWithoutProctorInput> | ExamProctorCreateWithoutProctorInput[] | ExamProctorUncheckedCreateWithoutProctorInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutProctorInput | ExamProctorCreateOrConnectWithoutProctorInput[]
    upsert?: ExamProctorUpsertWithWhereUniqueWithoutProctorInput | ExamProctorUpsertWithWhereUniqueWithoutProctorInput[]
    createMany?: ExamProctorCreateManyProctorInputEnvelope
    set?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    disconnect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    delete?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    update?: ExamProctorUpdateWithWhereUniqueWithoutProctorInput | ExamProctorUpdateWithWhereUniqueWithoutProctorInput[]
    updateMany?: ExamProctorUpdateManyWithWhereWithoutProctorInput | ExamProctorUpdateManyWithWhereWithoutProctorInput[]
    deleteMany?: ExamProctorScalarWhereInput | ExamProctorScalarWhereInput[]
  }

  export type StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<StudentGroupCreateWithoutAdvisorInput, StudentGroupUncheckedCreateWithoutAdvisorInput> | StudentGroupCreateWithoutAdvisorInput[] | StudentGroupUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutAdvisorInput | StudentGroupCreateOrConnectWithoutAdvisorInput[]
    upsert?: StudentGroupUpsertWithWhereUniqueWithoutAdvisorInput | StudentGroupUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: StudentGroupCreateManyAdvisorInputEnvelope
    set?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    disconnect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    delete?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    update?: StudentGroupUpdateWithWhereUniqueWithoutAdvisorInput | StudentGroupUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: StudentGroupUpdateManyWithWhereWithoutAdvisorInput | StudentGroupUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutReviewerInput, LeaveRequestUncheckedCreateWithoutReviewerInput> | LeaveRequestCreateWithoutReviewerInput[] | LeaveRequestUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutReviewerInput | LeaveRequestCreateOrConnectWithoutReviewerInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutReviewerInput | LeaveRequestUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: LeaveRequestCreateManyReviewerInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutReviewerInput | LeaveRequestUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutReviewerInput | LeaveRequestUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type DepartmentCreateNestedManyWithoutFacultyInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type ProgramCreateNestedManyWithoutFacultyInput = {
    create?: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput> | ProgramCreateWithoutFacultyInput[] | ProgramUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[]
    createMany?: ProgramCreateManyFacultyInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type PersonnelCreateNestedManyWithoutFacultyInput = {
    create?: XOR<PersonnelCreateWithoutFacultyInput, PersonnelUncheckedCreateWithoutFacultyInput> | PersonnelCreateWithoutFacultyInput[] | PersonnelUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutFacultyInput | PersonnelCreateOrConnectWithoutFacultyInput[]
    createMany?: PersonnelCreateManyFacultyInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput> | ProgramCreateWithoutFacultyInput[] | ProgramUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[]
    createMany?: ProgramCreateManyFacultyInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type PersonnelUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<PersonnelCreateWithoutFacultyInput, PersonnelUncheckedCreateWithoutFacultyInput> | PersonnelCreateWithoutFacultyInput[] | PersonnelUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutFacultyInput | PersonnelCreateOrConnectWithoutFacultyInput[]
    createMany?: PersonnelCreateManyFacultyInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type DepartmentUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutFacultyInput | DepartmentUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutFacultyInput | DepartmentUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutFacultyInput | DepartmentUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type ProgramUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput> | ProgramCreateWithoutFacultyInput[] | ProgramUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutFacultyInput | ProgramUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: ProgramCreateManyFacultyInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutFacultyInput | ProgramUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutFacultyInput | ProgramUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type PersonnelUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<PersonnelCreateWithoutFacultyInput, PersonnelUncheckedCreateWithoutFacultyInput> | PersonnelCreateWithoutFacultyInput[] | PersonnelUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutFacultyInput | PersonnelCreateOrConnectWithoutFacultyInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutFacultyInput | PersonnelUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: PersonnelCreateManyFacultyInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutFacultyInput | PersonnelUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutFacultyInput | PersonnelUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutFacultyInput | DepartmentUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutFacultyInput | DepartmentUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutFacultyInput | DepartmentUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput> | ProgramCreateWithoutFacultyInput[] | ProgramUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutFacultyInput | ProgramUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: ProgramCreateManyFacultyInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutFacultyInput | ProgramUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutFacultyInput | ProgramUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type PersonnelUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<PersonnelCreateWithoutFacultyInput, PersonnelUncheckedCreateWithoutFacultyInput> | PersonnelCreateWithoutFacultyInput[] | PersonnelUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutFacultyInput | PersonnelCreateOrConnectWithoutFacultyInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutFacultyInput | PersonnelUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: PersonnelCreateManyFacultyInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutFacultyInput | PersonnelUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutFacultyInput | PersonnelUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentsInput
    connect?: FacultyWhereUniqueInput
  }

  export type ProgramCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ProgramCreateWithoutDepartmentInput, ProgramUncheckedCreateWithoutDepartmentInput> | ProgramCreateWithoutDepartmentInput[] | ProgramUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDepartmentInput | ProgramCreateOrConnectWithoutDepartmentInput[]
    createMany?: ProgramCreateManyDepartmentInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type PersonnelCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PersonnelCreateWithoutDepartmentInput, PersonnelUncheckedCreateWithoutDepartmentInput> | PersonnelCreateWithoutDepartmentInput[] | PersonnelUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutDepartmentInput | PersonnelCreateOrConnectWithoutDepartmentInput[]
    createMany?: PersonnelCreateManyDepartmentInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ProgramCreateWithoutDepartmentInput, ProgramUncheckedCreateWithoutDepartmentInput> | ProgramCreateWithoutDepartmentInput[] | ProgramUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDepartmentInput | ProgramCreateOrConnectWithoutDepartmentInput[]
    createMany?: ProgramCreateManyDepartmentInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type PersonnelUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PersonnelCreateWithoutDepartmentInput, PersonnelUncheckedCreateWithoutDepartmentInput> | PersonnelCreateWithoutDepartmentInput[] | PersonnelUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutDepartmentInput | PersonnelCreateOrConnectWithoutDepartmentInput[]
    createMany?: PersonnelCreateManyDepartmentInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type FacultyUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentsInput
    upsert?: FacultyUpsertWithoutDepartmentsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutDepartmentsInput, FacultyUpdateWithoutDepartmentsInput>, FacultyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type ProgramUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ProgramCreateWithoutDepartmentInput, ProgramUncheckedCreateWithoutDepartmentInput> | ProgramCreateWithoutDepartmentInput[] | ProgramUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDepartmentInput | ProgramCreateOrConnectWithoutDepartmentInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutDepartmentInput | ProgramUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ProgramCreateManyDepartmentInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutDepartmentInput | ProgramUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutDepartmentInput | ProgramUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type PersonnelUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PersonnelCreateWithoutDepartmentInput, PersonnelUncheckedCreateWithoutDepartmentInput> | PersonnelCreateWithoutDepartmentInput[] | PersonnelUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutDepartmentInput | PersonnelCreateOrConnectWithoutDepartmentInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutDepartmentInput | PersonnelUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PersonnelCreateManyDepartmentInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutDepartmentInput | PersonnelUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutDepartmentInput | PersonnelUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ProgramCreateWithoutDepartmentInput, ProgramUncheckedCreateWithoutDepartmentInput> | ProgramCreateWithoutDepartmentInput[] | ProgramUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDepartmentInput | ProgramCreateOrConnectWithoutDepartmentInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutDepartmentInput | ProgramUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ProgramCreateManyDepartmentInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutDepartmentInput | ProgramUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutDepartmentInput | ProgramUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type PersonnelUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PersonnelCreateWithoutDepartmentInput, PersonnelUncheckedCreateWithoutDepartmentInput> | PersonnelCreateWithoutDepartmentInput[] | PersonnelUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutDepartmentInput | PersonnelCreateOrConnectWithoutDepartmentInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutDepartmentInput | PersonnelUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PersonnelCreateManyDepartmentInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutDepartmentInput | PersonnelUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutDepartmentInput | PersonnelUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutProgramsInput = {
    create?: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutProgramsInput
    connect?: FacultyWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutProgramsInput = {
    create?: XOR<DepartmentCreateWithoutProgramsInput, DepartmentUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutProgramsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ApplicationCreateNestedManyWithoutProgramInput = {
    create?: XOR<ApplicationCreateWithoutProgramInput, ApplicationUncheckedCreateWithoutProgramInput> | ApplicationCreateWithoutProgramInput[] | ApplicationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutProgramInput | ApplicationCreateOrConnectWithoutProgramInput[]
    createMany?: ApplicationCreateManyProgramInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type InterviewSlotCreateNestedManyWithoutProgramInput = {
    create?: XOR<InterviewSlotCreateWithoutProgramInput, InterviewSlotUncheckedCreateWithoutProgramInput> | InterviewSlotCreateWithoutProgramInput[] | InterviewSlotUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutProgramInput | InterviewSlotCreateOrConnectWithoutProgramInput[]
    createMany?: InterviewSlotCreateManyProgramInputEnvelope
    connect?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
  }

  export type ProgramCourseCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramCourseCreateWithoutProgramInput, ProgramCourseUncheckedCreateWithoutProgramInput> | ProgramCourseCreateWithoutProgramInput[] | ProgramCourseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutProgramInput | ProgramCourseCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramCourseCreateManyProgramInputEnvelope
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
  }

  export type AdmissionTrackCreateNestedManyWithoutProgramInput = {
    create?: XOR<AdmissionTrackCreateWithoutProgramInput, AdmissionTrackUncheckedCreateWithoutProgramInput> | AdmissionTrackCreateWithoutProgramInput[] | AdmissionTrackUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutProgramInput | AdmissionTrackCreateOrConnectWithoutProgramInput[]
    createMany?: AdmissionTrackCreateManyProgramInputEnvelope
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
  }

  export type StudentGroupCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentGroupCreateWithoutProgramInput, StudentGroupUncheckedCreateWithoutProgramInput> | StudentGroupCreateWithoutProgramInput[] | StudentGroupUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutProgramInput | StudentGroupCreateOrConnectWithoutProgramInput[]
    createMany?: StudentGroupCreateManyProgramInputEnvelope
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ApplicationCreateWithoutProgramInput, ApplicationUncheckedCreateWithoutProgramInput> | ApplicationCreateWithoutProgramInput[] | ApplicationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutProgramInput | ApplicationCreateOrConnectWithoutProgramInput[]
    createMany?: ApplicationCreateManyProgramInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type InterviewSlotUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<InterviewSlotCreateWithoutProgramInput, InterviewSlotUncheckedCreateWithoutProgramInput> | InterviewSlotCreateWithoutProgramInput[] | InterviewSlotUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutProgramInput | InterviewSlotCreateOrConnectWithoutProgramInput[]
    createMany?: InterviewSlotCreateManyProgramInputEnvelope
    connect?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
  }

  export type ProgramCourseUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramCourseCreateWithoutProgramInput, ProgramCourseUncheckedCreateWithoutProgramInput> | ProgramCourseCreateWithoutProgramInput[] | ProgramCourseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutProgramInput | ProgramCourseCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramCourseCreateManyProgramInputEnvelope
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
  }

  export type AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<AdmissionTrackCreateWithoutProgramInput, AdmissionTrackUncheckedCreateWithoutProgramInput> | AdmissionTrackCreateWithoutProgramInput[] | AdmissionTrackUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutProgramInput | AdmissionTrackCreateOrConnectWithoutProgramInput[]
    createMany?: AdmissionTrackCreateManyProgramInputEnvelope
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
  }

  export type StudentGroupUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentGroupCreateWithoutProgramInput, StudentGroupUncheckedCreateWithoutProgramInput> | StudentGroupCreateWithoutProgramInput[] | StudentGroupUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutProgramInput | StudentGroupCreateOrConnectWithoutProgramInput[]
    createMany?: StudentGroupCreateManyProgramInputEnvelope
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
  }

  export type EnumDegreeLevelFieldUpdateOperationsInput = {
    set?: $Enums.DegreeLevel
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FacultyUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutProgramsInput
    upsert?: FacultyUpsertWithoutProgramsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutProgramsInput, FacultyUpdateWithoutProgramsInput>, FacultyUncheckedUpdateWithoutProgramsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<DepartmentCreateWithoutProgramsInput, DepartmentUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutProgramsInput
    upsert?: DepartmentUpsertWithoutProgramsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutProgramsInput, DepartmentUpdateWithoutProgramsInput>, DepartmentUncheckedUpdateWithoutProgramsInput>
  }

  export type ApplicationUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ApplicationCreateWithoutProgramInput, ApplicationUncheckedCreateWithoutProgramInput> | ApplicationCreateWithoutProgramInput[] | ApplicationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutProgramInput | ApplicationCreateOrConnectWithoutProgramInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutProgramInput | ApplicationUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ApplicationCreateManyProgramInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutProgramInput | ApplicationUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutProgramInput | ApplicationUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutProgramInput | StudentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutProgramInput | StudentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutProgramInput | StudentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type InterviewSlotUpdateManyWithoutProgramNestedInput = {
    create?: XOR<InterviewSlotCreateWithoutProgramInput, InterviewSlotUncheckedCreateWithoutProgramInput> | InterviewSlotCreateWithoutProgramInput[] | InterviewSlotUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutProgramInput | InterviewSlotCreateOrConnectWithoutProgramInput[]
    upsert?: InterviewSlotUpsertWithWhereUniqueWithoutProgramInput | InterviewSlotUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: InterviewSlotCreateManyProgramInputEnvelope
    set?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    disconnect?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    delete?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    connect?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    update?: InterviewSlotUpdateWithWhereUniqueWithoutProgramInput | InterviewSlotUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: InterviewSlotUpdateManyWithWhereWithoutProgramInput | InterviewSlotUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: InterviewSlotScalarWhereInput | InterviewSlotScalarWhereInput[]
  }

  export type ProgramCourseUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramCourseCreateWithoutProgramInput, ProgramCourseUncheckedCreateWithoutProgramInput> | ProgramCourseCreateWithoutProgramInput[] | ProgramCourseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutProgramInput | ProgramCourseCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramCourseUpsertWithWhereUniqueWithoutProgramInput | ProgramCourseUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramCourseCreateManyProgramInputEnvelope
    set?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    disconnect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    delete?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    update?: ProgramCourseUpdateWithWhereUniqueWithoutProgramInput | ProgramCourseUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramCourseUpdateManyWithWhereWithoutProgramInput | ProgramCourseUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramCourseScalarWhereInput | ProgramCourseScalarWhereInput[]
  }

  export type AdmissionTrackUpdateManyWithoutProgramNestedInput = {
    create?: XOR<AdmissionTrackCreateWithoutProgramInput, AdmissionTrackUncheckedCreateWithoutProgramInput> | AdmissionTrackCreateWithoutProgramInput[] | AdmissionTrackUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutProgramInput | AdmissionTrackCreateOrConnectWithoutProgramInput[]
    upsert?: AdmissionTrackUpsertWithWhereUniqueWithoutProgramInput | AdmissionTrackUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: AdmissionTrackCreateManyProgramInputEnvelope
    set?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    disconnect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    delete?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    update?: AdmissionTrackUpdateWithWhereUniqueWithoutProgramInput | AdmissionTrackUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: AdmissionTrackUpdateManyWithWhereWithoutProgramInput | AdmissionTrackUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: AdmissionTrackScalarWhereInput | AdmissionTrackScalarWhereInput[]
  }

  export type StudentGroupUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentGroupCreateWithoutProgramInput, StudentGroupUncheckedCreateWithoutProgramInput> | StudentGroupCreateWithoutProgramInput[] | StudentGroupUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutProgramInput | StudentGroupCreateOrConnectWithoutProgramInput[]
    upsert?: StudentGroupUpsertWithWhereUniqueWithoutProgramInput | StudentGroupUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentGroupCreateManyProgramInputEnvelope
    set?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    disconnect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    delete?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    update?: StudentGroupUpdateWithWhereUniqueWithoutProgramInput | StudentGroupUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentGroupUpdateManyWithWhereWithoutProgramInput | StudentGroupUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ApplicationCreateWithoutProgramInput, ApplicationUncheckedCreateWithoutProgramInput> | ApplicationCreateWithoutProgramInput[] | ApplicationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutProgramInput | ApplicationCreateOrConnectWithoutProgramInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutProgramInput | ApplicationUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ApplicationCreateManyProgramInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutProgramInput | ApplicationUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutProgramInput | ApplicationUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutProgramInput | StudentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutProgramInput | StudentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutProgramInput | StudentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<InterviewSlotCreateWithoutProgramInput, InterviewSlotUncheckedCreateWithoutProgramInput> | InterviewSlotCreateWithoutProgramInput[] | InterviewSlotUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutProgramInput | InterviewSlotCreateOrConnectWithoutProgramInput[]
    upsert?: InterviewSlotUpsertWithWhereUniqueWithoutProgramInput | InterviewSlotUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: InterviewSlotCreateManyProgramInputEnvelope
    set?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    disconnect?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    delete?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    connect?: InterviewSlotWhereUniqueInput | InterviewSlotWhereUniqueInput[]
    update?: InterviewSlotUpdateWithWhereUniqueWithoutProgramInput | InterviewSlotUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: InterviewSlotUpdateManyWithWhereWithoutProgramInput | InterviewSlotUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: InterviewSlotScalarWhereInput | InterviewSlotScalarWhereInput[]
  }

  export type ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramCourseCreateWithoutProgramInput, ProgramCourseUncheckedCreateWithoutProgramInput> | ProgramCourseCreateWithoutProgramInput[] | ProgramCourseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutProgramInput | ProgramCourseCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramCourseUpsertWithWhereUniqueWithoutProgramInput | ProgramCourseUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramCourseCreateManyProgramInputEnvelope
    set?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    disconnect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    delete?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    update?: ProgramCourseUpdateWithWhereUniqueWithoutProgramInput | ProgramCourseUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramCourseUpdateManyWithWhereWithoutProgramInput | ProgramCourseUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramCourseScalarWhereInput | ProgramCourseScalarWhereInput[]
  }

  export type AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<AdmissionTrackCreateWithoutProgramInput, AdmissionTrackUncheckedCreateWithoutProgramInput> | AdmissionTrackCreateWithoutProgramInput[] | AdmissionTrackUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutProgramInput | AdmissionTrackCreateOrConnectWithoutProgramInput[]
    upsert?: AdmissionTrackUpsertWithWhereUniqueWithoutProgramInput | AdmissionTrackUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: AdmissionTrackCreateManyProgramInputEnvelope
    set?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    disconnect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    delete?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    update?: AdmissionTrackUpdateWithWhereUniqueWithoutProgramInput | AdmissionTrackUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: AdmissionTrackUpdateManyWithWhereWithoutProgramInput | AdmissionTrackUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: AdmissionTrackScalarWhereInput | AdmissionTrackScalarWhereInput[]
  }

  export type StudentGroupUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentGroupCreateWithoutProgramInput, StudentGroupUncheckedCreateWithoutProgramInput> | StudentGroupCreateWithoutProgramInput[] | StudentGroupUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutProgramInput | StudentGroupCreateOrConnectWithoutProgramInput[]
    upsert?: StudentGroupUpsertWithWhereUniqueWithoutProgramInput | StudentGroupUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentGroupCreateManyProgramInputEnvelope
    set?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    disconnect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    delete?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    update?: StudentGroupUpdateWithWhereUniqueWithoutProgramInput | StudentGroupUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentGroupUpdateManyWithWhereWithoutProgramInput | StudentGroupUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
  }

  export type ClassSectionCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassSectionCreateWithoutCourseInput, ClassSectionUncheckedCreateWithoutCourseInput> | ClassSectionCreateWithoutCourseInput[] | ClassSectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutCourseInput | ClassSectionCreateOrConnectWithoutCourseInput[]
    createMany?: ClassSectionCreateManyCourseInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type ProgramCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<ProgramCourseCreateWithoutCourseInput, ProgramCourseUncheckedCreateWithoutCourseInput> | ProgramCourseCreateWithoutCourseInput[] | ProgramCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutCourseInput | ProgramCourseCreateOrConnectWithoutCourseInput[]
    createMany?: ProgramCourseCreateManyCourseInputEnvelope
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
  }

  export type ClassScheduleCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassScheduleCreateWithoutCourseInput, ClassScheduleUncheckedCreateWithoutCourseInput> | ClassScheduleCreateWithoutCourseInput[] | ClassScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutCourseInput | ClassScheduleCreateOrConnectWithoutCourseInput[]
    createMany?: ClassScheduleCreateManyCourseInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type ExamScheduleCreateNestedManyWithoutCourseInput = {
    create?: XOR<ExamScheduleCreateWithoutCourseInput, ExamScheduleUncheckedCreateWithoutCourseInput> | ExamScheduleCreateWithoutCourseInput[] | ExamScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutCourseInput | ExamScheduleCreateOrConnectWithoutCourseInput[]
    createMany?: ExamScheduleCreateManyCourseInputEnvelope
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
  }

  export type ClassSectionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassSectionCreateWithoutCourseInput, ClassSectionUncheckedCreateWithoutCourseInput> | ClassSectionCreateWithoutCourseInput[] | ClassSectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutCourseInput | ClassSectionCreateOrConnectWithoutCourseInput[]
    createMany?: ClassSectionCreateManyCourseInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type ProgramCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ProgramCourseCreateWithoutCourseInput, ProgramCourseUncheckedCreateWithoutCourseInput> | ProgramCourseCreateWithoutCourseInput[] | ProgramCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutCourseInput | ProgramCourseCreateOrConnectWithoutCourseInput[]
    createMany?: ProgramCourseCreateManyCourseInputEnvelope
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassScheduleCreateWithoutCourseInput, ClassScheduleUncheckedCreateWithoutCourseInput> | ClassScheduleCreateWithoutCourseInput[] | ClassScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutCourseInput | ClassScheduleCreateOrConnectWithoutCourseInput[]
    createMany?: ClassScheduleCreateManyCourseInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type ExamScheduleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ExamScheduleCreateWithoutCourseInput, ExamScheduleUncheckedCreateWithoutCourseInput> | ExamScheduleCreateWithoutCourseInput[] | ExamScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutCourseInput | ExamScheduleCreateOrConnectWithoutCourseInput[]
    createMany?: ExamScheduleCreateManyCourseInputEnvelope
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassSectionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassSectionCreateWithoutCourseInput, ClassSectionUncheckedCreateWithoutCourseInput> | ClassSectionCreateWithoutCourseInput[] | ClassSectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutCourseInput | ClassSectionCreateOrConnectWithoutCourseInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutCourseInput | ClassSectionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassSectionCreateManyCourseInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutCourseInput | ClassSectionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutCourseInput | ClassSectionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type ProgramCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ProgramCourseCreateWithoutCourseInput, ProgramCourseUncheckedCreateWithoutCourseInput> | ProgramCourseCreateWithoutCourseInput[] | ProgramCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutCourseInput | ProgramCourseCreateOrConnectWithoutCourseInput[]
    upsert?: ProgramCourseUpsertWithWhereUniqueWithoutCourseInput | ProgramCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ProgramCourseCreateManyCourseInputEnvelope
    set?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    disconnect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    delete?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    update?: ProgramCourseUpdateWithWhereUniqueWithoutCourseInput | ProgramCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ProgramCourseUpdateManyWithWhereWithoutCourseInput | ProgramCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ProgramCourseScalarWhereInput | ProgramCourseScalarWhereInput[]
  }

  export type ClassScheduleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutCourseInput, ClassScheduleUncheckedCreateWithoutCourseInput> | ClassScheduleCreateWithoutCourseInput[] | ClassScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutCourseInput | ClassScheduleCreateOrConnectWithoutCourseInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutCourseInput | ClassScheduleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassScheduleCreateManyCourseInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutCourseInput | ClassScheduleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutCourseInput | ClassScheduleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type ExamScheduleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ExamScheduleCreateWithoutCourseInput, ExamScheduleUncheckedCreateWithoutCourseInput> | ExamScheduleCreateWithoutCourseInput[] | ExamScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutCourseInput | ExamScheduleCreateOrConnectWithoutCourseInput[]
    upsert?: ExamScheduleUpsertWithWhereUniqueWithoutCourseInput | ExamScheduleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ExamScheduleCreateManyCourseInputEnvelope
    set?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    disconnect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    delete?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    update?: ExamScheduleUpdateWithWhereUniqueWithoutCourseInput | ExamScheduleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ExamScheduleUpdateManyWithWhereWithoutCourseInput | ExamScheduleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ExamScheduleScalarWhereInput | ExamScheduleScalarWhereInput[]
  }

  export type ClassSectionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassSectionCreateWithoutCourseInput, ClassSectionUncheckedCreateWithoutCourseInput> | ClassSectionCreateWithoutCourseInput[] | ClassSectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutCourseInput | ClassSectionCreateOrConnectWithoutCourseInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutCourseInput | ClassSectionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassSectionCreateManyCourseInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutCourseInput | ClassSectionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutCourseInput | ClassSectionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type ProgramCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ProgramCourseCreateWithoutCourseInput, ProgramCourseUncheckedCreateWithoutCourseInput> | ProgramCourseCreateWithoutCourseInput[] | ProgramCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ProgramCourseCreateOrConnectWithoutCourseInput | ProgramCourseCreateOrConnectWithoutCourseInput[]
    upsert?: ProgramCourseUpsertWithWhereUniqueWithoutCourseInput | ProgramCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ProgramCourseCreateManyCourseInputEnvelope
    set?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    disconnect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    delete?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    connect?: ProgramCourseWhereUniqueInput | ProgramCourseWhereUniqueInput[]
    update?: ProgramCourseUpdateWithWhereUniqueWithoutCourseInput | ProgramCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ProgramCourseUpdateManyWithWhereWithoutCourseInput | ProgramCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ProgramCourseScalarWhereInput | ProgramCourseScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutCourseInput, ClassScheduleUncheckedCreateWithoutCourseInput> | ClassScheduleCreateWithoutCourseInput[] | ClassScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutCourseInput | ClassScheduleCreateOrConnectWithoutCourseInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutCourseInput | ClassScheduleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassScheduleCreateManyCourseInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutCourseInput | ClassScheduleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutCourseInput | ClassScheduleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type ExamScheduleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ExamScheduleCreateWithoutCourseInput, ExamScheduleUncheckedCreateWithoutCourseInput> | ExamScheduleCreateWithoutCourseInput[] | ExamScheduleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutCourseInput | ExamScheduleCreateOrConnectWithoutCourseInput[]
    upsert?: ExamScheduleUpsertWithWhereUniqueWithoutCourseInput | ExamScheduleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ExamScheduleCreateManyCourseInputEnvelope
    set?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    disconnect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    delete?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    update?: ExamScheduleUpdateWithWhereUniqueWithoutCourseInput | ExamScheduleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ExamScheduleUpdateManyWithWhereWithoutCourseInput | ExamScheduleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ExamScheduleScalarWhereInput | ExamScheduleScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutCoursesInput = {
    create?: XOR<ProgramCreateWithoutCoursesInput, ProgramUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutCoursesInput
    connect?: ProgramWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutProgramsInput = {
    create?: XOR<CourseCreateWithoutProgramsInput, CourseUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgramsInput
    connect?: CourseWhereUniqueInput
  }

  export type ProgramUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<ProgramCreateWithoutCoursesInput, ProgramUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutCoursesInput
    upsert?: ProgramUpsertWithoutCoursesInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutCoursesInput, ProgramUpdateWithoutCoursesInput>, ProgramUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<CourseCreateWithoutProgramsInput, CourseUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgramsInput
    upsert?: CourseUpsertWithoutProgramsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutProgramsInput, CourseUpdateWithoutProgramsInput>, CourseUncheckedUpdateWithoutProgramsInput>
  }

  export type ClassSectionCreateNestedManyWithoutTermInput = {
    create?: XOR<ClassSectionCreateWithoutTermInput, ClassSectionUncheckedCreateWithoutTermInput> | ClassSectionCreateWithoutTermInput[] | ClassSectionUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutTermInput | ClassSectionCreateOrConnectWithoutTermInput[]
    createMany?: ClassSectionCreateManyTermInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTermInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ExamScheduleCreateNestedManyWithoutTermInput = {
    create?: XOR<ExamScheduleCreateWithoutTermInput, ExamScheduleUncheckedCreateWithoutTermInput> | ExamScheduleCreateWithoutTermInput[] | ExamScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutTermInput | ExamScheduleCreateOrConnectWithoutTermInput[]
    createMany?: ExamScheduleCreateManyTermInputEnvelope
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
  }

  export type TeachingLoadCreateNestedManyWithoutTermInput = {
    create?: XOR<TeachingLoadCreateWithoutTermInput, TeachingLoadUncheckedCreateWithoutTermInput> | TeachingLoadCreateWithoutTermInput[] | TeachingLoadUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutTermInput | TeachingLoadCreateOrConnectWithoutTermInput[]
    createMany?: TeachingLoadCreateManyTermInputEnvelope
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
  }

  export type ClassScheduleCreateNestedManyWithoutTermInput = {
    create?: XOR<ClassScheduleCreateWithoutTermInput, ClassScheduleUncheckedCreateWithoutTermInput> | ClassScheduleCreateWithoutTermInput[] | ClassScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTermInput | ClassScheduleCreateOrConnectWithoutTermInput[]
    createMany?: ClassScheduleCreateManyTermInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type ClassSectionUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<ClassSectionCreateWithoutTermInput, ClassSectionUncheckedCreateWithoutTermInput> | ClassSectionCreateWithoutTermInput[] | ClassSectionUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutTermInput | ClassSectionCreateOrConnectWithoutTermInput[]
    createMany?: ClassSectionCreateManyTermInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ExamScheduleUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<ExamScheduleCreateWithoutTermInput, ExamScheduleUncheckedCreateWithoutTermInput> | ExamScheduleCreateWithoutTermInput[] | ExamScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutTermInput | ExamScheduleCreateOrConnectWithoutTermInput[]
    createMany?: ExamScheduleCreateManyTermInputEnvelope
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
  }

  export type TeachingLoadUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<TeachingLoadCreateWithoutTermInput, TeachingLoadUncheckedCreateWithoutTermInput> | TeachingLoadCreateWithoutTermInput[] | TeachingLoadUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutTermInput | TeachingLoadCreateOrConnectWithoutTermInput[]
    createMany?: TeachingLoadCreateManyTermInputEnvelope
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<ClassScheduleCreateWithoutTermInput, ClassScheduleUncheckedCreateWithoutTermInput> | ClassScheduleCreateWithoutTermInput[] | ClassScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTermInput | ClassScheduleCreateOrConnectWithoutTermInput[]
    createMany?: ClassScheduleCreateManyTermInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type ClassSectionUpdateManyWithoutTermNestedInput = {
    create?: XOR<ClassSectionCreateWithoutTermInput, ClassSectionUncheckedCreateWithoutTermInput> | ClassSectionCreateWithoutTermInput[] | ClassSectionUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutTermInput | ClassSectionCreateOrConnectWithoutTermInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutTermInput | ClassSectionUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: ClassSectionCreateManyTermInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutTermInput | ClassSectionUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutTermInput | ClassSectionUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTermNestedInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTermInput | InvoiceUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTermInput | InvoiceUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTermInput | InvoiceUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ExamScheduleUpdateManyWithoutTermNestedInput = {
    create?: XOR<ExamScheduleCreateWithoutTermInput, ExamScheduleUncheckedCreateWithoutTermInput> | ExamScheduleCreateWithoutTermInput[] | ExamScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutTermInput | ExamScheduleCreateOrConnectWithoutTermInput[]
    upsert?: ExamScheduleUpsertWithWhereUniqueWithoutTermInput | ExamScheduleUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: ExamScheduleCreateManyTermInputEnvelope
    set?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    disconnect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    delete?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    update?: ExamScheduleUpdateWithWhereUniqueWithoutTermInput | ExamScheduleUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: ExamScheduleUpdateManyWithWhereWithoutTermInput | ExamScheduleUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: ExamScheduleScalarWhereInput | ExamScheduleScalarWhereInput[]
  }

  export type TeachingLoadUpdateManyWithoutTermNestedInput = {
    create?: XOR<TeachingLoadCreateWithoutTermInput, TeachingLoadUncheckedCreateWithoutTermInput> | TeachingLoadCreateWithoutTermInput[] | TeachingLoadUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutTermInput | TeachingLoadCreateOrConnectWithoutTermInput[]
    upsert?: TeachingLoadUpsertWithWhereUniqueWithoutTermInput | TeachingLoadUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: TeachingLoadCreateManyTermInputEnvelope
    set?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    disconnect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    delete?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    update?: TeachingLoadUpdateWithWhereUniqueWithoutTermInput | TeachingLoadUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: TeachingLoadUpdateManyWithWhereWithoutTermInput | TeachingLoadUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: TeachingLoadScalarWhereInput | TeachingLoadScalarWhereInput[]
  }

  export type ClassScheduleUpdateManyWithoutTermNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutTermInput, ClassScheduleUncheckedCreateWithoutTermInput> | ClassScheduleCreateWithoutTermInput[] | ClassScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTermInput | ClassScheduleCreateOrConnectWithoutTermInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutTermInput | ClassScheduleUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: ClassScheduleCreateManyTermInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutTermInput | ClassScheduleUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutTermInput | ClassScheduleUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type ClassSectionUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<ClassSectionCreateWithoutTermInput, ClassSectionUncheckedCreateWithoutTermInput> | ClassSectionCreateWithoutTermInput[] | ClassSectionUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutTermInput | ClassSectionCreateOrConnectWithoutTermInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutTermInput | ClassSectionUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: ClassSectionCreateManyTermInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutTermInput | ClassSectionUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutTermInput | ClassSectionUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTermInput | InvoiceUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTermInput | InvoiceUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTermInput | InvoiceUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ExamScheduleUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<ExamScheduleCreateWithoutTermInput, ExamScheduleUncheckedCreateWithoutTermInput> | ExamScheduleCreateWithoutTermInput[] | ExamScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutTermInput | ExamScheduleCreateOrConnectWithoutTermInput[]
    upsert?: ExamScheduleUpsertWithWhereUniqueWithoutTermInput | ExamScheduleUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: ExamScheduleCreateManyTermInputEnvelope
    set?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    disconnect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    delete?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    connect?: ExamScheduleWhereUniqueInput | ExamScheduleWhereUniqueInput[]
    update?: ExamScheduleUpdateWithWhereUniqueWithoutTermInput | ExamScheduleUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: ExamScheduleUpdateManyWithWhereWithoutTermInput | ExamScheduleUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: ExamScheduleScalarWhereInput | ExamScheduleScalarWhereInput[]
  }

  export type TeachingLoadUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<TeachingLoadCreateWithoutTermInput, TeachingLoadUncheckedCreateWithoutTermInput> | TeachingLoadCreateWithoutTermInput[] | TeachingLoadUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TeachingLoadCreateOrConnectWithoutTermInput | TeachingLoadCreateOrConnectWithoutTermInput[]
    upsert?: TeachingLoadUpsertWithWhereUniqueWithoutTermInput | TeachingLoadUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: TeachingLoadCreateManyTermInputEnvelope
    set?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    disconnect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    delete?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    connect?: TeachingLoadWhereUniqueInput | TeachingLoadWhereUniqueInput[]
    update?: TeachingLoadUpdateWithWhereUniqueWithoutTermInput | TeachingLoadUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: TeachingLoadUpdateManyWithWhereWithoutTermInput | TeachingLoadUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: TeachingLoadScalarWhereInput | TeachingLoadScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutTermInput, ClassScheduleUncheckedCreateWithoutTermInput> | ClassScheduleCreateWithoutTermInput[] | ClassScheduleUncheckedCreateWithoutTermInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTermInput | ClassScheduleCreateOrConnectWithoutTermInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutTermInput | ClassScheduleUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: ClassScheduleCreateManyTermInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutTermInput | ClassScheduleUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutTermInput | ClassScheduleUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutApplicantProfileInput = {
    create?: XOR<UserCreateWithoutApplicantProfileInput, UserUncheckedCreateWithoutApplicantProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicantProfileInput
    connect?: UserWhereUniqueInput
  }

  export type EducationHistoryCreateNestedManyWithoutApplicantInput = {
    create?: XOR<EducationHistoryCreateWithoutApplicantInput, EducationHistoryUncheckedCreateWithoutApplicantInput> | EducationHistoryCreateWithoutApplicantInput[] | EducationHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: EducationHistoryCreateOrConnectWithoutApplicantInput | EducationHistoryCreateOrConnectWithoutApplicantInput[]
    createMany?: EducationHistoryCreateManyApplicantInputEnvelope
    connect?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutApplicantInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type EducationHistoryUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<EducationHistoryCreateWithoutApplicantInput, EducationHistoryUncheckedCreateWithoutApplicantInput> | EducationHistoryCreateWithoutApplicantInput[] | EducationHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: EducationHistoryCreateOrConnectWithoutApplicantInput | EducationHistoryCreateOrConnectWithoutApplicantInput[]
    createMany?: EducationHistoryCreateManyApplicantInputEnvelope
    connect?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type UserUpdateOneRequiredWithoutApplicantProfileNestedInput = {
    create?: XOR<UserCreateWithoutApplicantProfileInput, UserUncheckedCreateWithoutApplicantProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicantProfileInput
    upsert?: UserUpsertWithoutApplicantProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicantProfileInput, UserUpdateWithoutApplicantProfileInput>, UserUncheckedUpdateWithoutApplicantProfileInput>
  }

  export type EducationHistoryUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<EducationHistoryCreateWithoutApplicantInput, EducationHistoryUncheckedCreateWithoutApplicantInput> | EducationHistoryCreateWithoutApplicantInput[] | EducationHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: EducationHistoryCreateOrConnectWithoutApplicantInput | EducationHistoryCreateOrConnectWithoutApplicantInput[]
    upsert?: EducationHistoryUpsertWithWhereUniqueWithoutApplicantInput | EducationHistoryUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: EducationHistoryCreateManyApplicantInputEnvelope
    set?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    disconnect?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    delete?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    connect?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    update?: EducationHistoryUpdateWithWhereUniqueWithoutApplicantInput | EducationHistoryUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: EducationHistoryUpdateManyWithWhereWithoutApplicantInput | EducationHistoryUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: EducationHistoryScalarWhereInput | EducationHistoryScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutApplicantInput | ApplicationUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutApplicantInput | ApplicationUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutApplicantInput | ApplicationUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type EducationHistoryUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<EducationHistoryCreateWithoutApplicantInput, EducationHistoryUncheckedCreateWithoutApplicantInput> | EducationHistoryCreateWithoutApplicantInput[] | EducationHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: EducationHistoryCreateOrConnectWithoutApplicantInput | EducationHistoryCreateOrConnectWithoutApplicantInput[]
    upsert?: EducationHistoryUpsertWithWhereUniqueWithoutApplicantInput | EducationHistoryUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: EducationHistoryCreateManyApplicantInputEnvelope
    set?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    disconnect?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    delete?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    connect?: EducationHistoryWhereUniqueInput | EducationHistoryWhereUniqueInput[]
    update?: EducationHistoryUpdateWithWhereUniqueWithoutApplicantInput | EducationHistoryUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: EducationHistoryUpdateManyWithWhereWithoutApplicantInput | EducationHistoryUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: EducationHistoryScalarWhereInput | EducationHistoryScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput> | ApplicationCreateWithoutApplicantInput[] | ApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicantInput | ApplicationCreateOrConnectWithoutApplicantInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutApplicantInput | ApplicationUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: ApplicationCreateManyApplicantInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutApplicantInput | ApplicationUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutApplicantInput | ApplicationUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type ApplicantCreateNestedOneWithoutEducationHistoryInput = {
    create?: XOR<ApplicantCreateWithoutEducationHistoryInput, ApplicantUncheckedCreateWithoutEducationHistoryInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutEducationHistoryInput
    connect?: ApplicantWhereUniqueInput
  }

  export type ApplicantUpdateOneRequiredWithoutEducationHistoryNestedInput = {
    create?: XOR<ApplicantCreateWithoutEducationHistoryInput, ApplicantUncheckedCreateWithoutEducationHistoryInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutEducationHistoryInput
    upsert?: ApplicantUpsertWithoutEducationHistoryInput
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutEducationHistoryInput, ApplicantUpdateWithoutEducationHistoryInput>, ApplicantUncheckedUpdateWithoutEducationHistoryInput>
  }

  export type AdmissionTrackCreateNestedManyWithoutTypeInput = {
    create?: XOR<AdmissionTrackCreateWithoutTypeInput, AdmissionTrackUncheckedCreateWithoutTypeInput> | AdmissionTrackCreateWithoutTypeInput[] | AdmissionTrackUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutTypeInput | AdmissionTrackCreateOrConnectWithoutTypeInput[]
    createMany?: AdmissionTrackCreateManyTypeInputEnvelope
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
  }

  export type AdmissionTrackUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<AdmissionTrackCreateWithoutTypeInput, AdmissionTrackUncheckedCreateWithoutTypeInput> | AdmissionTrackCreateWithoutTypeInput[] | AdmissionTrackUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutTypeInput | AdmissionTrackCreateOrConnectWithoutTypeInput[]
    createMany?: AdmissionTrackCreateManyTypeInputEnvelope
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
  }

  export type AdmissionTrackUpdateManyWithoutTypeNestedInput = {
    create?: XOR<AdmissionTrackCreateWithoutTypeInput, AdmissionTrackUncheckedCreateWithoutTypeInput> | AdmissionTrackCreateWithoutTypeInput[] | AdmissionTrackUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutTypeInput | AdmissionTrackCreateOrConnectWithoutTypeInput[]
    upsert?: AdmissionTrackUpsertWithWhereUniqueWithoutTypeInput | AdmissionTrackUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: AdmissionTrackCreateManyTypeInputEnvelope
    set?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    disconnect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    delete?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    update?: AdmissionTrackUpdateWithWhereUniqueWithoutTypeInput | AdmissionTrackUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: AdmissionTrackUpdateManyWithWhereWithoutTypeInput | AdmissionTrackUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: AdmissionTrackScalarWhereInput | AdmissionTrackScalarWhereInput[]
  }

  export type AdmissionTrackUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<AdmissionTrackCreateWithoutTypeInput, AdmissionTrackUncheckedCreateWithoutTypeInput> | AdmissionTrackCreateWithoutTypeInput[] | AdmissionTrackUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutTypeInput | AdmissionTrackCreateOrConnectWithoutTypeInput[]
    upsert?: AdmissionTrackUpsertWithWhereUniqueWithoutTypeInput | AdmissionTrackUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: AdmissionTrackCreateManyTypeInputEnvelope
    set?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    disconnect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    delete?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    connect?: AdmissionTrackWhereUniqueInput | AdmissionTrackWhereUniqueInput[]
    update?: AdmissionTrackUpdateWithWhereUniqueWithoutTypeInput | AdmissionTrackUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: AdmissionTrackUpdateManyWithWhereWithoutTypeInput | AdmissionTrackUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: AdmissionTrackScalarWhereInput | AdmissionTrackScalarWhereInput[]
  }

  export type AdmissionTrackTypeCreateNestedOneWithoutTracksInput = {
    create?: XOR<AdmissionTrackTypeCreateWithoutTracksInput, AdmissionTrackTypeUncheckedCreateWithoutTracksInput>
    connectOrCreate?: AdmissionTrackTypeCreateOrConnectWithoutTracksInput
    connect?: AdmissionTrackTypeWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutAdmissionTracksInput = {
    create?: XOR<ProgramCreateWithoutAdmissionTracksInput, ProgramUncheckedCreateWithoutAdmissionTracksInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutAdmissionTracksInput
    connect?: ProgramWhereUniqueInput
  }

  export type ApplicationCreateNestedManyWithoutTrackInput = {
    create?: XOR<ApplicationCreateWithoutTrackInput, ApplicationUncheckedCreateWithoutTrackInput> | ApplicationCreateWithoutTrackInput[] | ApplicationUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTrackInput | ApplicationCreateOrConnectWithoutTrackInput[]
    createMany?: ApplicationCreateManyTrackInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutTrackInput = {
    create?: XOR<ApplicationCreateWithoutTrackInput, ApplicationUncheckedCreateWithoutTrackInput> | ApplicationCreateWithoutTrackInput[] | ApplicationUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTrackInput | ApplicationCreateOrConnectWithoutTrackInput[]
    createMany?: ApplicationCreateManyTrackInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type AdmissionTrackTypeUpdateOneRequiredWithoutTracksNestedInput = {
    create?: XOR<AdmissionTrackTypeCreateWithoutTracksInput, AdmissionTrackTypeUncheckedCreateWithoutTracksInput>
    connectOrCreate?: AdmissionTrackTypeCreateOrConnectWithoutTracksInput
    upsert?: AdmissionTrackTypeUpsertWithoutTracksInput
    connect?: AdmissionTrackTypeWhereUniqueInput
    update?: XOR<XOR<AdmissionTrackTypeUpdateToOneWithWhereWithoutTracksInput, AdmissionTrackTypeUpdateWithoutTracksInput>, AdmissionTrackTypeUncheckedUpdateWithoutTracksInput>
  }

  export type ProgramUpdateOneRequiredWithoutAdmissionTracksNestedInput = {
    create?: XOR<ProgramCreateWithoutAdmissionTracksInput, ProgramUncheckedCreateWithoutAdmissionTracksInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutAdmissionTracksInput
    upsert?: ProgramUpsertWithoutAdmissionTracksInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutAdmissionTracksInput, ProgramUpdateWithoutAdmissionTracksInput>, ProgramUncheckedUpdateWithoutAdmissionTracksInput>
  }

  export type ApplicationUpdateManyWithoutTrackNestedInput = {
    create?: XOR<ApplicationCreateWithoutTrackInput, ApplicationUncheckedCreateWithoutTrackInput> | ApplicationCreateWithoutTrackInput[] | ApplicationUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTrackInput | ApplicationCreateOrConnectWithoutTrackInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutTrackInput | ApplicationUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: ApplicationCreateManyTrackInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutTrackInput | ApplicationUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutTrackInput | ApplicationUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutTrackNestedInput = {
    create?: XOR<ApplicationCreateWithoutTrackInput, ApplicationUncheckedCreateWithoutTrackInput> | ApplicationCreateWithoutTrackInput[] | ApplicationUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTrackInput | ApplicationCreateOrConnectWithoutTrackInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutTrackInput | ApplicationUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: ApplicationCreateManyTrackInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutTrackInput | ApplicationUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutTrackInput | ApplicationUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type ApplicantCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<ApplicantCreateWithoutApplicationsInput, ApplicantUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutApplicationsInput
    connect?: ApplicantWhereUniqueInput
  }

  export type AdmissionTrackCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<AdmissionTrackCreateWithoutApplicationsInput, AdmissionTrackUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutApplicationsInput
    connect?: AdmissionTrackWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<ProgramCreateWithoutApplicationsInput, ProgramUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutApplicationsInput
    connect?: ProgramWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutApplicationInput = {
    create?: XOR<DocumentCreateWithoutApplicationInput, DocumentUncheckedCreateWithoutApplicationInput> | DocumentCreateWithoutApplicationInput[] | DocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutApplicationInput | DocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: DocumentCreateManyApplicationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type InterviewResultCreateNestedOneWithoutApplicationInput = {
    create?: XOR<InterviewResultCreateWithoutApplicationInput, InterviewResultUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: InterviewResultCreateOrConnectWithoutApplicationInput
    connect?: InterviewResultWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<DocumentCreateWithoutApplicationInput, DocumentUncheckedCreateWithoutApplicationInput> | DocumentCreateWithoutApplicationInput[] | DocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutApplicationInput | DocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: DocumentCreateManyApplicationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type InterviewResultUncheckedCreateNestedOneWithoutApplicationInput = {
    create?: XOR<InterviewResultCreateWithoutApplicationInput, InterviewResultUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: InterviewResultCreateOrConnectWithoutApplicationInput
    connect?: InterviewResultWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type ApplicantUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<ApplicantCreateWithoutApplicationsInput, ApplicantUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutApplicationsInput
    upsert?: ApplicantUpsertWithoutApplicationsInput
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutApplicationsInput, ApplicantUpdateWithoutApplicationsInput>, ApplicantUncheckedUpdateWithoutApplicationsInput>
  }

  export type AdmissionTrackUpdateOneWithoutApplicationsNestedInput = {
    create?: XOR<AdmissionTrackCreateWithoutApplicationsInput, AdmissionTrackUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: AdmissionTrackCreateOrConnectWithoutApplicationsInput
    upsert?: AdmissionTrackUpsertWithoutApplicationsInput
    disconnect?: AdmissionTrackWhereInput | boolean
    delete?: AdmissionTrackWhereInput | boolean
    connect?: AdmissionTrackWhereUniqueInput
    update?: XOR<XOR<AdmissionTrackUpdateToOneWithWhereWithoutApplicationsInput, AdmissionTrackUpdateWithoutApplicationsInput>, AdmissionTrackUncheckedUpdateWithoutApplicationsInput>
  }

  export type ProgramUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<ProgramCreateWithoutApplicationsInput, ProgramUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutApplicationsInput
    upsert?: ProgramUpsertWithoutApplicationsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutApplicationsInput, ProgramUpdateWithoutApplicationsInput>, ProgramUncheckedUpdateWithoutApplicationsInput>
  }

  export type DocumentUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<DocumentCreateWithoutApplicationInput, DocumentUncheckedCreateWithoutApplicationInput> | DocumentCreateWithoutApplicationInput[] | DocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutApplicationInput | DocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutApplicationInput | DocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: DocumentCreateManyApplicationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutApplicationInput | DocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutApplicationInput | DocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type InterviewResultUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<InterviewResultCreateWithoutApplicationInput, InterviewResultUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: InterviewResultCreateOrConnectWithoutApplicationInput
    upsert?: InterviewResultUpsertWithoutApplicationInput
    disconnect?: InterviewResultWhereInput | boolean
    delete?: InterviewResultWhereInput | boolean
    connect?: InterviewResultWhereUniqueInput
    update?: XOR<XOR<InterviewResultUpdateToOneWithWhereWithoutApplicationInput, InterviewResultUpdateWithoutApplicationInput>, InterviewResultUncheckedUpdateWithoutApplicationInput>
  }

  export type DocumentUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<DocumentCreateWithoutApplicationInput, DocumentUncheckedCreateWithoutApplicationInput> | DocumentCreateWithoutApplicationInput[] | DocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutApplicationInput | DocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutApplicationInput | DocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: DocumentCreateManyApplicationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutApplicationInput | DocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutApplicationInput | DocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type InterviewResultUncheckedUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<InterviewResultCreateWithoutApplicationInput, InterviewResultUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: InterviewResultCreateOrConnectWithoutApplicationInput
    upsert?: InterviewResultUpsertWithoutApplicationInput
    disconnect?: InterviewResultWhereInput | boolean
    delete?: InterviewResultWhereInput | boolean
    connect?: InterviewResultWhereUniqueInput
    update?: XOR<XOR<InterviewResultUpdateToOneWithWhereWithoutApplicationInput, InterviewResultUpdateWithoutApplicationInput>, InterviewResultUncheckedUpdateWithoutApplicationInput>
  }

  export type ApplicationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ApplicationCreateWithoutDocumentsInput, ApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutDocumentsInput
    connect?: ApplicationWhereUniqueInput
  }

  export type ApplicationUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ApplicationCreateWithoutDocumentsInput, ApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutDocumentsInput
    upsert?: ApplicationUpsertWithoutDocumentsInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutDocumentsInput, ApplicationUpdateWithoutDocumentsInput>, ApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProgramCreateNestedOneWithoutInterviewSlotsInput = {
    create?: XOR<ProgramCreateWithoutInterviewSlotsInput, ProgramUncheckedCreateWithoutInterviewSlotsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutInterviewSlotsInput
    connect?: ProgramWhereUniqueInput
  }

  export type InterviewResultCreateNestedManyWithoutSlotInput = {
    create?: XOR<InterviewResultCreateWithoutSlotInput, InterviewResultUncheckedCreateWithoutSlotInput> | InterviewResultCreateWithoutSlotInput[] | InterviewResultUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewResultCreateOrConnectWithoutSlotInput | InterviewResultCreateOrConnectWithoutSlotInput[]
    createMany?: InterviewResultCreateManySlotInputEnvelope
    connect?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
  }

  export type InterviewSlotInterviewerCreateNestedManyWithoutSlotInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutSlotInput, InterviewSlotInterviewerUncheckedCreateWithoutSlotInput> | InterviewSlotInterviewerCreateWithoutSlotInput[] | InterviewSlotInterviewerUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutSlotInput | InterviewSlotInterviewerCreateOrConnectWithoutSlotInput[]
    createMany?: InterviewSlotInterviewerCreateManySlotInputEnvelope
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
  }

  export type InterviewResultUncheckedCreateNestedManyWithoutSlotInput = {
    create?: XOR<InterviewResultCreateWithoutSlotInput, InterviewResultUncheckedCreateWithoutSlotInput> | InterviewResultCreateWithoutSlotInput[] | InterviewResultUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewResultCreateOrConnectWithoutSlotInput | InterviewResultCreateOrConnectWithoutSlotInput[]
    createMany?: InterviewResultCreateManySlotInputEnvelope
    connect?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
  }

  export type InterviewSlotInterviewerUncheckedCreateNestedManyWithoutSlotInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutSlotInput, InterviewSlotInterviewerUncheckedCreateWithoutSlotInput> | InterviewSlotInterviewerCreateWithoutSlotInput[] | InterviewSlotInterviewerUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutSlotInput | InterviewSlotInterviewerCreateOrConnectWithoutSlotInput[]
    createMany?: InterviewSlotInterviewerCreateManySlotInputEnvelope
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
  }

  export type ProgramUpdateOneWithoutInterviewSlotsNestedInput = {
    create?: XOR<ProgramCreateWithoutInterviewSlotsInput, ProgramUncheckedCreateWithoutInterviewSlotsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutInterviewSlotsInput
    upsert?: ProgramUpsertWithoutInterviewSlotsInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutInterviewSlotsInput, ProgramUpdateWithoutInterviewSlotsInput>, ProgramUncheckedUpdateWithoutInterviewSlotsInput>
  }

  export type InterviewResultUpdateManyWithoutSlotNestedInput = {
    create?: XOR<InterviewResultCreateWithoutSlotInput, InterviewResultUncheckedCreateWithoutSlotInput> | InterviewResultCreateWithoutSlotInput[] | InterviewResultUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewResultCreateOrConnectWithoutSlotInput | InterviewResultCreateOrConnectWithoutSlotInput[]
    upsert?: InterviewResultUpsertWithWhereUniqueWithoutSlotInput | InterviewResultUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: InterviewResultCreateManySlotInputEnvelope
    set?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    disconnect?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    delete?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    connect?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    update?: InterviewResultUpdateWithWhereUniqueWithoutSlotInput | InterviewResultUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: InterviewResultUpdateManyWithWhereWithoutSlotInput | InterviewResultUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: InterviewResultScalarWhereInput | InterviewResultScalarWhereInput[]
  }

  export type InterviewSlotInterviewerUpdateManyWithoutSlotNestedInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutSlotInput, InterviewSlotInterviewerUncheckedCreateWithoutSlotInput> | InterviewSlotInterviewerCreateWithoutSlotInput[] | InterviewSlotInterviewerUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutSlotInput | InterviewSlotInterviewerCreateOrConnectWithoutSlotInput[]
    upsert?: InterviewSlotInterviewerUpsertWithWhereUniqueWithoutSlotInput | InterviewSlotInterviewerUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: InterviewSlotInterviewerCreateManySlotInputEnvelope
    set?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    disconnect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    delete?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    update?: InterviewSlotInterviewerUpdateWithWhereUniqueWithoutSlotInput | InterviewSlotInterviewerUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: InterviewSlotInterviewerUpdateManyWithWhereWithoutSlotInput | InterviewSlotInterviewerUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: InterviewSlotInterviewerScalarWhereInput | InterviewSlotInterviewerScalarWhereInput[]
  }

  export type InterviewResultUncheckedUpdateManyWithoutSlotNestedInput = {
    create?: XOR<InterviewResultCreateWithoutSlotInput, InterviewResultUncheckedCreateWithoutSlotInput> | InterviewResultCreateWithoutSlotInput[] | InterviewResultUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewResultCreateOrConnectWithoutSlotInput | InterviewResultCreateOrConnectWithoutSlotInput[]
    upsert?: InterviewResultUpsertWithWhereUniqueWithoutSlotInput | InterviewResultUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: InterviewResultCreateManySlotInputEnvelope
    set?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    disconnect?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    delete?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    connect?: InterviewResultWhereUniqueInput | InterviewResultWhereUniqueInput[]
    update?: InterviewResultUpdateWithWhereUniqueWithoutSlotInput | InterviewResultUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: InterviewResultUpdateManyWithWhereWithoutSlotInput | InterviewResultUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: InterviewResultScalarWhereInput | InterviewResultScalarWhereInput[]
  }

  export type InterviewSlotInterviewerUncheckedUpdateManyWithoutSlotNestedInput = {
    create?: XOR<InterviewSlotInterviewerCreateWithoutSlotInput, InterviewSlotInterviewerUncheckedCreateWithoutSlotInput> | InterviewSlotInterviewerCreateWithoutSlotInput[] | InterviewSlotInterviewerUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: InterviewSlotInterviewerCreateOrConnectWithoutSlotInput | InterviewSlotInterviewerCreateOrConnectWithoutSlotInput[]
    upsert?: InterviewSlotInterviewerUpsertWithWhereUniqueWithoutSlotInput | InterviewSlotInterviewerUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: InterviewSlotInterviewerCreateManySlotInputEnvelope
    set?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    disconnect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    delete?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    connect?: InterviewSlotInterviewerWhereUniqueInput | InterviewSlotInterviewerWhereUniqueInput[]
    update?: InterviewSlotInterviewerUpdateWithWhereUniqueWithoutSlotInput | InterviewSlotInterviewerUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: InterviewSlotInterviewerUpdateManyWithWhereWithoutSlotInput | InterviewSlotInterviewerUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: InterviewSlotInterviewerScalarWhereInput | InterviewSlotInterviewerScalarWhereInput[]
  }

  export type InterviewSlotCreateNestedOneWithoutInterviewersInput = {
    create?: XOR<InterviewSlotCreateWithoutInterviewersInput, InterviewSlotUncheckedCreateWithoutInterviewersInput>
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutInterviewersInput
    connect?: InterviewSlotWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutInterviewSlotsInput = {
    create?: XOR<PersonnelCreateWithoutInterviewSlotsInput, PersonnelUncheckedCreateWithoutInterviewSlotsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutInterviewSlotsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type InterviewSlotUpdateOneRequiredWithoutInterviewersNestedInput = {
    create?: XOR<InterviewSlotCreateWithoutInterviewersInput, InterviewSlotUncheckedCreateWithoutInterviewersInput>
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutInterviewersInput
    upsert?: InterviewSlotUpsertWithoutInterviewersInput
    connect?: InterviewSlotWhereUniqueInput
    update?: XOR<XOR<InterviewSlotUpdateToOneWithWhereWithoutInterviewersInput, InterviewSlotUpdateWithoutInterviewersInput>, InterviewSlotUncheckedUpdateWithoutInterviewersInput>
  }

  export type PersonnelUpdateOneRequiredWithoutInterviewSlotsNestedInput = {
    create?: XOR<PersonnelCreateWithoutInterviewSlotsInput, PersonnelUncheckedCreateWithoutInterviewSlotsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutInterviewSlotsInput
    upsert?: PersonnelUpsertWithoutInterviewSlotsInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutInterviewSlotsInput, PersonnelUpdateWithoutInterviewSlotsInput>, PersonnelUncheckedUpdateWithoutInterviewSlotsInput>
  }

  export type ApplicationCreateNestedOneWithoutInterviewInput = {
    create?: XOR<ApplicationCreateWithoutInterviewInput, ApplicationUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutInterviewInput
    connect?: ApplicationWhereUniqueInput
  }

  export type InterviewSlotCreateNestedOneWithoutInterviewResultsInput = {
    create?: XOR<InterviewSlotCreateWithoutInterviewResultsInput, InterviewSlotUncheckedCreateWithoutInterviewResultsInput>
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutInterviewResultsInput
    connect?: InterviewSlotWhereUniqueInput
  }

  export type InterviewFeedbackCreateNestedOneWithoutInterviewResultInput = {
    create?: XOR<InterviewFeedbackCreateWithoutInterviewResultInput, InterviewFeedbackUncheckedCreateWithoutInterviewResultInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutInterviewResultInput
    connect?: InterviewFeedbackWhereUniqueInput
  }

  export type InterviewFeedbackUncheckedCreateNestedOneWithoutInterviewResultInput = {
    create?: XOR<InterviewFeedbackCreateWithoutInterviewResultInput, InterviewFeedbackUncheckedCreateWithoutInterviewResultInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutInterviewResultInput
    connect?: InterviewFeedbackWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ApplicationUpdateOneRequiredWithoutInterviewNestedInput = {
    create?: XOR<ApplicationCreateWithoutInterviewInput, ApplicationUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutInterviewInput
    upsert?: ApplicationUpsertWithoutInterviewInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutInterviewInput, ApplicationUpdateWithoutInterviewInput>, ApplicationUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewSlotUpdateOneRequiredWithoutInterviewResultsNestedInput = {
    create?: XOR<InterviewSlotCreateWithoutInterviewResultsInput, InterviewSlotUncheckedCreateWithoutInterviewResultsInput>
    connectOrCreate?: InterviewSlotCreateOrConnectWithoutInterviewResultsInput
    upsert?: InterviewSlotUpsertWithoutInterviewResultsInput
    connect?: InterviewSlotWhereUniqueInput
    update?: XOR<XOR<InterviewSlotUpdateToOneWithWhereWithoutInterviewResultsInput, InterviewSlotUpdateWithoutInterviewResultsInput>, InterviewSlotUncheckedUpdateWithoutInterviewResultsInput>
  }

  export type InterviewFeedbackUpdateOneWithoutInterviewResultNestedInput = {
    create?: XOR<InterviewFeedbackCreateWithoutInterviewResultInput, InterviewFeedbackUncheckedCreateWithoutInterviewResultInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutInterviewResultInput
    upsert?: InterviewFeedbackUpsertWithoutInterviewResultInput
    disconnect?: InterviewFeedbackWhereInput | boolean
    delete?: InterviewFeedbackWhereInput | boolean
    connect?: InterviewFeedbackWhereUniqueInput
    update?: XOR<XOR<InterviewFeedbackUpdateToOneWithWhereWithoutInterviewResultInput, InterviewFeedbackUpdateWithoutInterviewResultInput>, InterviewFeedbackUncheckedUpdateWithoutInterviewResultInput>
  }

  export type InterviewFeedbackUncheckedUpdateOneWithoutInterviewResultNestedInput = {
    create?: XOR<InterviewFeedbackCreateWithoutInterviewResultInput, InterviewFeedbackUncheckedCreateWithoutInterviewResultInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutInterviewResultInput
    upsert?: InterviewFeedbackUpsertWithoutInterviewResultInput
    disconnect?: InterviewFeedbackWhereInput | boolean
    delete?: InterviewFeedbackWhereInput | boolean
    connect?: InterviewFeedbackWhereUniqueInput
    update?: XOR<XOR<InterviewFeedbackUpdateToOneWithWhereWithoutInterviewResultInput, InterviewFeedbackUpdateWithoutInterviewResultInput>, InterviewFeedbackUncheckedUpdateWithoutInterviewResultInput>
  }

  export type InterviewResultCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<InterviewResultCreateWithoutFeedbackInput, InterviewResultUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: InterviewResultCreateOrConnectWithoutFeedbackInput
    connect?: InterviewResultWhereUniqueInput
  }

  export type InterviewResultUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<InterviewResultCreateWithoutFeedbackInput, InterviewResultUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: InterviewResultCreateOrConnectWithoutFeedbackInput
    upsert?: InterviewResultUpsertWithoutFeedbackInput
    connect?: InterviewResultWhereUniqueInput
    update?: XOR<XOR<InterviewResultUpdateToOneWithWhereWithoutFeedbackInput, InterviewResultUpdateWithoutFeedbackInput>, InterviewResultUncheckedUpdateWithoutFeedbackInput>
  }

  export type ProgramCreateNestedOneWithoutStudentGroupsInput = {
    create?: XOR<ProgramCreateWithoutStudentGroupsInput, ProgramUncheckedCreateWithoutStudentGroupsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutStudentGroupsInput
    connect?: ProgramWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutAdvisorGroupsInput = {
    create?: XOR<PersonnelCreateWithoutAdvisorGroupsInput, PersonnelUncheckedCreateWithoutAdvisorGroupsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutAdvisorGroupsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutStudentGroupInput = {
    create?: XOR<StudentCreateWithoutStudentGroupInput, StudentUncheckedCreateWithoutStudentGroupInput> | StudentCreateWithoutStudentGroupInput[] | StudentUncheckedCreateWithoutStudentGroupInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutStudentGroupInput | StudentCreateOrConnectWithoutStudentGroupInput[]
    createMany?: StudentCreateManyStudentGroupInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassSectionCreateNestedManyWithoutStudentGroupsInput = {
    create?: XOR<ClassSectionCreateWithoutStudentGroupsInput, ClassSectionUncheckedCreateWithoutStudentGroupsInput> | ClassSectionCreateWithoutStudentGroupsInput[] | ClassSectionUncheckedCreateWithoutStudentGroupsInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutStudentGroupsInput | ClassSectionCreateOrConnectWithoutStudentGroupsInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutStudentGroupInput = {
    create?: XOR<StudentCreateWithoutStudentGroupInput, StudentUncheckedCreateWithoutStudentGroupInput> | StudentCreateWithoutStudentGroupInput[] | StudentUncheckedCreateWithoutStudentGroupInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutStudentGroupInput | StudentCreateOrConnectWithoutStudentGroupInput[]
    createMany?: StudentCreateManyStudentGroupInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassSectionUncheckedCreateNestedManyWithoutStudentGroupsInput = {
    create?: XOR<ClassSectionCreateWithoutStudentGroupsInput, ClassSectionUncheckedCreateWithoutStudentGroupsInput> | ClassSectionCreateWithoutStudentGroupsInput[] | ClassSectionUncheckedCreateWithoutStudentGroupsInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutStudentGroupsInput | ClassSectionCreateOrConnectWithoutStudentGroupsInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type ProgramUpdateOneRequiredWithoutStudentGroupsNestedInput = {
    create?: XOR<ProgramCreateWithoutStudentGroupsInput, ProgramUncheckedCreateWithoutStudentGroupsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutStudentGroupsInput
    upsert?: ProgramUpsertWithoutStudentGroupsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutStudentGroupsInput, ProgramUpdateWithoutStudentGroupsInput>, ProgramUncheckedUpdateWithoutStudentGroupsInput>
  }

  export type PersonnelUpdateOneWithoutAdvisorGroupsNestedInput = {
    create?: XOR<PersonnelCreateWithoutAdvisorGroupsInput, PersonnelUncheckedCreateWithoutAdvisorGroupsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutAdvisorGroupsInput
    upsert?: PersonnelUpsertWithoutAdvisorGroupsInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutAdvisorGroupsInput, PersonnelUpdateWithoutAdvisorGroupsInput>, PersonnelUncheckedUpdateWithoutAdvisorGroupsInput>
  }

  export type StudentUpdateManyWithoutStudentGroupNestedInput = {
    create?: XOR<StudentCreateWithoutStudentGroupInput, StudentUncheckedCreateWithoutStudentGroupInput> | StudentCreateWithoutStudentGroupInput[] | StudentUncheckedCreateWithoutStudentGroupInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutStudentGroupInput | StudentCreateOrConnectWithoutStudentGroupInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutStudentGroupInput | StudentUpsertWithWhereUniqueWithoutStudentGroupInput[]
    createMany?: StudentCreateManyStudentGroupInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutStudentGroupInput | StudentUpdateWithWhereUniqueWithoutStudentGroupInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutStudentGroupInput | StudentUpdateManyWithWhereWithoutStudentGroupInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassSectionUpdateManyWithoutStudentGroupsNestedInput = {
    create?: XOR<ClassSectionCreateWithoutStudentGroupsInput, ClassSectionUncheckedCreateWithoutStudentGroupsInput> | ClassSectionCreateWithoutStudentGroupsInput[] | ClassSectionUncheckedCreateWithoutStudentGroupsInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutStudentGroupsInput | ClassSectionCreateOrConnectWithoutStudentGroupsInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutStudentGroupsInput | ClassSectionUpsertWithWhereUniqueWithoutStudentGroupsInput[]
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutStudentGroupsInput | ClassSectionUpdateWithWhereUniqueWithoutStudentGroupsInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutStudentGroupsInput | ClassSectionUpdateManyWithWhereWithoutStudentGroupsInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutStudentGroupNestedInput = {
    create?: XOR<StudentCreateWithoutStudentGroupInput, StudentUncheckedCreateWithoutStudentGroupInput> | StudentCreateWithoutStudentGroupInput[] | StudentUncheckedCreateWithoutStudentGroupInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutStudentGroupInput | StudentCreateOrConnectWithoutStudentGroupInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutStudentGroupInput | StudentUpsertWithWhereUniqueWithoutStudentGroupInput[]
    createMany?: StudentCreateManyStudentGroupInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutStudentGroupInput | StudentUpdateWithWhereUniqueWithoutStudentGroupInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutStudentGroupInput | StudentUpdateManyWithWhereWithoutStudentGroupInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassSectionUncheckedUpdateManyWithoutStudentGroupsNestedInput = {
    create?: XOR<ClassSectionCreateWithoutStudentGroupsInput, ClassSectionUncheckedCreateWithoutStudentGroupsInput> | ClassSectionCreateWithoutStudentGroupsInput[] | ClassSectionUncheckedCreateWithoutStudentGroupsInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutStudentGroupsInput | ClassSectionCreateOrConnectWithoutStudentGroupsInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutStudentGroupsInput | ClassSectionUpsertWithWhereUniqueWithoutStudentGroupsInput[]
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutStudentGroupsInput | ClassSectionUpdateWithWhereUniqueWithoutStudentGroupsInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutStudentGroupsInput | ClassSectionUpdateManyWithWhereWithoutStudentGroupsInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutStudentsInput
    connect?: ProgramWhereUniqueInput
  }

  export type StudentGroupCreateNestedOneWithoutStudentsInput = {
    create?: XOR<StudentGroupCreateWithoutStudentsInput, StudentGroupUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: StudentGroupCreateOrConnectWithoutStudentsInput
    connect?: StudentGroupWhereUniqueInput
  }

  export type EnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<LeaveRequestCreateWithoutStudentInput, LeaveRequestUncheckedCreateWithoutStudentInput> | LeaveRequestCreateWithoutStudentInput[] | LeaveRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutStudentInput | LeaveRequestCreateOrConnectWithoutStudentInput[]
    createMany?: LeaveRequestCreateManyStudentInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<LeaveRequestCreateWithoutStudentInput, LeaveRequestUncheckedCreateWithoutStudentInput> | LeaveRequestCreateWithoutStudentInput[] | LeaveRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutStudentInput | LeaveRequestCreateOrConnectWithoutStudentInput[]
    createMany?: LeaveRequestCreateManyStudentInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type EnumStudentTypeFieldUpdateOperationsInput = {
    set?: $Enums.StudentType
  }

  export type EnumStudentStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutStudentProfileNestedInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    upsert?: UserUpsertWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentProfileInput, UserUpdateWithoutStudentProfileInput>, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type ProgramUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutStudentsInput
    upsert?: ProgramUpsertWithoutStudentsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutStudentsInput, ProgramUpdateWithoutStudentsInput>, ProgramUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentGroupUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<StudentGroupCreateWithoutStudentsInput, StudentGroupUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: StudentGroupCreateOrConnectWithoutStudentsInput
    upsert?: StudentGroupUpsertWithoutStudentsInput
    disconnect?: StudentGroupWhereInput | boolean
    delete?: StudentGroupWhereInput | boolean
    connect?: StudentGroupWhereUniqueInput
    update?: XOR<XOR<StudentGroupUpdateToOneWithWhereWithoutStudentsInput, StudentGroupUpdateWithoutStudentsInput>, StudentGroupUncheckedUpdateWithoutStudentsInput>
  }

  export type EnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentInput | InvoiceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentInput | InvoiceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentInput | InvoiceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutStudentInput, LeaveRequestUncheckedCreateWithoutStudentInput> | LeaveRequestCreateWithoutStudentInput[] | LeaveRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutStudentInput | LeaveRequestCreateOrConnectWithoutStudentInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutStudentInput | LeaveRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LeaveRequestCreateManyStudentInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutStudentInput | LeaveRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutStudentInput | LeaveRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentInput | InvoiceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentInput | InvoiceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentInput | InvoiceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutStudentInput, LeaveRequestUncheckedCreateWithoutStudentInput> | LeaveRequestCreateWithoutStudentInput[] | LeaveRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutStudentInput | LeaveRequestCreateOrConnectWithoutStudentInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutStudentInput | LeaveRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LeaveRequestCreateManyStudentInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutStudentInput | LeaveRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutStudentInput | LeaveRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutSectionsInput = {
    create?: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSectionsInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicTermCreateNestedOneWithoutSectionsInput = {
    create?: XOR<AcademicTermCreateWithoutSectionsInput, AcademicTermUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutSectionsInput
    connect?: AcademicTermWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutInstructedSectionsInput = {
    create?: XOR<PersonnelCreateWithoutInstructedSectionsInput, PersonnelUncheckedCreateWithoutInstructedSectionsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutInstructedSectionsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type ClassScheduleCreateNestedManyWithoutSectionInput = {
    create?: XOR<ClassScheduleCreateWithoutSectionInput, ClassScheduleUncheckedCreateWithoutSectionInput> | ClassScheduleCreateWithoutSectionInput[] | ClassScheduleUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSectionInput | ClassScheduleCreateOrConnectWithoutSectionInput[]
    createMany?: ClassScheduleCreateManySectionInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutSectionInput = {
    create?: XOR<EnrollmentCreateWithoutSectionInput, EnrollmentUncheckedCreateWithoutSectionInput> | EnrollmentCreateWithoutSectionInput[] | EnrollmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutSectionInput | EnrollmentCreateOrConnectWithoutSectionInput[]
    createMany?: EnrollmentCreateManySectionInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type StudentGroupCreateNestedManyWithoutSectionsInput = {
    create?: XOR<StudentGroupCreateWithoutSectionsInput, StudentGroupUncheckedCreateWithoutSectionsInput> | StudentGroupCreateWithoutSectionsInput[] | StudentGroupUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutSectionsInput | StudentGroupCreateOrConnectWithoutSectionsInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<ClassScheduleCreateWithoutSectionInput, ClassScheduleUncheckedCreateWithoutSectionInput> | ClassScheduleCreateWithoutSectionInput[] | ClassScheduleUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSectionInput | ClassScheduleCreateOrConnectWithoutSectionInput[]
    createMany?: ClassScheduleCreateManySectionInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<EnrollmentCreateWithoutSectionInput, EnrollmentUncheckedCreateWithoutSectionInput> | EnrollmentCreateWithoutSectionInput[] | EnrollmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutSectionInput | EnrollmentCreateOrConnectWithoutSectionInput[]
    createMany?: EnrollmentCreateManySectionInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type StudentGroupUncheckedCreateNestedManyWithoutSectionsInput = {
    create?: XOR<StudentGroupCreateWithoutSectionsInput, StudentGroupUncheckedCreateWithoutSectionsInput> | StudentGroupCreateWithoutSectionsInput[] | StudentGroupUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutSectionsInput | StudentGroupCreateOrConnectWithoutSectionsInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSectionsInput
    upsert?: CourseUpsertWithoutSectionsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSectionsInput, CourseUpdateWithoutSectionsInput>, CourseUncheckedUpdateWithoutSectionsInput>
  }

  export type AcademicTermUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<AcademicTermCreateWithoutSectionsInput, AcademicTermUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutSectionsInput
    upsert?: AcademicTermUpsertWithoutSectionsInput
    connect?: AcademicTermWhereUniqueInput
    update?: XOR<XOR<AcademicTermUpdateToOneWithWhereWithoutSectionsInput, AcademicTermUpdateWithoutSectionsInput>, AcademicTermUncheckedUpdateWithoutSectionsInput>
  }

  export type PersonnelUpdateOneWithoutInstructedSectionsNestedInput = {
    create?: XOR<PersonnelCreateWithoutInstructedSectionsInput, PersonnelUncheckedCreateWithoutInstructedSectionsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutInstructedSectionsInput
    upsert?: PersonnelUpsertWithoutInstructedSectionsInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutInstructedSectionsInput, PersonnelUpdateWithoutInstructedSectionsInput>, PersonnelUncheckedUpdateWithoutInstructedSectionsInput>
  }

  export type ClassScheduleUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutSectionInput, ClassScheduleUncheckedCreateWithoutSectionInput> | ClassScheduleCreateWithoutSectionInput[] | ClassScheduleUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSectionInput | ClassScheduleCreateOrConnectWithoutSectionInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutSectionInput | ClassScheduleUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ClassScheduleCreateManySectionInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutSectionInput | ClassScheduleUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutSectionInput | ClassScheduleUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutSectionNestedInput = {
    create?: XOR<EnrollmentCreateWithoutSectionInput, EnrollmentUncheckedCreateWithoutSectionInput> | EnrollmentCreateWithoutSectionInput[] | EnrollmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutSectionInput | EnrollmentCreateOrConnectWithoutSectionInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutSectionInput | EnrollmentUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: EnrollmentCreateManySectionInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutSectionInput | EnrollmentUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutSectionInput | EnrollmentUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type StudentGroupUpdateManyWithoutSectionsNestedInput = {
    create?: XOR<StudentGroupCreateWithoutSectionsInput, StudentGroupUncheckedCreateWithoutSectionsInput> | StudentGroupCreateWithoutSectionsInput[] | StudentGroupUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutSectionsInput | StudentGroupCreateOrConnectWithoutSectionsInput[]
    upsert?: StudentGroupUpsertWithWhereUniqueWithoutSectionsInput | StudentGroupUpsertWithWhereUniqueWithoutSectionsInput[]
    set?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    disconnect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    delete?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    update?: StudentGroupUpdateWithWhereUniqueWithoutSectionsInput | StudentGroupUpdateWithWhereUniqueWithoutSectionsInput[]
    updateMany?: StudentGroupUpdateManyWithWhereWithoutSectionsInput | StudentGroupUpdateManyWithWhereWithoutSectionsInput[]
    deleteMany?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutSectionInput, ClassScheduleUncheckedCreateWithoutSectionInput> | ClassScheduleCreateWithoutSectionInput[] | ClassScheduleUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSectionInput | ClassScheduleCreateOrConnectWithoutSectionInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutSectionInput | ClassScheduleUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ClassScheduleCreateManySectionInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutSectionInput | ClassScheduleUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutSectionInput | ClassScheduleUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<EnrollmentCreateWithoutSectionInput, EnrollmentUncheckedCreateWithoutSectionInput> | EnrollmentCreateWithoutSectionInput[] | EnrollmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutSectionInput | EnrollmentCreateOrConnectWithoutSectionInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutSectionInput | EnrollmentUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: EnrollmentCreateManySectionInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutSectionInput | EnrollmentUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutSectionInput | EnrollmentUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type StudentGroupUncheckedUpdateManyWithoutSectionsNestedInput = {
    create?: XOR<StudentGroupCreateWithoutSectionsInput, StudentGroupUncheckedCreateWithoutSectionsInput> | StudentGroupCreateWithoutSectionsInput[] | StudentGroupUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentGroupCreateOrConnectWithoutSectionsInput | StudentGroupCreateOrConnectWithoutSectionsInput[]
    upsert?: StudentGroupUpsertWithWhereUniqueWithoutSectionsInput | StudentGroupUpsertWithWhereUniqueWithoutSectionsInput[]
    set?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    disconnect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    delete?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    connect?: StudentGroupWhereUniqueInput | StudentGroupWhereUniqueInput[]
    update?: StudentGroupUpdateWithWhereUniqueWithoutSectionsInput | StudentGroupUpdateWithWhereUniqueWithoutSectionsInput[]
    updateMany?: StudentGroupUpdateManyWithWhereWithoutSectionsInput | StudentGroupUpdateManyWithWhereWithoutSectionsInput[]
    deleteMany?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
  }

  export type ClassSectionCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<ClassSectionCreateWithoutSchedulesInput, ClassSectionUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ClassSectionCreateOrConnectWithoutSchedulesInput
    connect?: ClassSectionWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<RoomCreateWithoutSchedulesInput, RoomUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutSchedulesInput
    connect?: RoomWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<CourseCreateWithoutSchedulesInput, CourseUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSchedulesInput
    connect?: CourseWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutTeachingSchedulesInput = {
    create?: XOR<PersonnelCreateWithoutTeachingSchedulesInput, PersonnelUncheckedCreateWithoutTeachingSchedulesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutTeachingSchedulesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type AcademicTermCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<AcademicTermCreateWithoutSchedulesInput, AcademicTermUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutSchedulesInput
    connect?: AcademicTermWhereUniqueInput
  }

  export type EnumDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.DayOfWeek
  }

  export type ClassSectionUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<ClassSectionCreateWithoutSchedulesInput, ClassSectionUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ClassSectionCreateOrConnectWithoutSchedulesInput
    upsert?: ClassSectionUpsertWithoutSchedulesInput
    connect?: ClassSectionWhereUniqueInput
    update?: XOR<XOR<ClassSectionUpdateToOneWithWhereWithoutSchedulesInput, ClassSectionUpdateWithoutSchedulesInput>, ClassSectionUncheckedUpdateWithoutSchedulesInput>
  }

  export type RoomUpdateOneWithoutSchedulesNestedInput = {
    create?: XOR<RoomCreateWithoutSchedulesInput, RoomUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutSchedulesInput
    upsert?: RoomUpsertWithoutSchedulesInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutSchedulesInput, RoomUpdateWithoutSchedulesInput>, RoomUncheckedUpdateWithoutSchedulesInput>
  }

  export type CourseUpdateOneWithoutSchedulesNestedInput = {
    create?: XOR<CourseCreateWithoutSchedulesInput, CourseUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSchedulesInput
    upsert?: CourseUpsertWithoutSchedulesInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSchedulesInput, CourseUpdateWithoutSchedulesInput>, CourseUncheckedUpdateWithoutSchedulesInput>
  }

  export type PersonnelUpdateOneWithoutTeachingSchedulesNestedInput = {
    create?: XOR<PersonnelCreateWithoutTeachingSchedulesInput, PersonnelUncheckedCreateWithoutTeachingSchedulesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutTeachingSchedulesInput
    upsert?: PersonnelUpsertWithoutTeachingSchedulesInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutTeachingSchedulesInput, PersonnelUpdateWithoutTeachingSchedulesInput>, PersonnelUncheckedUpdateWithoutTeachingSchedulesInput>
  }

  export type AcademicTermUpdateOneWithoutSchedulesNestedInput = {
    create?: XOR<AcademicTermCreateWithoutSchedulesInput, AcademicTermUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutSchedulesInput
    upsert?: AcademicTermUpsertWithoutSchedulesInput
    disconnect?: AcademicTermWhereInput | boolean
    delete?: AcademicTermWhereInput | boolean
    connect?: AcademicTermWhereUniqueInput
    update?: XOR<XOR<AcademicTermUpdateToOneWithWhereWithoutSchedulesInput, AcademicTermUpdateWithoutSchedulesInput>, AcademicTermUncheckedUpdateWithoutSchedulesInput>
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassSectionCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<ClassSectionCreateWithoutEnrollmentsInput, ClassSectionUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassSectionCreateOrConnectWithoutEnrollmentsInput
    connect?: ClassSectionWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassSectionUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<ClassSectionCreateWithoutEnrollmentsInput, ClassSectionUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassSectionCreateOrConnectWithoutEnrollmentsInput
    upsert?: ClassSectionUpsertWithoutEnrollmentsInput
    connect?: ClassSectionWhereUniqueInput
    update?: XOR<XOR<ClassSectionUpdateToOneWithWhereWithoutEnrollmentsInput, ClassSectionUpdateWithoutEnrollmentsInput>, ClassSectionUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoicesInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicTermCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<AcademicTermCreateWithoutInvoicesInput, AcademicTermUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutInvoicesInput
    connect?: AcademicTermWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type StudentUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoicesInput
    upsert?: StudentUpsertWithoutInvoicesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutInvoicesInput, StudentUpdateWithoutInvoicesInput>, StudentUncheckedUpdateWithoutInvoicesInput>
  }

  export type AcademicTermUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<AcademicTermCreateWithoutInvoicesInput, AcademicTermUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutInvoicesInput
    upsert?: AcademicTermUpsertWithoutInvoicesInput
    connect?: AcademicTermWhereUniqueInput
    update?: XOR<XOR<AcademicTermUpdateToOneWithWhereWithoutInvoicesInput, AcademicTermUpdateWithoutInvoicesInput>, AcademicTermUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAnnouncementTargetFieldUpdateOperationsInput = {
    set?: $Enums.AnnouncementTarget
  }

  export type UserUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    upsert?: UserUpsertWithoutAnnouncementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementsInput, UserUpdateWithoutAnnouncementsInput>, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type AiMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
  }

  export type AiMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
  }

  export type AiMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AiMessageUpsertWithWhereUniqueWithoutConversationInput | AiMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    set?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    disconnect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    delete?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    update?: AiMessageUpdateWithWhereUniqueWithoutConversationInput | AiMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AiMessageUpdateManyWithWhereWithoutConversationInput | AiMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
  }

  export type AiMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AiMessageUpsertWithWhereUniqueWithoutConversationInput | AiMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    set?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    disconnect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    delete?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    update?: AiMessageUpdateWithWhereUniqueWithoutConversationInput | AiMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AiMessageUpdateManyWithWhereWithoutConversationInput | AiMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
  }

  export type AiConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiConversationCreateOrConnectWithoutMessagesInput
    connect?: AiConversationWhereUniqueInput
  }

  export type AiConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiConversationCreateOrConnectWithoutMessagesInput
    upsert?: AiConversationUpsertWithoutMessagesInput
    connect?: AiConversationWhereUniqueInput
    update?: XOR<XOR<AiConversationUpdateToOneWithWhereWithoutMessagesInput, AiConversationUpdateWithoutMessagesInput>, AiConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type HelpArticleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HelpArticleCreateWithoutCategoryInput, HelpArticleUncheckedCreateWithoutCategoryInput> | HelpArticleCreateWithoutCategoryInput[] | HelpArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutCategoryInput | HelpArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: HelpArticleCreateManyCategoryInputEnvelope
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
  }

  export type HelpArticleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HelpArticleCreateWithoutCategoryInput, HelpArticleUncheckedCreateWithoutCategoryInput> | HelpArticleCreateWithoutCategoryInput[] | HelpArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutCategoryInput | HelpArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: HelpArticleCreateManyCategoryInputEnvelope
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
  }

  export type HelpArticleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HelpArticleCreateWithoutCategoryInput, HelpArticleUncheckedCreateWithoutCategoryInput> | HelpArticleCreateWithoutCategoryInput[] | HelpArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutCategoryInput | HelpArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: HelpArticleUpsertWithWhereUniqueWithoutCategoryInput | HelpArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HelpArticleCreateManyCategoryInputEnvelope
    set?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    disconnect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    delete?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    update?: HelpArticleUpdateWithWhereUniqueWithoutCategoryInput | HelpArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HelpArticleUpdateManyWithWhereWithoutCategoryInput | HelpArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
  }

  export type HelpArticleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HelpArticleCreateWithoutCategoryInput, HelpArticleUncheckedCreateWithoutCategoryInput> | HelpArticleCreateWithoutCategoryInput[] | HelpArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutCategoryInput | HelpArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: HelpArticleUpsertWithWhereUniqueWithoutCategoryInput | HelpArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HelpArticleCreateManyCategoryInputEnvelope
    set?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    disconnect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    delete?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    update?: HelpArticleUpdateWithWhereUniqueWithoutCategoryInput | HelpArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HelpArticleUpdateManyWithWhereWithoutCategoryInput | HelpArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
  }

  export type HelpCategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: HelpCategoryCreateOrConnectWithoutArticlesInput
    connect?: HelpCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHelpArticlesInput = {
    create?: XOR<UserCreateWithoutHelpArticlesInput, UserUncheckedCreateWithoutHelpArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelpArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumHelpArticleVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.HelpArticleVisibility
  }

  export type HelpCategoryUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: HelpCategoryCreateOrConnectWithoutArticlesInput
    upsert?: HelpCategoryUpsertWithoutArticlesInput
    connect?: HelpCategoryWhereUniqueInput
    update?: XOR<XOR<HelpCategoryUpdateToOneWithWhereWithoutArticlesInput, HelpCategoryUpdateWithoutArticlesInput>, HelpCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateOneRequiredWithoutHelpArticlesNestedInput = {
    create?: XOR<UserCreateWithoutHelpArticlesInput, UserUncheckedCreateWithoutHelpArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelpArticlesInput
    upsert?: UserUpsertWithoutHelpArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHelpArticlesInput, UserUpdateWithoutHelpArticlesInput>, UserUncheckedUpdateWithoutHelpArticlesInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type ClassScheduleCreateNestedManyWithoutRoomInput = {
    create?: XOR<ClassScheduleCreateWithoutRoomInput, ClassScheduleUncheckedCreateWithoutRoomInput> | ClassScheduleCreateWithoutRoomInput[] | ClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutRoomInput | ClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: ClassScheduleCreateManyRoomInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type ExamSlotCreateNestedManyWithoutRoomInput = {
    create?: XOR<ExamSlotCreateWithoutRoomInput, ExamSlotUncheckedCreateWithoutRoomInput> | ExamSlotCreateWithoutRoomInput[] | ExamSlotUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutRoomInput | ExamSlotCreateOrConnectWithoutRoomInput[]
    createMany?: ExamSlotCreateManyRoomInputEnvelope
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<ClassScheduleCreateWithoutRoomInput, ClassScheduleUncheckedCreateWithoutRoomInput> | ClassScheduleCreateWithoutRoomInput[] | ClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutRoomInput | ClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: ClassScheduleCreateManyRoomInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type ExamSlotUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<ExamSlotCreateWithoutRoomInput, ExamSlotUncheckedCreateWithoutRoomInput> | ExamSlotCreateWithoutRoomInput[] | ExamSlotUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutRoomInput | ExamSlotCreateOrConnectWithoutRoomInput[]
    createMany?: ExamSlotCreateManyRoomInputEnvelope
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
  }

  export type EnumRoomTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoomType
  }

  export type ClassScheduleUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutRoomInput, ClassScheduleUncheckedCreateWithoutRoomInput> | ClassScheduleCreateWithoutRoomInput[] | ClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutRoomInput | ClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutRoomInput | ClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ClassScheduleCreateManyRoomInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutRoomInput | ClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutRoomInput | ClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type ExamSlotUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ExamSlotCreateWithoutRoomInput, ExamSlotUncheckedCreateWithoutRoomInput> | ExamSlotCreateWithoutRoomInput[] | ExamSlotUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutRoomInput | ExamSlotCreateOrConnectWithoutRoomInput[]
    upsert?: ExamSlotUpsertWithWhereUniqueWithoutRoomInput | ExamSlotUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ExamSlotCreateManyRoomInputEnvelope
    set?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    disconnect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    delete?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    update?: ExamSlotUpdateWithWhereUniqueWithoutRoomInput | ExamSlotUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ExamSlotUpdateManyWithWhereWithoutRoomInput | ExamSlotUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ExamSlotScalarWhereInput | ExamSlotScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutRoomInput, ClassScheduleUncheckedCreateWithoutRoomInput> | ClassScheduleCreateWithoutRoomInput[] | ClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutRoomInput | ClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutRoomInput | ClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ClassScheduleCreateManyRoomInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutRoomInput | ClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutRoomInput | ClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type ExamSlotUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ExamSlotCreateWithoutRoomInput, ExamSlotUncheckedCreateWithoutRoomInput> | ExamSlotCreateWithoutRoomInput[] | ExamSlotUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutRoomInput | ExamSlotCreateOrConnectWithoutRoomInput[]
    upsert?: ExamSlotUpsertWithWhereUniqueWithoutRoomInput | ExamSlotUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ExamSlotCreateManyRoomInputEnvelope
    set?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    disconnect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    delete?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    update?: ExamSlotUpdateWithWhereUniqueWithoutRoomInput | ExamSlotUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ExamSlotUpdateManyWithWhereWithoutRoomInput | ExamSlotUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ExamSlotScalarWhereInput | ExamSlotScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutExamSchedulesInput = {
    create?: XOR<CourseCreateWithoutExamSchedulesInput, CourseUncheckedCreateWithoutExamSchedulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutExamSchedulesInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicTermCreateNestedOneWithoutExamSchedulesInput = {
    create?: XOR<AcademicTermCreateWithoutExamSchedulesInput, AcademicTermUncheckedCreateWithoutExamSchedulesInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutExamSchedulesInput
    connect?: AcademicTermWhereUniqueInput
  }

  export type ExamSlotCreateNestedManyWithoutExamScheduleInput = {
    create?: XOR<ExamSlotCreateWithoutExamScheduleInput, ExamSlotUncheckedCreateWithoutExamScheduleInput> | ExamSlotCreateWithoutExamScheduleInput[] | ExamSlotUncheckedCreateWithoutExamScheduleInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutExamScheduleInput | ExamSlotCreateOrConnectWithoutExamScheduleInput[]
    createMany?: ExamSlotCreateManyExamScheduleInputEnvelope
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
  }

  export type ExamSlotUncheckedCreateNestedManyWithoutExamScheduleInput = {
    create?: XOR<ExamSlotCreateWithoutExamScheduleInput, ExamSlotUncheckedCreateWithoutExamScheduleInput> | ExamSlotCreateWithoutExamScheduleInput[] | ExamSlotUncheckedCreateWithoutExamScheduleInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutExamScheduleInput | ExamSlotCreateOrConnectWithoutExamScheduleInput[]
    createMany?: ExamSlotCreateManyExamScheduleInputEnvelope
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
  }

  export type EnumExamTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExamType
  }

  export type EnumExamFormatFieldUpdateOperationsInput = {
    set?: $Enums.ExamFormat
  }

  export type CourseUpdateOneRequiredWithoutExamSchedulesNestedInput = {
    create?: XOR<CourseCreateWithoutExamSchedulesInput, CourseUncheckedCreateWithoutExamSchedulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutExamSchedulesInput
    upsert?: CourseUpsertWithoutExamSchedulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutExamSchedulesInput, CourseUpdateWithoutExamSchedulesInput>, CourseUncheckedUpdateWithoutExamSchedulesInput>
  }

  export type AcademicTermUpdateOneRequiredWithoutExamSchedulesNestedInput = {
    create?: XOR<AcademicTermCreateWithoutExamSchedulesInput, AcademicTermUncheckedCreateWithoutExamSchedulesInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutExamSchedulesInput
    upsert?: AcademicTermUpsertWithoutExamSchedulesInput
    connect?: AcademicTermWhereUniqueInput
    update?: XOR<XOR<AcademicTermUpdateToOneWithWhereWithoutExamSchedulesInput, AcademicTermUpdateWithoutExamSchedulesInput>, AcademicTermUncheckedUpdateWithoutExamSchedulesInput>
  }

  export type ExamSlotUpdateManyWithoutExamScheduleNestedInput = {
    create?: XOR<ExamSlotCreateWithoutExamScheduleInput, ExamSlotUncheckedCreateWithoutExamScheduleInput> | ExamSlotCreateWithoutExamScheduleInput[] | ExamSlotUncheckedCreateWithoutExamScheduleInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutExamScheduleInput | ExamSlotCreateOrConnectWithoutExamScheduleInput[]
    upsert?: ExamSlotUpsertWithWhereUniqueWithoutExamScheduleInput | ExamSlotUpsertWithWhereUniqueWithoutExamScheduleInput[]
    createMany?: ExamSlotCreateManyExamScheduleInputEnvelope
    set?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    disconnect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    delete?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    update?: ExamSlotUpdateWithWhereUniqueWithoutExamScheduleInput | ExamSlotUpdateWithWhereUniqueWithoutExamScheduleInput[]
    updateMany?: ExamSlotUpdateManyWithWhereWithoutExamScheduleInput | ExamSlotUpdateManyWithWhereWithoutExamScheduleInput[]
    deleteMany?: ExamSlotScalarWhereInput | ExamSlotScalarWhereInput[]
  }

  export type ExamSlotUncheckedUpdateManyWithoutExamScheduleNestedInput = {
    create?: XOR<ExamSlotCreateWithoutExamScheduleInput, ExamSlotUncheckedCreateWithoutExamScheduleInput> | ExamSlotCreateWithoutExamScheduleInput[] | ExamSlotUncheckedCreateWithoutExamScheduleInput[]
    connectOrCreate?: ExamSlotCreateOrConnectWithoutExamScheduleInput | ExamSlotCreateOrConnectWithoutExamScheduleInput[]
    upsert?: ExamSlotUpsertWithWhereUniqueWithoutExamScheduleInput | ExamSlotUpsertWithWhereUniqueWithoutExamScheduleInput[]
    createMany?: ExamSlotCreateManyExamScheduleInputEnvelope
    set?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    disconnect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    delete?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    connect?: ExamSlotWhereUniqueInput | ExamSlotWhereUniqueInput[]
    update?: ExamSlotUpdateWithWhereUniqueWithoutExamScheduleInput | ExamSlotUpdateWithWhereUniqueWithoutExamScheduleInput[]
    updateMany?: ExamSlotUpdateManyWithWhereWithoutExamScheduleInput | ExamSlotUpdateManyWithWhereWithoutExamScheduleInput[]
    deleteMany?: ExamSlotScalarWhereInput | ExamSlotScalarWhereInput[]
  }

  export type ExamScheduleCreateNestedOneWithoutExamSlotsInput = {
    create?: XOR<ExamScheduleCreateWithoutExamSlotsInput, ExamScheduleUncheckedCreateWithoutExamSlotsInput>
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutExamSlotsInput
    connect?: ExamScheduleWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutExamSlotsInput = {
    create?: XOR<RoomCreateWithoutExamSlotsInput, RoomUncheckedCreateWithoutExamSlotsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExamSlotsInput
    connect?: RoomWhereUniqueInput
  }

  export type ExamProctorCreateNestedManyWithoutExamSlotInput = {
    create?: XOR<ExamProctorCreateWithoutExamSlotInput, ExamProctorUncheckedCreateWithoutExamSlotInput> | ExamProctorCreateWithoutExamSlotInput[] | ExamProctorUncheckedCreateWithoutExamSlotInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutExamSlotInput | ExamProctorCreateOrConnectWithoutExamSlotInput[]
    createMany?: ExamProctorCreateManyExamSlotInputEnvelope
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
  }

  export type ExamProctorUncheckedCreateNestedManyWithoutExamSlotInput = {
    create?: XOR<ExamProctorCreateWithoutExamSlotInput, ExamProctorUncheckedCreateWithoutExamSlotInput> | ExamProctorCreateWithoutExamSlotInput[] | ExamProctorUncheckedCreateWithoutExamSlotInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutExamSlotInput | ExamProctorCreateOrConnectWithoutExamSlotInput[]
    createMany?: ExamProctorCreateManyExamSlotInputEnvelope
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
  }

  export type ExamScheduleUpdateOneRequiredWithoutExamSlotsNestedInput = {
    create?: XOR<ExamScheduleCreateWithoutExamSlotsInput, ExamScheduleUncheckedCreateWithoutExamSlotsInput>
    connectOrCreate?: ExamScheduleCreateOrConnectWithoutExamSlotsInput
    upsert?: ExamScheduleUpsertWithoutExamSlotsInput
    connect?: ExamScheduleWhereUniqueInput
    update?: XOR<XOR<ExamScheduleUpdateToOneWithWhereWithoutExamSlotsInput, ExamScheduleUpdateWithoutExamSlotsInput>, ExamScheduleUncheckedUpdateWithoutExamSlotsInput>
  }

  export type RoomUpdateOneRequiredWithoutExamSlotsNestedInput = {
    create?: XOR<RoomCreateWithoutExamSlotsInput, RoomUncheckedCreateWithoutExamSlotsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExamSlotsInput
    upsert?: RoomUpsertWithoutExamSlotsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutExamSlotsInput, RoomUpdateWithoutExamSlotsInput>, RoomUncheckedUpdateWithoutExamSlotsInput>
  }

  export type ExamProctorUpdateManyWithoutExamSlotNestedInput = {
    create?: XOR<ExamProctorCreateWithoutExamSlotInput, ExamProctorUncheckedCreateWithoutExamSlotInput> | ExamProctorCreateWithoutExamSlotInput[] | ExamProctorUncheckedCreateWithoutExamSlotInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutExamSlotInput | ExamProctorCreateOrConnectWithoutExamSlotInput[]
    upsert?: ExamProctorUpsertWithWhereUniqueWithoutExamSlotInput | ExamProctorUpsertWithWhereUniqueWithoutExamSlotInput[]
    createMany?: ExamProctorCreateManyExamSlotInputEnvelope
    set?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    disconnect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    delete?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    update?: ExamProctorUpdateWithWhereUniqueWithoutExamSlotInput | ExamProctorUpdateWithWhereUniqueWithoutExamSlotInput[]
    updateMany?: ExamProctorUpdateManyWithWhereWithoutExamSlotInput | ExamProctorUpdateManyWithWhereWithoutExamSlotInput[]
    deleteMany?: ExamProctorScalarWhereInput | ExamProctorScalarWhereInput[]
  }

  export type ExamProctorUncheckedUpdateManyWithoutExamSlotNestedInput = {
    create?: XOR<ExamProctorCreateWithoutExamSlotInput, ExamProctorUncheckedCreateWithoutExamSlotInput> | ExamProctorCreateWithoutExamSlotInput[] | ExamProctorUncheckedCreateWithoutExamSlotInput[]
    connectOrCreate?: ExamProctorCreateOrConnectWithoutExamSlotInput | ExamProctorCreateOrConnectWithoutExamSlotInput[]
    upsert?: ExamProctorUpsertWithWhereUniqueWithoutExamSlotInput | ExamProctorUpsertWithWhereUniqueWithoutExamSlotInput[]
    createMany?: ExamProctorCreateManyExamSlotInputEnvelope
    set?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    disconnect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    delete?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    connect?: ExamProctorWhereUniqueInput | ExamProctorWhereUniqueInput[]
    update?: ExamProctorUpdateWithWhereUniqueWithoutExamSlotInput | ExamProctorUpdateWithWhereUniqueWithoutExamSlotInput[]
    updateMany?: ExamProctorUpdateManyWithWhereWithoutExamSlotInput | ExamProctorUpdateManyWithWhereWithoutExamSlotInput[]
    deleteMany?: ExamProctorScalarWhereInput | ExamProctorScalarWhereInput[]
  }

  export type ExamSlotCreateNestedOneWithoutProctorsInput = {
    create?: XOR<ExamSlotCreateWithoutProctorsInput, ExamSlotUncheckedCreateWithoutProctorsInput>
    connectOrCreate?: ExamSlotCreateOrConnectWithoutProctorsInput
    connect?: ExamSlotWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutProctorDutiesInput = {
    create?: XOR<PersonnelCreateWithoutProctorDutiesInput, PersonnelUncheckedCreateWithoutProctorDutiesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutProctorDutiesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumProctorRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProctorRole
  }

  export type ExamSlotUpdateOneRequiredWithoutProctorsNestedInput = {
    create?: XOR<ExamSlotCreateWithoutProctorsInput, ExamSlotUncheckedCreateWithoutProctorsInput>
    connectOrCreate?: ExamSlotCreateOrConnectWithoutProctorsInput
    upsert?: ExamSlotUpsertWithoutProctorsInput
    connect?: ExamSlotWhereUniqueInput
    update?: XOR<XOR<ExamSlotUpdateToOneWithWhereWithoutProctorsInput, ExamSlotUpdateWithoutProctorsInput>, ExamSlotUncheckedUpdateWithoutProctorsInput>
  }

  export type PersonnelUpdateOneRequiredWithoutProctorDutiesNestedInput = {
    create?: XOR<PersonnelCreateWithoutProctorDutiesInput, PersonnelUncheckedCreateWithoutProctorDutiesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutProctorDutiesInput
    upsert?: PersonnelUpsertWithoutProctorDutiesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutProctorDutiesInput, PersonnelUpdateWithoutProctorDutiesInput>, PersonnelUncheckedUpdateWithoutProctorDutiesInput>
  }

  export type PersonnelCreateNestedOneWithoutTeachingLoadsInput = {
    create?: XOR<PersonnelCreateWithoutTeachingLoadsInput, PersonnelUncheckedCreateWithoutTeachingLoadsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutTeachingLoadsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type AcademicTermCreateNestedOneWithoutTeachingLoadsInput = {
    create?: XOR<AcademicTermCreateWithoutTeachingLoadsInput, AcademicTermUncheckedCreateWithoutTeachingLoadsInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutTeachingLoadsInput
    connect?: AcademicTermWhereUniqueInput
  }

  export type PersonnelUpdateOneRequiredWithoutTeachingLoadsNestedInput = {
    create?: XOR<PersonnelCreateWithoutTeachingLoadsInput, PersonnelUncheckedCreateWithoutTeachingLoadsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutTeachingLoadsInput
    upsert?: PersonnelUpsertWithoutTeachingLoadsInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutTeachingLoadsInput, PersonnelUpdateWithoutTeachingLoadsInput>, PersonnelUncheckedUpdateWithoutTeachingLoadsInput>
  }

  export type AcademicTermUpdateOneRequiredWithoutTeachingLoadsNestedInput = {
    create?: XOR<AcademicTermCreateWithoutTeachingLoadsInput, AcademicTermUncheckedCreateWithoutTeachingLoadsInput>
    connectOrCreate?: AcademicTermCreateOrConnectWithoutTeachingLoadsInput
    upsert?: AcademicTermUpsertWithoutTeachingLoadsInput
    connect?: AcademicTermWhereUniqueInput
    update?: XOR<XOR<AcademicTermUpdateToOneWithWhereWithoutTeachingLoadsInput, AcademicTermUpdateWithoutTeachingLoadsInput>, AcademicTermUncheckedUpdateWithoutTeachingLoadsInput>
  }

  export type StudentCreateNestedOneWithoutLeaveRequestsInput = {
    create?: XOR<StudentCreateWithoutLeaveRequestsInput, StudentUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLeaveRequestsInput
    connect?: StudentWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutReviewedLeaveRequestsInput = {
    create?: XOR<PersonnelCreateWithoutReviewedLeaveRequestsInput, PersonnelUncheckedCreateWithoutReviewedLeaveRequestsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutReviewedLeaveRequestsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumLeaveRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveRequestStatus
  }

  export type StudentUpdateOneRequiredWithoutLeaveRequestsNestedInput = {
    create?: XOR<StudentCreateWithoutLeaveRequestsInput, StudentUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLeaveRequestsInput
    upsert?: StudentUpsertWithoutLeaveRequestsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutLeaveRequestsInput, StudentUpdateWithoutLeaveRequestsInput>, StudentUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type PersonnelUpdateOneWithoutReviewedLeaveRequestsNestedInput = {
    create?: XOR<PersonnelCreateWithoutReviewedLeaveRequestsInput, PersonnelUncheckedCreateWithoutReviewedLeaveRequestsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutReviewedLeaveRequestsInput
    upsert?: PersonnelUpsertWithoutReviewedLeaveRequestsInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutReviewedLeaveRequestsInput, PersonnelUpdateWithoutReviewedLeaveRequestsInput>, PersonnelUncheckedUpdateWithoutReviewedLeaveRequestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDegreeLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeLevel | EnumDegreeLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeLevel[]
    notIn?: $Enums.DegreeLevel[]
    not?: NestedEnumDegreeLevelFilter<$PrismaModel> | $Enums.DegreeLevel
  }

  export type NestedEnumDegreeLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeLevel | EnumDegreeLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeLevel[]
    notIn?: $Enums.DegreeLevel[]
    not?: NestedEnumDegreeLevelWithAggregatesFilter<$PrismaModel> | $Enums.DegreeLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDegreeLevelFilter<$PrismaModel>
    _max?: NestedEnumDegreeLevelFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[]
    notIn?: $Enums.ApplicationStatus[]
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumStudentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeFilter<$PrismaModel> | $Enums.StudentType
  }

  export type NestedEnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[]
    notIn?: $Enums.StudentStatus[]
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type NestedEnumStudentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeWithAggregatesFilter<$PrismaModel> | $Enums.StudentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentTypeFilter<$PrismaModel>
    _max?: NestedEnumStudentTypeFilter<$PrismaModel>
  }

  export type NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[]
    notIn?: $Enums.StudentStatus[]
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[]
    notIn?: $Enums.InvoiceStatus[]
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[]
    notIn?: $Enums.InvoiceStatus[]
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumAnnouncementTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementTarget | EnumAnnouncementTargetFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementTarget[]
    notIn?: $Enums.AnnouncementTarget[]
    not?: NestedEnumAnnouncementTargetFilter<$PrismaModel> | $Enums.AnnouncementTarget
  }

  export type NestedEnumAnnouncementTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementTarget | EnumAnnouncementTargetFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementTarget[]
    notIn?: $Enums.AnnouncementTarget[]
    not?: NestedEnumAnnouncementTargetWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementTargetFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementTargetFilter<$PrismaModel>
  }

  export type NestedEnumHelpArticleVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpArticleVisibility | EnumHelpArticleVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.HelpArticleVisibility[]
    notIn?: $Enums.HelpArticleVisibility[]
    not?: NestedEnumHelpArticleVisibilityFilter<$PrismaModel> | $Enums.HelpArticleVisibility
  }

  export type NestedEnumHelpArticleVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpArticleVisibility | EnumHelpArticleVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.HelpArticleVisibility[]
    notIn?: $Enums.HelpArticleVisibility[]
    not?: NestedEnumHelpArticleVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.HelpArticleVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHelpArticleVisibilityFilter<$PrismaModel>
    _max?: NestedEnumHelpArticleVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type NestedEnumExamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamType[]
    notIn?: $Enums.ExamType[]
    not?: NestedEnumExamTypeFilter<$PrismaModel> | $Enums.ExamType
  }

  export type NestedEnumExamFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamFormat | EnumExamFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExamFormat[]
    notIn?: $Enums.ExamFormat[]
    not?: NestedEnumExamFormatFilter<$PrismaModel> | $Enums.ExamFormat
  }

  export type NestedEnumExamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamType[]
    notIn?: $Enums.ExamType[]
    not?: NestedEnumExamTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExamType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamTypeFilter<$PrismaModel>
    _max?: NestedEnumExamTypeFilter<$PrismaModel>
  }

  export type NestedEnumExamFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamFormat | EnumExamFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExamFormat[]
    notIn?: $Enums.ExamFormat[]
    not?: NestedEnumExamFormatWithAggregatesFilter<$PrismaModel> | $Enums.ExamFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamFormatFilter<$PrismaModel>
    _max?: NestedEnumExamFormatFilter<$PrismaModel>
  }

  export type NestedEnumProctorRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProctorRole | EnumProctorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProctorRole[]
    notIn?: $Enums.ProctorRole[]
    not?: NestedEnumProctorRoleFilter<$PrismaModel> | $Enums.ProctorRole
  }

  export type NestedEnumProctorRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProctorRole | EnumProctorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProctorRole[]
    notIn?: $Enums.ProctorRole[]
    not?: NestedEnumProctorRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProctorRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProctorRoleFilter<$PrismaModel>
    _max?: NestedEnumProctorRoleFilter<$PrismaModel>
  }

  export type NestedEnumLeaveRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveRequestStatus | EnumLeaveRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveRequestStatus[]
    notIn?: $Enums.LeaveRequestStatus[]
    not?: NestedEnumLeaveRequestStatusFilter<$PrismaModel> | $Enums.LeaveRequestStatus
  }

  export type NestedEnumLeaveRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveRequestStatus | EnumLeaveRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveRequestStatus[]
    notIn?: $Enums.LeaveRequestStatus[]
    not?: NestedEnumLeaveRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveRequestStatusFilter<$PrismaModel>
  }

  export type PersonnelCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutUserInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutUserInput, PersonnelUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutStudentsInput
    studentGroup?: StudentGroupCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type ApplicantCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    educationHistory?: EducationHistoryCreateNestedManyWithoutApplicantInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    educationHistory?: EducationHistoryUncheckedCreateNestedManyWithoutApplicantInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutUserInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutUserInput, ApplicantUncheckedCreateWithoutUserInput>
  }

  export type SystemLogCreateWithoutUserInput = {
    id?: string
    action: string
    details?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    details?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SystemLogCreateOrConnectWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type SystemLogCreateManyUserInputEnvelope = {
    data: SystemLogCreateManyUserInput | SystemLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutAuthorInput = {
    id?: string
    title: string
    imageUrl?: string | null
    content: string
    target?: $Enums.AnnouncementTarget
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    imageUrl?: string | null
    content: string
    target?: $Enums.AnnouncementTarget
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type AnnouncementCreateManyAuthorInputEnvelope = {
    data: AnnouncementCreateManyAuthorInput | AnnouncementCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type HelpArticleCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: HelpCategoryCreateNestedOneWithoutArticlesInput
  }

  export type HelpArticleUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleCreateOrConnectWithoutAuthorInput = {
    where: HelpArticleWhereUniqueInput
    create: XOR<HelpArticleCreateWithoutAuthorInput, HelpArticleUncheckedCreateWithoutAuthorInput>
  }

  export type HelpArticleCreateManyAuthorInputEnvelope = {
    data: HelpArticleCreateManyAuthorInput | HelpArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelUpsertWithoutUserInput = {
    update: XOR<PersonnelUpdateWithoutUserInput, PersonnelUncheckedUpdateWithoutUserInput>
    create: XOR<PersonnelCreateWithoutUserInput, PersonnelUncheckedCreateWithoutUserInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutUserInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutUserInput, PersonnelUncheckedUpdateWithoutUserInput>
  }

  export type PersonnelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    studentGroup?: StudentGroupUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ApplicantUpsertWithoutUserInput = {
    update: XOR<ApplicantUpdateWithoutUserInput, ApplicantUncheckedUpdateWithoutUserInput>
    create: XOR<ApplicantCreateWithoutUserInput, ApplicantUncheckedCreateWithoutUserInput>
    where?: ApplicantWhereInput
  }

  export type ApplicantUpdateToOneWithWhereWithoutUserInput = {
    where?: ApplicantWhereInput
    data: XOR<ApplicantUpdateWithoutUserInput, ApplicantUncheckedUpdateWithoutUserInput>
  }

  export type ApplicantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationHistory?: EducationHistoryUpdateManyWithoutApplicantNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationHistory?: EducationHistoryUncheckedUpdateManyWithoutApplicantNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type SystemLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    update: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type SystemLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    data: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
  }

  export type SystemLogUpdateManyWithWhereWithoutUserInput = {
    where: SystemLogScalarWhereInput
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SystemLogScalarWhereInput = {
    AND?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    OR?: SystemLogScalarWhereInput[]
    NOT?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    userId?: StringNullableFilter<"SystemLog"> | string | null
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutAuthorInput, AnnouncementUncheckedUpdateWithoutAuthorInput>
    create: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutAuthorInput, AnnouncementUncheckedUpdateWithoutAuthorInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutAuthorInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    imageUrl?: StringNullableFilter<"Announcement"> | string | null
    content?: StringFilter<"Announcement"> | string
    target?: EnumAnnouncementTargetFilter<"Announcement"> | $Enums.AnnouncementTarget
    isPublished?: BoolFilter<"Announcement"> | boolean
    publishedAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    authorId?: StringFilter<"Announcement"> | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type HelpArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: HelpArticleWhereUniqueInput
    update: XOR<HelpArticleUpdateWithoutAuthorInput, HelpArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<HelpArticleCreateWithoutAuthorInput, HelpArticleUncheckedCreateWithoutAuthorInput>
  }

  export type HelpArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: HelpArticleWhereUniqueInput
    data: XOR<HelpArticleUpdateWithoutAuthorInput, HelpArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type HelpArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: HelpArticleScalarWhereInput
    data: XOR<HelpArticleUpdateManyMutationInput, HelpArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type HelpArticleScalarWhereInput = {
    AND?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
    OR?: HelpArticleScalarWhereInput[]
    NOT?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
    id?: StringFilter<"HelpArticle"> | string
    title?: StringFilter<"HelpArticle"> | string
    content?: StringFilter<"HelpArticle"> | string
    categoryId?: StringFilter<"HelpArticle"> | string
    visibility?: EnumHelpArticleVisibilityFilter<"HelpArticle"> | $Enums.HelpArticleVisibility
    isPublished?: BoolFilter<"HelpArticle"> | boolean
    authorId?: StringFilter<"HelpArticle"> | string
    views?: IntFilter<"HelpArticle"> | number
    createdAt?: DateTimeFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HelpArticle"> | Date | string
  }

  export type UserCreateWithoutPersonnelProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantCreateNestedOneWithoutUserInput
    logs?: SystemLogCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutPersonnelProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantUncheckedCreateNestedOneWithoutUserInput
    logs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutPersonnelProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonnelProfileInput, UserUncheckedCreateWithoutPersonnelProfileInput>
  }

  export type FacultyCreateWithoutPersonnelInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    departments?: DepartmentCreateNestedManyWithoutFacultyInput
    programs?: ProgramCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutPersonnelInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacultyInput
    programs?: ProgramUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutPersonnelInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutPersonnelInput, FacultyUncheckedCreateWithoutPersonnelInput>
  }

  export type DepartmentCreateWithoutPersonnelInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    faculty: FacultyCreateNestedOneWithoutDepartmentsInput
    programs?: ProgramCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPersonnelInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    facultyId: string
    programs?: ProgramUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPersonnelInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPersonnelInput, DepartmentUncheckedCreateWithoutPersonnelInput>
  }

  export type ClassSectionCreateWithoutInstructorInput = {
    id?: string
    sectionNumber: string
    capacity: number
    course: CourseCreateNestedOneWithoutSectionsInput
    term: AcademicTermCreateNestedOneWithoutSectionsInput
    schedules?: ClassScheduleCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionUncheckedCreateWithoutInstructorInput = {
    id?: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionCreateOrConnectWithoutInstructorInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutInstructorInput, ClassSectionUncheckedCreateWithoutInstructorInput>
  }

  export type ClassSectionCreateManyInstructorInputEnvelope = {
    data: ClassSectionCreateManyInstructorInput | ClassSectionCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type InterviewSlotInterviewerCreateWithoutInterviewerInput = {
    id?: string
    slot: InterviewSlotCreateNestedOneWithoutInterviewersInput
  }

  export type InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput = {
    id?: string
    slotId: string
  }

  export type InterviewSlotInterviewerCreateOrConnectWithoutInterviewerInput = {
    where: InterviewSlotInterviewerWhereUniqueInput
    create: XOR<InterviewSlotInterviewerCreateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput>
  }

  export type InterviewSlotInterviewerCreateManyInterviewerInputEnvelope = {
    data: InterviewSlotInterviewerCreateManyInterviewerInput | InterviewSlotInterviewerCreateManyInterviewerInput[]
    skipDuplicates?: boolean
  }

  export type ClassScheduleCreateWithoutInstructorInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    section: ClassSectionCreateNestedOneWithoutSchedulesInput
    room?: RoomCreateNestedOneWithoutSchedulesInput
    course?: CourseCreateNestedOneWithoutSchedulesInput
    term?: AcademicTermCreateNestedOneWithoutSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutInstructorInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    termId?: string | null
  }

  export type ClassScheduleCreateOrConnectWithoutInstructorInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutInstructorInput, ClassScheduleUncheckedCreateWithoutInstructorInput>
  }

  export type ClassScheduleCreateManyInstructorInputEnvelope = {
    data: ClassScheduleCreateManyInstructorInput | ClassScheduleCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type TeachingLoadCreateWithoutInstructorInput = {
    id?: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    term: AcademicTermCreateNestedOneWithoutTeachingLoadsInput
  }

  export type TeachingLoadUncheckedCreateWithoutInstructorInput = {
    id?: string
    termId: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingLoadCreateOrConnectWithoutInstructorInput = {
    where: TeachingLoadWhereUniqueInput
    create: XOR<TeachingLoadCreateWithoutInstructorInput, TeachingLoadUncheckedCreateWithoutInstructorInput>
  }

  export type TeachingLoadCreateManyInstructorInputEnvelope = {
    data: TeachingLoadCreateManyInstructorInput | TeachingLoadCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type ExamProctorCreateWithoutProctorInput = {
    id?: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examSlot: ExamSlotCreateNestedOneWithoutProctorsInput
  }

  export type ExamProctorUncheckedCreateWithoutProctorInput = {
    id?: string
    examSlotId: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamProctorCreateOrConnectWithoutProctorInput = {
    where: ExamProctorWhereUniqueInput
    create: XOR<ExamProctorCreateWithoutProctorInput, ExamProctorUncheckedCreateWithoutProctorInput>
  }

  export type ExamProctorCreateManyProctorInputEnvelope = {
    data: ExamProctorCreateManyProctorInput | ExamProctorCreateManyProctorInput[]
    skipDuplicates?: boolean
  }

  export type StudentGroupCreateWithoutAdvisorInput = {
    id?: string
    name: string
    admissionYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutStudentGroupsInput
    students?: StudentCreateNestedManyWithoutStudentGroupInput
    sections?: ClassSectionCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupUncheckedCreateWithoutAdvisorInput = {
    id?: string
    name: string
    admissionYear: number
    programId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutStudentGroupInput
    sections?: ClassSectionUncheckedCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupCreateOrConnectWithoutAdvisorInput = {
    where: StudentGroupWhereUniqueInput
    create: XOR<StudentGroupCreateWithoutAdvisorInput, StudentGroupUncheckedCreateWithoutAdvisorInput>
  }

  export type StudentGroupCreateManyAdvisorInputEnvelope = {
    data: StudentGroupCreateManyAdvisorInput | StudentGroupCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutReviewerInput = {
    id?: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLeaveRequestsInput
  }

  export type LeaveRequestUncheckedCreateWithoutReviewerInput = {
    id?: string
    studentId: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateOrConnectWithoutReviewerInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutReviewerInput, LeaveRequestUncheckedCreateWithoutReviewerInput>
  }

  export type LeaveRequestCreateManyReviewerInputEnvelope = {
    data: LeaveRequestCreateManyReviewerInput | LeaveRequestCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPersonnelProfileInput = {
    update: XOR<UserUpdateWithoutPersonnelProfileInput, UserUncheckedUpdateWithoutPersonnelProfileInput>
    create: XOR<UserCreateWithoutPersonnelProfileInput, UserUncheckedCreateWithoutPersonnelProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonnelProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonnelProfileInput, UserUncheckedUpdateWithoutPersonnelProfileInput>
  }

  export type UserUpdateWithoutPersonnelProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUpdateOneWithoutUserNestedInput
    logs?: SystemLogUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonnelProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUncheckedUpdateOneWithoutUserNestedInput
    logs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type FacultyUpsertWithoutPersonnelInput = {
    update: XOR<FacultyUpdateWithoutPersonnelInput, FacultyUncheckedUpdateWithoutPersonnelInput>
    create: XOR<FacultyCreateWithoutPersonnelInput, FacultyUncheckedCreateWithoutPersonnelInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutPersonnelInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutPersonnelInput, FacultyUncheckedUpdateWithoutPersonnelInput>
  }

  export type FacultyUpdateWithoutPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUpdateManyWithoutFacultyNestedInput
    programs?: ProgramUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutFacultyNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type DepartmentUpsertWithoutPersonnelInput = {
    update: XOR<DepartmentUpdateWithoutPersonnelInput, DepartmentUncheckedUpdateWithoutPersonnelInput>
    create: XOR<DepartmentCreateWithoutPersonnelInput, DepartmentUncheckedCreateWithoutPersonnelInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutPersonnelInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutPersonnelInput, DepartmentUncheckedUpdateWithoutPersonnelInput>
  }

  export type DepartmentUpdateWithoutPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutDepartmentsNestedInput
    programs?: ProgramUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    programs?: ProgramUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ClassSectionUpsertWithWhereUniqueWithoutInstructorInput = {
    where: ClassSectionWhereUniqueInput
    update: XOR<ClassSectionUpdateWithoutInstructorInput, ClassSectionUncheckedUpdateWithoutInstructorInput>
    create: XOR<ClassSectionCreateWithoutInstructorInput, ClassSectionUncheckedCreateWithoutInstructorInput>
  }

  export type ClassSectionUpdateWithWhereUniqueWithoutInstructorInput = {
    where: ClassSectionWhereUniqueInput
    data: XOR<ClassSectionUpdateWithoutInstructorInput, ClassSectionUncheckedUpdateWithoutInstructorInput>
  }

  export type ClassSectionUpdateManyWithWhereWithoutInstructorInput = {
    where: ClassSectionScalarWhereInput
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyWithoutInstructorInput>
  }

  export type ClassSectionScalarWhereInput = {
    AND?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
    OR?: ClassSectionScalarWhereInput[]
    NOT?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
    id?: StringFilter<"ClassSection"> | string
    courseId?: StringFilter<"ClassSection"> | string
    termId?: StringFilter<"ClassSection"> | string
    sectionNumber?: StringFilter<"ClassSection"> | string
    capacity?: IntFilter<"ClassSection"> | number
    instructorId?: StringNullableFilter<"ClassSection"> | string | null
  }

  export type InterviewSlotInterviewerUpsertWithWhereUniqueWithoutInterviewerInput = {
    where: InterviewSlotInterviewerWhereUniqueInput
    update: XOR<InterviewSlotInterviewerUpdateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedUpdateWithoutInterviewerInput>
    create: XOR<InterviewSlotInterviewerCreateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedCreateWithoutInterviewerInput>
  }

  export type InterviewSlotInterviewerUpdateWithWhereUniqueWithoutInterviewerInput = {
    where: InterviewSlotInterviewerWhereUniqueInput
    data: XOR<InterviewSlotInterviewerUpdateWithoutInterviewerInput, InterviewSlotInterviewerUncheckedUpdateWithoutInterviewerInput>
  }

  export type InterviewSlotInterviewerUpdateManyWithWhereWithoutInterviewerInput = {
    where: InterviewSlotInterviewerScalarWhereInput
    data: XOR<InterviewSlotInterviewerUpdateManyMutationInput, InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerInput>
  }

  export type InterviewSlotInterviewerScalarWhereInput = {
    AND?: InterviewSlotInterviewerScalarWhereInput | InterviewSlotInterviewerScalarWhereInput[]
    OR?: InterviewSlotInterviewerScalarWhereInput[]
    NOT?: InterviewSlotInterviewerScalarWhereInput | InterviewSlotInterviewerScalarWhereInput[]
    id?: StringFilter<"InterviewSlotInterviewer"> | string
    slotId?: StringFilter<"InterviewSlotInterviewer"> | string
    interviewerId?: StringFilter<"InterviewSlotInterviewer"> | string
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutInstructorInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutInstructorInput, ClassScheduleUncheckedUpdateWithoutInstructorInput>
    create: XOR<ClassScheduleCreateWithoutInstructorInput, ClassScheduleUncheckedCreateWithoutInstructorInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutInstructorInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutInstructorInput, ClassScheduleUncheckedUpdateWithoutInstructorInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutInstructorInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutInstructorInput>
  }

  export type ClassScheduleScalarWhereInput = {
    AND?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
    OR?: ClassScheduleScalarWhereInput[]
    NOT?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
    id?: StringFilter<"ClassSchedule"> | string
    sectionId?: StringFilter<"ClassSchedule"> | string
    day?: EnumDayOfWeekFilter<"ClassSchedule"> | $Enums.DayOfWeek
    startTime?: StringFilter<"ClassSchedule"> | string
    endTime?: StringFilter<"ClassSchedule"> | string
    roomId?: StringNullableFilter<"ClassSchedule"> | string | null
    courseId?: StringNullableFilter<"ClassSchedule"> | string | null
    instructorId?: StringNullableFilter<"ClassSchedule"> | string | null
    termId?: StringNullableFilter<"ClassSchedule"> | string | null
  }

  export type TeachingLoadUpsertWithWhereUniqueWithoutInstructorInput = {
    where: TeachingLoadWhereUniqueInput
    update: XOR<TeachingLoadUpdateWithoutInstructorInput, TeachingLoadUncheckedUpdateWithoutInstructorInput>
    create: XOR<TeachingLoadCreateWithoutInstructorInput, TeachingLoadUncheckedCreateWithoutInstructorInput>
  }

  export type TeachingLoadUpdateWithWhereUniqueWithoutInstructorInput = {
    where: TeachingLoadWhereUniqueInput
    data: XOR<TeachingLoadUpdateWithoutInstructorInput, TeachingLoadUncheckedUpdateWithoutInstructorInput>
  }

  export type TeachingLoadUpdateManyWithWhereWithoutInstructorInput = {
    where: TeachingLoadScalarWhereInput
    data: XOR<TeachingLoadUpdateManyMutationInput, TeachingLoadUncheckedUpdateManyWithoutInstructorInput>
  }

  export type TeachingLoadScalarWhereInput = {
    AND?: TeachingLoadScalarWhereInput | TeachingLoadScalarWhereInput[]
    OR?: TeachingLoadScalarWhereInput[]
    NOT?: TeachingLoadScalarWhereInput | TeachingLoadScalarWhereInput[]
    id?: StringFilter<"TeachingLoad"> | string
    instructorId?: StringFilter<"TeachingLoad"> | string
    termId?: StringFilter<"TeachingLoad"> | string
    lectureHours?: FloatFilter<"TeachingLoad"> | number
    labHours?: FloatFilter<"TeachingLoad"> | number
    totalHours?: FloatFilter<"TeachingLoad"> | number
    courseCount?: IntFilter<"TeachingLoad"> | number
    isApproved?: BoolFilter<"TeachingLoad"> | boolean
    approvedBy?: StringNullableFilter<"TeachingLoad"> | string | null
    approvedAt?: DateTimeNullableFilter<"TeachingLoad"> | Date | string | null
    createdAt?: DateTimeFilter<"TeachingLoad"> | Date | string
    updatedAt?: DateTimeFilter<"TeachingLoad"> | Date | string
  }

  export type ExamProctorUpsertWithWhereUniqueWithoutProctorInput = {
    where: ExamProctorWhereUniqueInput
    update: XOR<ExamProctorUpdateWithoutProctorInput, ExamProctorUncheckedUpdateWithoutProctorInput>
    create: XOR<ExamProctorCreateWithoutProctorInput, ExamProctorUncheckedCreateWithoutProctorInput>
  }

  export type ExamProctorUpdateWithWhereUniqueWithoutProctorInput = {
    where: ExamProctorWhereUniqueInput
    data: XOR<ExamProctorUpdateWithoutProctorInput, ExamProctorUncheckedUpdateWithoutProctorInput>
  }

  export type ExamProctorUpdateManyWithWhereWithoutProctorInput = {
    where: ExamProctorScalarWhereInput
    data: XOR<ExamProctorUpdateManyMutationInput, ExamProctorUncheckedUpdateManyWithoutProctorInput>
  }

  export type ExamProctorScalarWhereInput = {
    AND?: ExamProctorScalarWhereInput | ExamProctorScalarWhereInput[]
    OR?: ExamProctorScalarWhereInput[]
    NOT?: ExamProctorScalarWhereInput | ExamProctorScalarWhereInput[]
    id?: StringFilter<"ExamProctor"> | string
    examSlotId?: StringFilter<"ExamProctor"> | string
    proctorId?: StringFilter<"ExamProctor"> | string
    role?: EnumProctorRoleFilter<"ExamProctor"> | $Enums.ProctorRole
    isConfirmed?: BoolFilter<"ExamProctor"> | boolean
    createdAt?: DateTimeFilter<"ExamProctor"> | Date | string
    updatedAt?: DateTimeFilter<"ExamProctor"> | Date | string
  }

  export type StudentGroupUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: StudentGroupWhereUniqueInput
    update: XOR<StudentGroupUpdateWithoutAdvisorInput, StudentGroupUncheckedUpdateWithoutAdvisorInput>
    create: XOR<StudentGroupCreateWithoutAdvisorInput, StudentGroupUncheckedCreateWithoutAdvisorInput>
  }

  export type StudentGroupUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: StudentGroupWhereUniqueInput
    data: XOR<StudentGroupUpdateWithoutAdvisorInput, StudentGroupUncheckedUpdateWithoutAdvisorInput>
  }

  export type StudentGroupUpdateManyWithWhereWithoutAdvisorInput = {
    where: StudentGroupScalarWhereInput
    data: XOR<StudentGroupUpdateManyMutationInput, StudentGroupUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type StudentGroupScalarWhereInput = {
    AND?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
    OR?: StudentGroupScalarWhereInput[]
    NOT?: StudentGroupScalarWhereInput | StudentGroupScalarWhereInput[]
    id?: StringFilter<"StudentGroup"> | string
    name?: StringFilter<"StudentGroup"> | string
    admissionYear?: IntFilter<"StudentGroup"> | number
    programId?: StringFilter<"StudentGroup"> | string
    advisorId?: StringNullableFilter<"StudentGroup"> | string | null
    createdAt?: DateTimeFilter<"StudentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"StudentGroup"> | Date | string
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutReviewerInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutReviewerInput, LeaveRequestUncheckedUpdateWithoutReviewerInput>
    create: XOR<LeaveRequestCreateWithoutReviewerInput, LeaveRequestUncheckedCreateWithoutReviewerInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutReviewerInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutReviewerInput, LeaveRequestUncheckedUpdateWithoutReviewerInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutReviewerInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutReviewerInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    studentId?: StringFilter<"LeaveRequest"> | string
    reason?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveRequestStatusFilter<"LeaveRequest"> | $Enums.LeaveRequestStatus
    reviewedBy?: StringNullableFilter<"LeaveRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    reviewNote?: StringNullableFilter<"LeaveRequest"> | string | null
    documentUrl?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }

  export type DepartmentCreateWithoutFacultyInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    programs?: ProgramCreateNestedManyWithoutDepartmentInput
    personnel?: PersonnelCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutFacultyInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    programs?: ProgramUncheckedCreateNestedManyWithoutDepartmentInput
    personnel?: PersonnelUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
  }

  export type DepartmentCreateManyFacultyInputEnvelope = {
    data: DepartmentCreateManyFacultyInput | DepartmentCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutFacultyInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    department: DepartmentCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    students?: StudentCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutFacultyInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    departmentId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutFacultyInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>
  }

  export type ProgramCreateManyFacultyInputEnvelope = {
    data: ProgramCreateManyFacultyInput | ProgramCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelCreateWithoutFacultyInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutFacultyInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutFacultyInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutFacultyInput, PersonnelUncheckedCreateWithoutFacultyInput>
  }

  export type PersonnelCreateManyFacultyInputEnvelope = {
    data: PersonnelCreateManyFacultyInput | PersonnelCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutFacultyInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutFacultyInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    nameTh?: StringFilter<"Department"> | string
    nameEn?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    facultyId?: StringFilter<"Department"> | string
  }

  export type ProgramUpsertWithWhereUniqueWithoutFacultyInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutFacultyInput, ProgramUncheckedUpdateWithoutFacultyInput>
    create: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutFacultyInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutFacultyInput, ProgramUncheckedUpdateWithoutFacultyInput>
  }

  export type ProgramUpdateManyWithWhereWithoutFacultyInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutFacultyInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: StringFilter<"Program"> | string
    nameTh?: StringFilter<"Program"> | string
    nameEn?: StringFilter<"Program"> | string
    degreeLevel?: EnumDegreeLevelFilter<"Program"> | $Enums.DegreeLevel
    description?: StringNullableFilter<"Program"> | string | null
    isAcceptingApplications?: BoolFilter<"Program"> | boolean
    credits?: IntNullableFilter<"Program"> | number | null
    duration?: StringNullableFilter<"Program"> | string | null
    objectives?: StringNullableFilter<"Program"> | string | null
    structure?: StringNullableFilter<"Program"> | string | null
    admissionRequirements?: StringNullableFilter<"Program"> | string | null
    careerOpportunities?: StringNullableFilter<"Program"> | string | null
    facultyId?: StringFilter<"Program"> | string
    departmentId?: StringFilter<"Program"> | string
  }

  export type PersonnelUpsertWithWhereUniqueWithoutFacultyInput = {
    where: PersonnelWhereUniqueInput
    update: XOR<PersonnelUpdateWithoutFacultyInput, PersonnelUncheckedUpdateWithoutFacultyInput>
    create: XOR<PersonnelCreateWithoutFacultyInput, PersonnelUncheckedCreateWithoutFacultyInput>
  }

  export type PersonnelUpdateWithWhereUniqueWithoutFacultyInput = {
    where: PersonnelWhereUniqueInput
    data: XOR<PersonnelUpdateWithoutFacultyInput, PersonnelUncheckedUpdateWithoutFacultyInput>
  }

  export type PersonnelUpdateManyWithWhereWithoutFacultyInput = {
    where: PersonnelScalarWhereInput
    data: XOR<PersonnelUpdateManyMutationInput, PersonnelUncheckedUpdateManyWithoutFacultyInput>
  }

  export type PersonnelScalarWhereInput = {
    AND?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
    OR?: PersonnelScalarWhereInput[]
    NOT?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
    id?: StringFilter<"Personnel"> | string
    userId?: StringFilter<"Personnel"> | string
    firstName?: StringFilter<"Personnel"> | string
    lastName?: StringFilter<"Personnel"> | string
    title?: StringNullableFilter<"Personnel"> | string | null
    position?: StringNullableFilter<"Personnel"> | string | null
    phone?: StringNullableFilter<"Personnel"> | string | null
    profileImageUrl?: StringNullableFilter<"Personnel"> | string | null
    facultyId?: StringNullableFilter<"Personnel"> | string | null
    departmentId?: StringNullableFilter<"Personnel"> | string | null
    bio?: StringNullableFilter<"Personnel"> | string | null
    expertise?: StringNullableFilter<"Personnel"> | string | null
    education?: StringNullableFilter<"Personnel"> | string | null
    publications?: StringNullableFilter<"Personnel"> | string | null
    officeHours?: StringNullableFilter<"Personnel"> | string | null
    officeLocation?: StringNullableFilter<"Personnel"> | string | null
    isProfilePublic?: BoolFilter<"Personnel"> | boolean
    createdAt?: DateTimeFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeFilter<"Personnel"> | Date | string
  }

  export type FacultyCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    programs?: ProgramCreateNestedManyWithoutFacultyInput
    personnel?: PersonnelCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    programs?: ProgramUncheckedCreateNestedManyWithoutFacultyInput
    personnel?: PersonnelUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutDepartmentsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
  }

  export type ProgramCreateWithoutDepartmentInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    students?: StudentCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutDepartmentInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutDepartmentInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutDepartmentInput, ProgramUncheckedCreateWithoutDepartmentInput>
  }

  export type ProgramCreateManyDepartmentInputEnvelope = {
    data: ProgramCreateManyDepartmentInput | ProgramCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelCreateWithoutDepartmentInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutDepartmentInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutDepartmentInput, PersonnelUncheckedCreateWithoutDepartmentInput>
  }

  export type PersonnelCreateManyDepartmentInputEnvelope = {
    data: PersonnelCreateManyDepartmentInput | PersonnelCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type FacultyUpsertWithoutDepartmentsInput = {
    update: XOR<FacultyUpdateWithoutDepartmentsInput, FacultyUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutDepartmentsInput, FacultyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type FacultyUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    programs?: ProgramUpdateManyWithoutFacultyNestedInput
    personnel?: PersonnelUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    programs?: ProgramUncheckedUpdateManyWithoutFacultyNestedInput
    personnel?: PersonnelUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type ProgramUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutDepartmentInput, ProgramUncheckedUpdateWithoutDepartmentInput>
    create: XOR<ProgramCreateWithoutDepartmentInput, ProgramUncheckedCreateWithoutDepartmentInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutDepartmentInput, ProgramUncheckedUpdateWithoutDepartmentInput>
  }

  export type ProgramUpdateManyWithWhereWithoutDepartmentInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type PersonnelUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: PersonnelWhereUniqueInput
    update: XOR<PersonnelUpdateWithoutDepartmentInput, PersonnelUncheckedUpdateWithoutDepartmentInput>
    create: XOR<PersonnelCreateWithoutDepartmentInput, PersonnelUncheckedCreateWithoutDepartmentInput>
  }

  export type PersonnelUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: PersonnelWhereUniqueInput
    data: XOR<PersonnelUpdateWithoutDepartmentInput, PersonnelUncheckedUpdateWithoutDepartmentInput>
  }

  export type PersonnelUpdateManyWithWhereWithoutDepartmentInput = {
    where: PersonnelScalarWhereInput
    data: XOR<PersonnelUpdateManyMutationInput, PersonnelUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type FacultyCreateWithoutProgramsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    departments?: DepartmentCreateNestedManyWithoutFacultyInput
    personnel?: PersonnelCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutProgramsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    logoUrl?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacultyInput
    personnel?: PersonnelUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutProgramsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>
  }

  export type DepartmentCreateWithoutProgramsInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    faculty: FacultyCreateNestedOneWithoutDepartmentsInput
    personnel?: PersonnelCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutProgramsInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
    facultyId: string
    personnel?: PersonnelUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutProgramsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutProgramsInput, DepartmentUncheckedCreateWithoutProgramsInput>
  }

  export type ApplicationCreateWithoutProgramInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutApplicationsInput
    track?: AdmissionTrackCreateNestedOneWithoutApplicationsInput
    documents?: DocumentCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutProgramInput = {
    id?: string
    applicantId: string
    trackId?: string | null
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutProgramInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutProgramInput, ApplicationUncheckedCreateWithoutProgramInput>
  }

  export type ApplicationCreateManyProgramInputEnvelope = {
    data: ApplicationCreateManyProgramInput | ApplicationCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutProgramInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    studentGroup?: StudentGroupCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutProgramInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutProgramInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
  }

  export type StudentCreateManyProgramInputEnvelope = {
    data: StudentCreateManyProgramInput | StudentCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type InterviewSlotCreateWithoutProgramInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    interviewResults?: InterviewResultCreateNestedManyWithoutSlotInput
    interviewers?: InterviewSlotInterviewerCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotUncheckedCreateWithoutProgramInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    interviewResults?: InterviewResultUncheckedCreateNestedManyWithoutSlotInput
    interviewers?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotCreateOrConnectWithoutProgramInput = {
    where: InterviewSlotWhereUniqueInput
    create: XOR<InterviewSlotCreateWithoutProgramInput, InterviewSlotUncheckedCreateWithoutProgramInput>
  }

  export type InterviewSlotCreateManyProgramInputEnvelope = {
    data: InterviewSlotCreateManyProgramInput | InterviewSlotCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCourseCreateWithoutProgramInput = {
    id?: string
    isRequired?: boolean
    semester?: number | null
    course: CourseCreateNestedOneWithoutProgramsInput
  }

  export type ProgramCourseUncheckedCreateWithoutProgramInput = {
    id?: string
    courseId: string
    isRequired?: boolean
    semester?: number | null
  }

  export type ProgramCourseCreateOrConnectWithoutProgramInput = {
    where: ProgramCourseWhereUniqueInput
    create: XOR<ProgramCourseCreateWithoutProgramInput, ProgramCourseUncheckedCreateWithoutProgramInput>
  }

  export type ProgramCourseCreateManyProgramInputEnvelope = {
    data: ProgramCourseCreateManyProgramInput | ProgramCourseCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionTrackCreateWithoutProgramInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: AdmissionTrackTypeCreateNestedOneWithoutTracksInput
    applications?: ApplicationCreateNestedManyWithoutTrackInput
  }

  export type AdmissionTrackUncheckedCreateWithoutProgramInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    typeId: string
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutTrackInput
  }

  export type AdmissionTrackCreateOrConnectWithoutProgramInput = {
    where: AdmissionTrackWhereUniqueInput
    create: XOR<AdmissionTrackCreateWithoutProgramInput, AdmissionTrackUncheckedCreateWithoutProgramInput>
  }

  export type AdmissionTrackCreateManyProgramInputEnvelope = {
    data: AdmissionTrackCreateManyProgramInput | AdmissionTrackCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type StudentGroupCreateWithoutProgramInput = {
    id?: string
    name: string
    admissionYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor?: PersonnelCreateNestedOneWithoutAdvisorGroupsInput
    students?: StudentCreateNestedManyWithoutStudentGroupInput
    sections?: ClassSectionCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupUncheckedCreateWithoutProgramInput = {
    id?: string
    name: string
    admissionYear: number
    advisorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutStudentGroupInput
    sections?: ClassSectionUncheckedCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupCreateOrConnectWithoutProgramInput = {
    where: StudentGroupWhereUniqueInput
    create: XOR<StudentGroupCreateWithoutProgramInput, StudentGroupUncheckedCreateWithoutProgramInput>
  }

  export type StudentGroupCreateManyProgramInputEnvelope = {
    data: StudentGroupCreateManyProgramInput | StudentGroupCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type FacultyUpsertWithoutProgramsInput = {
    update: XOR<FacultyUpdateWithoutProgramsInput, FacultyUncheckedUpdateWithoutProgramsInput>
    create: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutProgramsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutProgramsInput, FacultyUncheckedUpdateWithoutProgramsInput>
  }

  export type FacultyUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUpdateManyWithoutFacultyNestedInput
    personnel?: PersonnelUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutFacultyNestedInput
    personnel?: PersonnelUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type DepartmentUpsertWithoutProgramsInput = {
    update: XOR<DepartmentUpdateWithoutProgramsInput, DepartmentUncheckedUpdateWithoutProgramsInput>
    create: XOR<DepartmentCreateWithoutProgramsInput, DepartmentUncheckedCreateWithoutProgramsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutProgramsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutProgramsInput, DepartmentUncheckedUpdateWithoutProgramsInput>
  }

  export type DepartmentUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutDepartmentsNestedInput
    personnel?: PersonnelUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    personnel?: PersonnelUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ApplicationUpsertWithWhereUniqueWithoutProgramInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutProgramInput, ApplicationUncheckedUpdateWithoutProgramInput>
    create: XOR<ApplicationCreateWithoutProgramInput, ApplicationUncheckedCreateWithoutProgramInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutProgramInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutProgramInput, ApplicationUncheckedUpdateWithoutProgramInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutProgramInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutProgramInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: StringFilter<"Application"> | string
    applicantId?: StringFilter<"Application"> | string
    trackId?: StringNullableFilter<"Application"> | string | null
    programId?: StringFilter<"Application"> | string
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    submittedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutProgramInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutProgramInput, StudentUncheckedUpdateWithoutProgramInput>
    create: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutProgramInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutProgramInput, StudentUncheckedUpdateWithoutProgramInput>
  }

  export type StudentUpdateManyWithWhereWithoutProgramInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutProgramInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    title?: StringNullableFilter<"Student"> | string | null
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    firstNameTh?: StringNullableFilter<"Student"> | string | null
    lastNameTh?: StringNullableFilter<"Student"> | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    citizenId?: StringNullableFilter<"Student"> | string | null
    birthDate?: DateTimeFilter<"Student"> | Date | string
    gender?: EnumGenderNullableFilter<"Student"> | $Enums.Gender | null
    phone?: StringNullableFilter<"Student"> | string | null
    profileImageUrl?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    subDistrict?: StringNullableFilter<"Student"> | string | null
    district?: StringNullableFilter<"Student"> | string | null
    province?: StringNullableFilter<"Student"> | string | null
    zipCode?: StringNullableFilter<"Student"> | string | null
    programId?: StringFilter<"Student"> | string
    studentType?: EnumStudentTypeFilter<"Student"> | $Enums.StudentType
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    gpax?: FloatFilter<"Student"> | number
    bio?: StringNullableFilter<"Student"> | string | null
    interests?: StringNullableFilter<"Student"> | string | null
    skills?: StringNullableFilter<"Student"> | string | null
    socialLinks?: StringNullableFilter<"Student"> | string | null
    isProfilePublic?: BoolFilter<"Student"> | boolean
    showGPA?: BoolFilter<"Student"> | boolean
    admissionYear?: IntNullableFilter<"Student"> | number | null
    studentGroupId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type InterviewSlotUpsertWithWhereUniqueWithoutProgramInput = {
    where: InterviewSlotWhereUniqueInput
    update: XOR<InterviewSlotUpdateWithoutProgramInput, InterviewSlotUncheckedUpdateWithoutProgramInput>
    create: XOR<InterviewSlotCreateWithoutProgramInput, InterviewSlotUncheckedCreateWithoutProgramInput>
  }

  export type InterviewSlotUpdateWithWhereUniqueWithoutProgramInput = {
    where: InterviewSlotWhereUniqueInput
    data: XOR<InterviewSlotUpdateWithoutProgramInput, InterviewSlotUncheckedUpdateWithoutProgramInput>
  }

  export type InterviewSlotUpdateManyWithWhereWithoutProgramInput = {
    where: InterviewSlotScalarWhereInput
    data: XOR<InterviewSlotUpdateManyMutationInput, InterviewSlotUncheckedUpdateManyWithoutProgramInput>
  }

  export type InterviewSlotScalarWhereInput = {
    AND?: InterviewSlotScalarWhereInput | InterviewSlotScalarWhereInput[]
    OR?: InterviewSlotScalarWhereInput[]
    NOT?: InterviewSlotScalarWhereInput | InterviewSlotScalarWhereInput[]
    id?: StringFilter<"InterviewSlot"> | string
    startTime?: DateTimeFilter<"InterviewSlot"> | Date | string
    endTime?: DateTimeFilter<"InterviewSlot"> | Date | string
    location?: StringNullableFilter<"InterviewSlot"> | string | null
    coordinatorName?: StringNullableFilter<"InterviewSlot"> | string | null
    coordinatorPhone?: StringNullableFilter<"InterviewSlot"> | string | null
    description?: StringNullableFilter<"InterviewSlot"> | string | null
    programId?: StringNullableFilter<"InterviewSlot"> | string | null
  }

  export type ProgramCourseUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramCourseWhereUniqueInput
    update: XOR<ProgramCourseUpdateWithoutProgramInput, ProgramCourseUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramCourseCreateWithoutProgramInput, ProgramCourseUncheckedCreateWithoutProgramInput>
  }

  export type ProgramCourseUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramCourseWhereUniqueInput
    data: XOR<ProgramCourseUpdateWithoutProgramInput, ProgramCourseUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramCourseUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramCourseScalarWhereInput
    data: XOR<ProgramCourseUpdateManyMutationInput, ProgramCourseUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramCourseScalarWhereInput = {
    AND?: ProgramCourseScalarWhereInput | ProgramCourseScalarWhereInput[]
    OR?: ProgramCourseScalarWhereInput[]
    NOT?: ProgramCourseScalarWhereInput | ProgramCourseScalarWhereInput[]
    id?: StringFilter<"ProgramCourse"> | string
    programId?: StringFilter<"ProgramCourse"> | string
    courseId?: StringFilter<"ProgramCourse"> | string
    isRequired?: BoolFilter<"ProgramCourse"> | boolean
    semester?: IntNullableFilter<"ProgramCourse"> | number | null
  }

  export type AdmissionTrackUpsertWithWhereUniqueWithoutProgramInput = {
    where: AdmissionTrackWhereUniqueInput
    update: XOR<AdmissionTrackUpdateWithoutProgramInput, AdmissionTrackUncheckedUpdateWithoutProgramInput>
    create: XOR<AdmissionTrackCreateWithoutProgramInput, AdmissionTrackUncheckedCreateWithoutProgramInput>
  }

  export type AdmissionTrackUpdateWithWhereUniqueWithoutProgramInput = {
    where: AdmissionTrackWhereUniqueInput
    data: XOR<AdmissionTrackUpdateWithoutProgramInput, AdmissionTrackUncheckedUpdateWithoutProgramInput>
  }

  export type AdmissionTrackUpdateManyWithWhereWithoutProgramInput = {
    where: AdmissionTrackScalarWhereInput
    data: XOR<AdmissionTrackUpdateManyMutationInput, AdmissionTrackUncheckedUpdateManyWithoutProgramInput>
  }

  export type AdmissionTrackScalarWhereInput = {
    AND?: AdmissionTrackScalarWhereInput | AdmissionTrackScalarWhereInput[]
    OR?: AdmissionTrackScalarWhereInput[]
    NOT?: AdmissionTrackScalarWhereInput | AdmissionTrackScalarWhereInput[]
    id?: StringFilter<"AdmissionTrack"> | string
    code?: StringFilter<"AdmissionTrack"> | string
    nameTh?: StringFilter<"AdmissionTrack"> | string
    nameEn?: StringFilter<"AdmissionTrack"> | string
    description?: StringNullableFilter<"AdmissionTrack"> | string | null
    typeId?: StringFilter<"AdmissionTrack"> | string
    programId?: StringFilter<"AdmissionTrack"> | string
    academicYear?: StringFilter<"AdmissionTrack"> | string
    openDate?: DateTimeFilter<"AdmissionTrack"> | Date | string
    closeDate?: DateTimeFilter<"AdmissionTrack"> | Date | string
    announceDate?: DateTimeNullableFilter<"AdmissionTrack"> | Date | string | null
    totalSeats?: IntFilter<"AdmissionTrack"> | number
    filledSeats?: IntFilter<"AdmissionTrack"> | number
    reservedSeats?: IntNullableFilter<"AdmissionTrack"> | number | null
    enableWaitlist?: BoolFilter<"AdmissionTrack"> | boolean
    requirements?: StringNullableFilter<"AdmissionTrack"> | string | null
    applicationFee?: FloatNullableFilter<"AdmissionTrack"> | number | null
    isActive?: BoolFilter<"AdmissionTrack"> | boolean
    isPublished?: BoolFilter<"AdmissionTrack"> | boolean
    displayOrder?: IntFilter<"AdmissionTrack"> | number
    createdAt?: DateTimeFilter<"AdmissionTrack"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionTrack"> | Date | string
  }

  export type StudentGroupUpsertWithWhereUniqueWithoutProgramInput = {
    where: StudentGroupWhereUniqueInput
    update: XOR<StudentGroupUpdateWithoutProgramInput, StudentGroupUncheckedUpdateWithoutProgramInput>
    create: XOR<StudentGroupCreateWithoutProgramInput, StudentGroupUncheckedCreateWithoutProgramInput>
  }

  export type StudentGroupUpdateWithWhereUniqueWithoutProgramInput = {
    where: StudentGroupWhereUniqueInput
    data: XOR<StudentGroupUpdateWithoutProgramInput, StudentGroupUncheckedUpdateWithoutProgramInput>
  }

  export type StudentGroupUpdateManyWithWhereWithoutProgramInput = {
    where: StudentGroupScalarWhereInput
    data: XOR<StudentGroupUpdateManyMutationInput, StudentGroupUncheckedUpdateManyWithoutProgramInput>
  }

  export type ClassSectionCreateWithoutCourseInput = {
    id?: string
    sectionNumber: string
    capacity: number
    term: AcademicTermCreateNestedOneWithoutSectionsInput
    instructor?: PersonnelCreateNestedOneWithoutInstructedSectionsInput
    schedules?: ClassScheduleCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionUncheckedCreateWithoutCourseInput = {
    id?: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionCreateOrConnectWithoutCourseInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutCourseInput, ClassSectionUncheckedCreateWithoutCourseInput>
  }

  export type ClassSectionCreateManyCourseInputEnvelope = {
    data: ClassSectionCreateManyCourseInput | ClassSectionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCourseCreateWithoutCourseInput = {
    id?: string
    isRequired?: boolean
    semester?: number | null
    program: ProgramCreateNestedOneWithoutCoursesInput
  }

  export type ProgramCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    programId: string
    isRequired?: boolean
    semester?: number | null
  }

  export type ProgramCourseCreateOrConnectWithoutCourseInput = {
    where: ProgramCourseWhereUniqueInput
    create: XOR<ProgramCourseCreateWithoutCourseInput, ProgramCourseUncheckedCreateWithoutCourseInput>
  }

  export type ProgramCourseCreateManyCourseInputEnvelope = {
    data: ProgramCourseCreateManyCourseInput | ProgramCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ClassScheduleCreateWithoutCourseInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    section: ClassSectionCreateNestedOneWithoutSchedulesInput
    room?: RoomCreateNestedOneWithoutSchedulesInput
    instructor?: PersonnelCreateNestedOneWithoutTeachingSchedulesInput
    term?: AcademicTermCreateNestedOneWithoutSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutCourseInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type ClassScheduleCreateOrConnectWithoutCourseInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutCourseInput, ClassScheduleUncheckedCreateWithoutCourseInput>
  }

  export type ClassScheduleCreateManyCourseInputEnvelope = {
    data: ClassScheduleCreateManyCourseInput | ClassScheduleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ExamScheduleCreateWithoutCourseInput = {
    id?: string
    section: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    term: AcademicTermCreateNestedOneWithoutExamSchedulesInput
    examSlots?: ExamSlotCreateNestedManyWithoutExamScheduleInput
  }

  export type ExamScheduleUncheckedCreateWithoutCourseInput = {
    id?: string
    section: string
    termId: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examSlots?: ExamSlotUncheckedCreateNestedManyWithoutExamScheduleInput
  }

  export type ExamScheduleCreateOrConnectWithoutCourseInput = {
    where: ExamScheduleWhereUniqueInput
    create: XOR<ExamScheduleCreateWithoutCourseInput, ExamScheduleUncheckedCreateWithoutCourseInput>
  }

  export type ExamScheduleCreateManyCourseInputEnvelope = {
    data: ExamScheduleCreateManyCourseInput | ExamScheduleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ClassSectionUpsertWithWhereUniqueWithoutCourseInput = {
    where: ClassSectionWhereUniqueInput
    update: XOR<ClassSectionUpdateWithoutCourseInput, ClassSectionUncheckedUpdateWithoutCourseInput>
    create: XOR<ClassSectionCreateWithoutCourseInput, ClassSectionUncheckedCreateWithoutCourseInput>
  }

  export type ClassSectionUpdateWithWhereUniqueWithoutCourseInput = {
    where: ClassSectionWhereUniqueInput
    data: XOR<ClassSectionUpdateWithoutCourseInput, ClassSectionUncheckedUpdateWithoutCourseInput>
  }

  export type ClassSectionUpdateManyWithWhereWithoutCourseInput = {
    where: ClassSectionScalarWhereInput
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyWithoutCourseInput>
  }

  export type ProgramCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: ProgramCourseWhereUniqueInput
    update: XOR<ProgramCourseUpdateWithoutCourseInput, ProgramCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<ProgramCourseCreateWithoutCourseInput, ProgramCourseUncheckedCreateWithoutCourseInput>
  }

  export type ProgramCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: ProgramCourseWhereUniqueInput
    data: XOR<ProgramCourseUpdateWithoutCourseInput, ProgramCourseUncheckedUpdateWithoutCourseInput>
  }

  export type ProgramCourseUpdateManyWithWhereWithoutCourseInput = {
    where: ProgramCourseScalarWhereInput
    data: XOR<ProgramCourseUpdateManyMutationInput, ProgramCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutCourseInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutCourseInput, ClassScheduleUncheckedUpdateWithoutCourseInput>
    create: XOR<ClassScheduleCreateWithoutCourseInput, ClassScheduleUncheckedCreateWithoutCourseInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutCourseInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutCourseInput, ClassScheduleUncheckedUpdateWithoutCourseInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutCourseInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutCourseInput>
  }

  export type ExamScheduleUpsertWithWhereUniqueWithoutCourseInput = {
    where: ExamScheduleWhereUniqueInput
    update: XOR<ExamScheduleUpdateWithoutCourseInput, ExamScheduleUncheckedUpdateWithoutCourseInput>
    create: XOR<ExamScheduleCreateWithoutCourseInput, ExamScheduleUncheckedCreateWithoutCourseInput>
  }

  export type ExamScheduleUpdateWithWhereUniqueWithoutCourseInput = {
    where: ExamScheduleWhereUniqueInput
    data: XOR<ExamScheduleUpdateWithoutCourseInput, ExamScheduleUncheckedUpdateWithoutCourseInput>
  }

  export type ExamScheduleUpdateManyWithWhereWithoutCourseInput = {
    where: ExamScheduleScalarWhereInput
    data: XOR<ExamScheduleUpdateManyMutationInput, ExamScheduleUncheckedUpdateManyWithoutCourseInput>
  }

  export type ExamScheduleScalarWhereInput = {
    AND?: ExamScheduleScalarWhereInput | ExamScheduleScalarWhereInput[]
    OR?: ExamScheduleScalarWhereInput[]
    NOT?: ExamScheduleScalarWhereInput | ExamScheduleScalarWhereInput[]
    id?: StringFilter<"ExamSchedule"> | string
    courseId?: StringFilter<"ExamSchedule"> | string
    section?: StringFilter<"ExamSchedule"> | string
    termId?: StringFilter<"ExamSchedule"> | string
    examType?: EnumExamTypeFilter<"ExamSchedule"> | $Enums.ExamType
    examDate?: DateTimeFilter<"ExamSchedule"> | Date | string
    startTime?: StringFilter<"ExamSchedule"> | string
    endTime?: StringFilter<"ExamSchedule"> | string
    duration?: IntFilter<"ExamSchedule"> | number
    examFormat?: EnumExamFormatFilter<"ExamSchedule"> | $Enums.ExamFormat
    instructions?: StringNullableFilter<"ExamSchedule"> | string | null
    isPublished?: BoolFilter<"ExamSchedule"> | boolean
    createdAt?: DateTimeFilter<"ExamSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSchedule"> | Date | string
  }

  export type ProgramCreateWithoutCoursesInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    department: DepartmentCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    students?: StudentCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutCoursesInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutCoursesInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutCoursesInput, ProgramUncheckedCreateWithoutCoursesInput>
  }

  export type CourseCreateWithoutProgramsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutProgramsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutProgramsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutProgramsInput, CourseUncheckedCreateWithoutProgramsInput>
  }

  export type ProgramUpsertWithoutCoursesInput = {
    update: XOR<ProgramUpdateWithoutCoursesInput, ProgramUncheckedUpdateWithoutCoursesInput>
    create: XOR<ProgramCreateWithoutCoursesInput, ProgramUncheckedCreateWithoutCoursesInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutCoursesInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutCoursesInput, ProgramUncheckedUpdateWithoutCoursesInput>
  }

  export type ProgramUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type CourseUpsertWithoutProgramsInput = {
    update: XOR<CourseUpdateWithoutProgramsInput, CourseUncheckedUpdateWithoutProgramsInput>
    create: XOR<CourseCreateWithoutProgramsInput, CourseUncheckedCreateWithoutProgramsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutProgramsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutProgramsInput, CourseUncheckedUpdateWithoutProgramsInput>
  }

  export type CourseUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ClassSectionCreateWithoutTermInput = {
    id?: string
    sectionNumber: string
    capacity: number
    course: CourseCreateNestedOneWithoutSectionsInput
    instructor?: PersonnelCreateNestedOneWithoutInstructedSectionsInput
    schedules?: ClassScheduleCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionUncheckedCreateWithoutTermInput = {
    id?: string
    courseId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionCreateOrConnectWithoutTermInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutTermInput, ClassSectionUncheckedCreateWithoutTermInput>
  }

  export type ClassSectionCreateManyTermInputEnvelope = {
    data: ClassSectionCreateManyTermInput | ClassSectionCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTermInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTermInput = {
    id?: string
    studentId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTermInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput>
  }

  export type InvoiceCreateManyTermInputEnvelope = {
    data: InvoiceCreateManyTermInput | InvoiceCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type ExamScheduleCreateWithoutTermInput = {
    id?: string
    section: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutExamSchedulesInput
    examSlots?: ExamSlotCreateNestedManyWithoutExamScheduleInput
  }

  export type ExamScheduleUncheckedCreateWithoutTermInput = {
    id?: string
    courseId: string
    section: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examSlots?: ExamSlotUncheckedCreateNestedManyWithoutExamScheduleInput
  }

  export type ExamScheduleCreateOrConnectWithoutTermInput = {
    where: ExamScheduleWhereUniqueInput
    create: XOR<ExamScheduleCreateWithoutTermInput, ExamScheduleUncheckedCreateWithoutTermInput>
  }

  export type ExamScheduleCreateManyTermInputEnvelope = {
    data: ExamScheduleCreateManyTermInput | ExamScheduleCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type TeachingLoadCreateWithoutTermInput = {
    id?: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor: PersonnelCreateNestedOneWithoutTeachingLoadsInput
  }

  export type TeachingLoadUncheckedCreateWithoutTermInput = {
    id?: string
    instructorId: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingLoadCreateOrConnectWithoutTermInput = {
    where: TeachingLoadWhereUniqueInput
    create: XOR<TeachingLoadCreateWithoutTermInput, TeachingLoadUncheckedCreateWithoutTermInput>
  }

  export type TeachingLoadCreateManyTermInputEnvelope = {
    data: TeachingLoadCreateManyTermInput | TeachingLoadCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type ClassScheduleCreateWithoutTermInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    section: ClassSectionCreateNestedOneWithoutSchedulesInput
    room?: RoomCreateNestedOneWithoutSchedulesInput
    course?: CourseCreateNestedOneWithoutSchedulesInput
    instructor?: PersonnelCreateNestedOneWithoutTeachingSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutTermInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    instructorId?: string | null
  }

  export type ClassScheduleCreateOrConnectWithoutTermInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutTermInput, ClassScheduleUncheckedCreateWithoutTermInput>
  }

  export type ClassScheduleCreateManyTermInputEnvelope = {
    data: ClassScheduleCreateManyTermInput | ClassScheduleCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type ClassSectionUpsertWithWhereUniqueWithoutTermInput = {
    where: ClassSectionWhereUniqueInput
    update: XOR<ClassSectionUpdateWithoutTermInput, ClassSectionUncheckedUpdateWithoutTermInput>
    create: XOR<ClassSectionCreateWithoutTermInput, ClassSectionUncheckedCreateWithoutTermInput>
  }

  export type ClassSectionUpdateWithWhereUniqueWithoutTermInput = {
    where: ClassSectionWhereUniqueInput
    data: XOR<ClassSectionUpdateWithoutTermInput, ClassSectionUncheckedUpdateWithoutTermInput>
  }

  export type ClassSectionUpdateManyWithWhereWithoutTermInput = {
    where: ClassSectionScalarWhereInput
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyWithoutTermInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTermInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTermInput, InvoiceUncheckedUpdateWithoutTermInput>
    create: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTermInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTermInput, InvoiceUncheckedUpdateWithoutTermInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTermInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTermInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    studentId?: StringFilter<"Invoice"> | string
    termId?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type ExamScheduleUpsertWithWhereUniqueWithoutTermInput = {
    where: ExamScheduleWhereUniqueInput
    update: XOR<ExamScheduleUpdateWithoutTermInput, ExamScheduleUncheckedUpdateWithoutTermInput>
    create: XOR<ExamScheduleCreateWithoutTermInput, ExamScheduleUncheckedCreateWithoutTermInput>
  }

  export type ExamScheduleUpdateWithWhereUniqueWithoutTermInput = {
    where: ExamScheduleWhereUniqueInput
    data: XOR<ExamScheduleUpdateWithoutTermInput, ExamScheduleUncheckedUpdateWithoutTermInput>
  }

  export type ExamScheduleUpdateManyWithWhereWithoutTermInput = {
    where: ExamScheduleScalarWhereInput
    data: XOR<ExamScheduleUpdateManyMutationInput, ExamScheduleUncheckedUpdateManyWithoutTermInput>
  }

  export type TeachingLoadUpsertWithWhereUniqueWithoutTermInput = {
    where: TeachingLoadWhereUniqueInput
    update: XOR<TeachingLoadUpdateWithoutTermInput, TeachingLoadUncheckedUpdateWithoutTermInput>
    create: XOR<TeachingLoadCreateWithoutTermInput, TeachingLoadUncheckedCreateWithoutTermInput>
  }

  export type TeachingLoadUpdateWithWhereUniqueWithoutTermInput = {
    where: TeachingLoadWhereUniqueInput
    data: XOR<TeachingLoadUpdateWithoutTermInput, TeachingLoadUncheckedUpdateWithoutTermInput>
  }

  export type TeachingLoadUpdateManyWithWhereWithoutTermInput = {
    where: TeachingLoadScalarWhereInput
    data: XOR<TeachingLoadUpdateManyMutationInput, TeachingLoadUncheckedUpdateManyWithoutTermInput>
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutTermInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutTermInput, ClassScheduleUncheckedUpdateWithoutTermInput>
    create: XOR<ClassScheduleCreateWithoutTermInput, ClassScheduleUncheckedCreateWithoutTermInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutTermInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutTermInput, ClassScheduleUncheckedUpdateWithoutTermInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutTermInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutTermInput>
  }

  export type UserCreateWithoutApplicantProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelCreateNestedOneWithoutUserInput
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    logs?: SystemLogCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutApplicantProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    logs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutApplicantProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicantProfileInput, UserUncheckedCreateWithoutApplicantProfileInput>
  }

  export type EducationHistoryCreateWithoutApplicantInput = {
    id?: string
    level: string
    degreeName: string
    institution: string
    gpa?: string | null
    graduationYear?: number | null
  }

  export type EducationHistoryUncheckedCreateWithoutApplicantInput = {
    id?: string
    level: string
    degreeName: string
    institution: string
    gpa?: string | null
    graduationYear?: number | null
  }

  export type EducationHistoryCreateOrConnectWithoutApplicantInput = {
    where: EducationHistoryWhereUniqueInput
    create: XOR<EducationHistoryCreateWithoutApplicantInput, EducationHistoryUncheckedCreateWithoutApplicantInput>
  }

  export type EducationHistoryCreateManyApplicantInputEnvelope = {
    data: EducationHistoryCreateManyApplicantInput | EducationHistoryCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutApplicantInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    track?: AdmissionTrackCreateNestedOneWithoutApplicationsInput
    program: ProgramCreateNestedOneWithoutApplicationsInput
    documents?: DocumentCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutApplicantInput = {
    id?: string
    trackId?: string | null
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutApplicantInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput>
  }

  export type ApplicationCreateManyApplicantInputEnvelope = {
    data: ApplicationCreateManyApplicantInput | ApplicationCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutApplicantProfileInput = {
    update: XOR<UserUpdateWithoutApplicantProfileInput, UserUncheckedUpdateWithoutApplicantProfileInput>
    create: XOR<UserCreateWithoutApplicantProfileInput, UserUncheckedCreateWithoutApplicantProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicantProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicantProfileInput, UserUncheckedUpdateWithoutApplicantProfileInput>
  }

  export type UserUpdateWithoutApplicantProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    logs?: SystemLogUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicantProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    logs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type EducationHistoryUpsertWithWhereUniqueWithoutApplicantInput = {
    where: EducationHistoryWhereUniqueInput
    update: XOR<EducationHistoryUpdateWithoutApplicantInput, EducationHistoryUncheckedUpdateWithoutApplicantInput>
    create: XOR<EducationHistoryCreateWithoutApplicantInput, EducationHistoryUncheckedCreateWithoutApplicantInput>
  }

  export type EducationHistoryUpdateWithWhereUniqueWithoutApplicantInput = {
    where: EducationHistoryWhereUniqueInput
    data: XOR<EducationHistoryUpdateWithoutApplicantInput, EducationHistoryUncheckedUpdateWithoutApplicantInput>
  }

  export type EducationHistoryUpdateManyWithWhereWithoutApplicantInput = {
    where: EducationHistoryScalarWhereInput
    data: XOR<EducationHistoryUpdateManyMutationInput, EducationHistoryUncheckedUpdateManyWithoutApplicantInput>
  }

  export type EducationHistoryScalarWhereInput = {
    AND?: EducationHistoryScalarWhereInput | EducationHistoryScalarWhereInput[]
    OR?: EducationHistoryScalarWhereInput[]
    NOT?: EducationHistoryScalarWhereInput | EducationHistoryScalarWhereInput[]
    id?: StringFilter<"EducationHistory"> | string
    applicantId?: StringFilter<"EducationHistory"> | string
    level?: StringFilter<"EducationHistory"> | string
    degreeName?: StringFilter<"EducationHistory"> | string
    institution?: StringFilter<"EducationHistory"> | string
    gpa?: StringNullableFilter<"EducationHistory"> | string | null
    graduationYear?: IntNullableFilter<"EducationHistory"> | number | null
  }

  export type ApplicationUpsertWithWhereUniqueWithoutApplicantInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutApplicantInput, ApplicationUncheckedUpdateWithoutApplicantInput>
    create: XOR<ApplicationCreateWithoutApplicantInput, ApplicationUncheckedCreateWithoutApplicantInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutApplicantInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutApplicantInput, ApplicationUncheckedUpdateWithoutApplicantInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutApplicantInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutApplicantInput>
  }

  export type ApplicantCreateWithoutEducationHistoryInput = {
    id?: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    user: UserCreateNestedOneWithoutApplicantProfileInput
    applications?: ApplicationCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutEducationHistoryInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    applications?: ApplicationUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutEducationHistoryInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutEducationHistoryInput, ApplicantUncheckedCreateWithoutEducationHistoryInput>
  }

  export type ApplicantUpsertWithoutEducationHistoryInput = {
    update: XOR<ApplicantUpdateWithoutEducationHistoryInput, ApplicantUncheckedUpdateWithoutEducationHistoryInput>
    create: XOR<ApplicantCreateWithoutEducationHistoryInput, ApplicantUncheckedCreateWithoutEducationHistoryInput>
    where?: ApplicantWhereInput
  }

  export type ApplicantUpdateToOneWithWhereWithoutEducationHistoryInput = {
    where?: ApplicantWhereInput
    data: XOR<ApplicantUpdateWithoutEducationHistoryInput, ApplicantUncheckedUpdateWithoutEducationHistoryInput>
  }

  export type ApplicantUpdateWithoutEducationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutApplicantProfileNestedInput
    applications?: ApplicationUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutEducationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: ApplicationUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type AdmissionTrackCreateWithoutTypeInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutAdmissionTracksInput
    applications?: ApplicationCreateNestedManyWithoutTrackInput
  }

  export type AdmissionTrackUncheckedCreateWithoutTypeInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    programId: string
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutTrackInput
  }

  export type AdmissionTrackCreateOrConnectWithoutTypeInput = {
    where: AdmissionTrackWhereUniqueInput
    create: XOR<AdmissionTrackCreateWithoutTypeInput, AdmissionTrackUncheckedCreateWithoutTypeInput>
  }

  export type AdmissionTrackCreateManyTypeInputEnvelope = {
    data: AdmissionTrackCreateManyTypeInput | AdmissionTrackCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionTrackUpsertWithWhereUniqueWithoutTypeInput = {
    where: AdmissionTrackWhereUniqueInput
    update: XOR<AdmissionTrackUpdateWithoutTypeInput, AdmissionTrackUncheckedUpdateWithoutTypeInput>
    create: XOR<AdmissionTrackCreateWithoutTypeInput, AdmissionTrackUncheckedCreateWithoutTypeInput>
  }

  export type AdmissionTrackUpdateWithWhereUniqueWithoutTypeInput = {
    where: AdmissionTrackWhereUniqueInput
    data: XOR<AdmissionTrackUpdateWithoutTypeInput, AdmissionTrackUncheckedUpdateWithoutTypeInput>
  }

  export type AdmissionTrackUpdateManyWithWhereWithoutTypeInput = {
    where: AdmissionTrackScalarWhereInput
    data: XOR<AdmissionTrackUpdateManyMutationInput, AdmissionTrackUncheckedUpdateManyWithoutTypeInput>
  }

  export type AdmissionTrackTypeCreateWithoutTracksInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    color?: string
    icon?: string
    displayOrder?: number
    isActive?: boolean
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionTrackTypeUncheckedCreateWithoutTracksInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    color?: string
    icon?: string
    displayOrder?: number
    isActive?: boolean
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionTrackTypeCreateOrConnectWithoutTracksInput = {
    where: AdmissionTrackTypeWhereUniqueInput
    create: XOR<AdmissionTrackTypeCreateWithoutTracksInput, AdmissionTrackTypeUncheckedCreateWithoutTracksInput>
  }

  export type ProgramCreateWithoutAdmissionTracksInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    department: DepartmentCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    students?: StudentCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutAdmissionTracksInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutAdmissionTracksInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutAdmissionTracksInput, ProgramUncheckedCreateWithoutAdmissionTracksInput>
  }

  export type ApplicationCreateWithoutTrackInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutApplicationsInput
    program: ProgramCreateNestedOneWithoutApplicationsInput
    documents?: DocumentCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutTrackInput = {
    id?: string
    applicantId: string
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutApplicationInput
    interview?: InterviewResultUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutTrackInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutTrackInput, ApplicationUncheckedCreateWithoutTrackInput>
  }

  export type ApplicationCreateManyTrackInputEnvelope = {
    data: ApplicationCreateManyTrackInput | ApplicationCreateManyTrackInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionTrackTypeUpsertWithoutTracksInput = {
    update: XOR<AdmissionTrackTypeUpdateWithoutTracksInput, AdmissionTrackTypeUncheckedUpdateWithoutTracksInput>
    create: XOR<AdmissionTrackTypeCreateWithoutTracksInput, AdmissionTrackTypeUncheckedCreateWithoutTracksInput>
    where?: AdmissionTrackTypeWhereInput
  }

  export type AdmissionTrackTypeUpdateToOneWithWhereWithoutTracksInput = {
    where?: AdmissionTrackTypeWhereInput
    data: XOR<AdmissionTrackTypeUpdateWithoutTracksInput, AdmissionTrackTypeUncheckedUpdateWithoutTracksInput>
  }

  export type AdmissionTrackTypeUpdateWithoutTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionTrackTypeUncheckedUpdateWithoutTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpsertWithoutAdmissionTracksInput = {
    update: XOR<ProgramUpdateWithoutAdmissionTracksInput, ProgramUncheckedUpdateWithoutAdmissionTracksInput>
    create: XOR<ProgramCreateWithoutAdmissionTracksInput, ProgramUncheckedCreateWithoutAdmissionTracksInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutAdmissionTracksInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutAdmissionTracksInput, ProgramUncheckedUpdateWithoutAdmissionTracksInput>
  }

  export type ProgramUpdateWithoutAdmissionTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutAdmissionTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ApplicationUpsertWithWhereUniqueWithoutTrackInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutTrackInput, ApplicationUncheckedUpdateWithoutTrackInput>
    create: XOR<ApplicationCreateWithoutTrackInput, ApplicationUncheckedCreateWithoutTrackInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutTrackInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutTrackInput, ApplicationUncheckedUpdateWithoutTrackInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutTrackInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutTrackInput>
  }

  export type ApplicantCreateWithoutApplicationsInput = {
    id?: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    user: UserCreateNestedOneWithoutApplicantProfileInput
    educationHistory?: EducationHistoryCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutApplicationsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    title?: string | null
    citizenId?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    phone?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    profileImageUrl?: string | null
    educationHistory?: EducationHistoryUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutApplicationsInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutApplicationsInput, ApplicantUncheckedCreateWithoutApplicationsInput>
  }

  export type AdmissionTrackCreateWithoutApplicationsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: AdmissionTrackTypeCreateNestedOneWithoutTracksInput
    program: ProgramCreateNestedOneWithoutAdmissionTracksInput
  }

  export type AdmissionTrackUncheckedCreateWithoutApplicationsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    typeId: string
    programId: string
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionTrackCreateOrConnectWithoutApplicationsInput = {
    where: AdmissionTrackWhereUniqueInput
    create: XOR<AdmissionTrackCreateWithoutApplicationsInput, AdmissionTrackUncheckedCreateWithoutApplicationsInput>
  }

  export type ProgramCreateWithoutApplicationsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    department: DepartmentCreateNestedOneWithoutProgramsInput
    students?: StudentCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutApplicationsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutApplicationsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutApplicationsInput, ProgramUncheckedCreateWithoutApplicationsInput>
  }

  export type DocumentCreateWithoutApplicationInput = {
    id?: string
    type: string
    url: string
    uploadedAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutApplicationInput = {
    id?: string
    type: string
    url: string
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutApplicationInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutApplicationInput, DocumentUncheckedCreateWithoutApplicationInput>
  }

  export type DocumentCreateManyApplicationInputEnvelope = {
    data: DocumentCreateManyApplicationInput | DocumentCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type InterviewResultCreateWithoutApplicationInput = {
    id?: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
    slot: InterviewSlotCreateNestedOneWithoutInterviewResultsInput
    feedback?: InterviewFeedbackCreateNestedOneWithoutInterviewResultInput
  }

  export type InterviewResultUncheckedCreateWithoutApplicationInput = {
    id?: string
    slotId: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
    feedback?: InterviewFeedbackUncheckedCreateNestedOneWithoutInterviewResultInput
  }

  export type InterviewResultCreateOrConnectWithoutApplicationInput = {
    where: InterviewResultWhereUniqueInput
    create: XOR<InterviewResultCreateWithoutApplicationInput, InterviewResultUncheckedCreateWithoutApplicationInput>
  }

  export type ApplicantUpsertWithoutApplicationsInput = {
    update: XOR<ApplicantUpdateWithoutApplicationsInput, ApplicantUncheckedUpdateWithoutApplicationsInput>
    create: XOR<ApplicantCreateWithoutApplicationsInput, ApplicantUncheckedCreateWithoutApplicationsInput>
    where?: ApplicantWhereInput
  }

  export type ApplicantUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: ApplicantWhereInput
    data: XOR<ApplicantUpdateWithoutApplicationsInput, ApplicantUncheckedUpdateWithoutApplicationsInput>
  }

  export type ApplicantUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutApplicantProfileNestedInput
    educationHistory?: EducationHistoryUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationHistory?: EducationHistoryUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type AdmissionTrackUpsertWithoutApplicationsInput = {
    update: XOR<AdmissionTrackUpdateWithoutApplicationsInput, AdmissionTrackUncheckedUpdateWithoutApplicationsInput>
    create: XOR<AdmissionTrackCreateWithoutApplicationsInput, AdmissionTrackUncheckedCreateWithoutApplicationsInput>
    where?: AdmissionTrackWhereInput
  }

  export type AdmissionTrackUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: AdmissionTrackWhereInput
    data: XOR<AdmissionTrackUpdateWithoutApplicationsInput, AdmissionTrackUncheckedUpdateWithoutApplicationsInput>
  }

  export type AdmissionTrackUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: AdmissionTrackTypeUpdateOneRequiredWithoutTracksNestedInput
    program?: ProgramUpdateOneRequiredWithoutAdmissionTracksNestedInput
  }

  export type AdmissionTrackUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpsertWithoutApplicationsInput = {
    update: XOR<ProgramUpdateWithoutApplicationsInput, ProgramUncheckedUpdateWithoutApplicationsInput>
    create: XOR<ProgramCreateWithoutApplicationsInput, ProgramUncheckedCreateWithoutApplicationsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutApplicationsInput, ProgramUncheckedUpdateWithoutApplicationsInput>
  }

  export type ProgramUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutApplicationInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutApplicationInput, DocumentUncheckedUpdateWithoutApplicationInput>
    create: XOR<DocumentCreateWithoutApplicationInput, DocumentUncheckedCreateWithoutApplicationInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutApplicationInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutApplicationInput, DocumentUncheckedUpdateWithoutApplicationInput>
  }

  export type DocumentUpdateManyWithWhereWithoutApplicationInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutApplicationInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    applicationId?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type InterviewResultUpsertWithoutApplicationInput = {
    update: XOR<InterviewResultUpdateWithoutApplicationInput, InterviewResultUncheckedUpdateWithoutApplicationInput>
    create: XOR<InterviewResultCreateWithoutApplicationInput, InterviewResultUncheckedCreateWithoutApplicationInput>
    where?: InterviewResultWhereInput
  }

  export type InterviewResultUpdateToOneWithWhereWithoutApplicationInput = {
    where?: InterviewResultWhereInput
    data: XOR<InterviewResultUpdateWithoutApplicationInput, InterviewResultUncheckedUpdateWithoutApplicationInput>
  }

  export type InterviewResultUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot?: InterviewSlotUpdateOneRequiredWithoutInterviewResultsNestedInput
    feedback?: InterviewFeedbackUpdateOneWithoutInterviewResultNestedInput
  }

  export type InterviewResultUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: InterviewFeedbackUncheckedUpdateOneWithoutInterviewResultNestedInput
  }

  export type ApplicationCreateWithoutDocumentsInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutApplicationsInput
    track?: AdmissionTrackCreateNestedOneWithoutApplicationsInput
    program: ProgramCreateNestedOneWithoutApplicationsInput
    interview?: InterviewResultCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    applicantId: string
    trackId?: string | null
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interview?: InterviewResultUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutDocumentsInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutDocumentsInput, ApplicationUncheckedCreateWithoutDocumentsInput>
  }

  export type ApplicationUpsertWithoutDocumentsInput = {
    update: XOR<ApplicationUpdateWithoutDocumentsInput, ApplicationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ApplicationCreateWithoutDocumentsInput, ApplicationUncheckedCreateWithoutDocumentsInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutDocumentsInput, ApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type ApplicationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutApplicationsNestedInput
    track?: AdmissionTrackUpdateOneWithoutApplicationsNestedInput
    program?: ProgramUpdateOneRequiredWithoutApplicationsNestedInput
    interview?: InterviewResultUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interview?: InterviewResultUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ProgramCreateWithoutInterviewSlotsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    department: DepartmentCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    students?: StudentCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutInterviewSlotsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutInterviewSlotsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutInterviewSlotsInput, ProgramUncheckedCreateWithoutInterviewSlotsInput>
  }

  export type InterviewResultCreateWithoutSlotInput = {
    id?: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
    application: ApplicationCreateNestedOneWithoutInterviewInput
    feedback?: InterviewFeedbackCreateNestedOneWithoutInterviewResultInput
  }

  export type InterviewResultUncheckedCreateWithoutSlotInput = {
    id?: string
    applicationId: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
    feedback?: InterviewFeedbackUncheckedCreateNestedOneWithoutInterviewResultInput
  }

  export type InterviewResultCreateOrConnectWithoutSlotInput = {
    where: InterviewResultWhereUniqueInput
    create: XOR<InterviewResultCreateWithoutSlotInput, InterviewResultUncheckedCreateWithoutSlotInput>
  }

  export type InterviewResultCreateManySlotInputEnvelope = {
    data: InterviewResultCreateManySlotInput | InterviewResultCreateManySlotInput[]
    skipDuplicates?: boolean
  }

  export type InterviewSlotInterviewerCreateWithoutSlotInput = {
    id?: string
    interviewer: PersonnelCreateNestedOneWithoutInterviewSlotsInput
  }

  export type InterviewSlotInterviewerUncheckedCreateWithoutSlotInput = {
    id?: string
    interviewerId: string
  }

  export type InterviewSlotInterviewerCreateOrConnectWithoutSlotInput = {
    where: InterviewSlotInterviewerWhereUniqueInput
    create: XOR<InterviewSlotInterviewerCreateWithoutSlotInput, InterviewSlotInterviewerUncheckedCreateWithoutSlotInput>
  }

  export type InterviewSlotInterviewerCreateManySlotInputEnvelope = {
    data: InterviewSlotInterviewerCreateManySlotInput | InterviewSlotInterviewerCreateManySlotInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutInterviewSlotsInput = {
    update: XOR<ProgramUpdateWithoutInterviewSlotsInput, ProgramUncheckedUpdateWithoutInterviewSlotsInput>
    create: XOR<ProgramCreateWithoutInterviewSlotsInput, ProgramUncheckedCreateWithoutInterviewSlotsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutInterviewSlotsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutInterviewSlotsInput, ProgramUncheckedUpdateWithoutInterviewSlotsInput>
  }

  export type ProgramUpdateWithoutInterviewSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutInterviewSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type InterviewResultUpsertWithWhereUniqueWithoutSlotInput = {
    where: InterviewResultWhereUniqueInput
    update: XOR<InterviewResultUpdateWithoutSlotInput, InterviewResultUncheckedUpdateWithoutSlotInput>
    create: XOR<InterviewResultCreateWithoutSlotInput, InterviewResultUncheckedCreateWithoutSlotInput>
  }

  export type InterviewResultUpdateWithWhereUniqueWithoutSlotInput = {
    where: InterviewResultWhereUniqueInput
    data: XOR<InterviewResultUpdateWithoutSlotInput, InterviewResultUncheckedUpdateWithoutSlotInput>
  }

  export type InterviewResultUpdateManyWithWhereWithoutSlotInput = {
    where: InterviewResultScalarWhereInput
    data: XOR<InterviewResultUpdateManyMutationInput, InterviewResultUncheckedUpdateManyWithoutSlotInput>
  }

  export type InterviewResultScalarWhereInput = {
    AND?: InterviewResultScalarWhereInput | InterviewResultScalarWhereInput[]
    OR?: InterviewResultScalarWhereInput[]
    NOT?: InterviewResultScalarWhereInput | InterviewResultScalarWhereInput[]
    id?: StringFilter<"InterviewResult"> | string
    applicationId?: StringFilter<"InterviewResult"> | string
    slotId?: StringFilter<"InterviewResult"> | string
    score?: IntNullableFilter<"InterviewResult"> | number | null
    comments?: StringNullableFilter<"InterviewResult"> | string | null
    isPassed?: BoolNullableFilter<"InterviewResult"> | boolean | null
    confirmedAt?: DateTimeNullableFilter<"InterviewResult"> | Date | string | null
    rescheduleRequested?: BoolFilter<"InterviewResult"> | boolean
    rescheduleReason?: StringNullableFilter<"InterviewResult"> | string | null
    checkedInAt?: DateTimeNullableFilter<"InterviewResult"> | Date | string | null
  }

  export type InterviewSlotInterviewerUpsertWithWhereUniqueWithoutSlotInput = {
    where: InterviewSlotInterviewerWhereUniqueInput
    update: XOR<InterviewSlotInterviewerUpdateWithoutSlotInput, InterviewSlotInterviewerUncheckedUpdateWithoutSlotInput>
    create: XOR<InterviewSlotInterviewerCreateWithoutSlotInput, InterviewSlotInterviewerUncheckedCreateWithoutSlotInput>
  }

  export type InterviewSlotInterviewerUpdateWithWhereUniqueWithoutSlotInput = {
    where: InterviewSlotInterviewerWhereUniqueInput
    data: XOR<InterviewSlotInterviewerUpdateWithoutSlotInput, InterviewSlotInterviewerUncheckedUpdateWithoutSlotInput>
  }

  export type InterviewSlotInterviewerUpdateManyWithWhereWithoutSlotInput = {
    where: InterviewSlotInterviewerScalarWhereInput
    data: XOR<InterviewSlotInterviewerUpdateManyMutationInput, InterviewSlotInterviewerUncheckedUpdateManyWithoutSlotInput>
  }

  export type InterviewSlotCreateWithoutInterviewersInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    program?: ProgramCreateNestedOneWithoutInterviewSlotsInput
    interviewResults?: InterviewResultCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotUncheckedCreateWithoutInterviewersInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    programId?: string | null
    interviewResults?: InterviewResultUncheckedCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotCreateOrConnectWithoutInterviewersInput = {
    where: InterviewSlotWhereUniqueInput
    create: XOR<InterviewSlotCreateWithoutInterviewersInput, InterviewSlotUncheckedCreateWithoutInterviewersInput>
  }

  export type PersonnelCreateWithoutInterviewSlotsInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutInterviewSlotsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutInterviewSlotsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutInterviewSlotsInput, PersonnelUncheckedCreateWithoutInterviewSlotsInput>
  }

  export type InterviewSlotUpsertWithoutInterviewersInput = {
    update: XOR<InterviewSlotUpdateWithoutInterviewersInput, InterviewSlotUncheckedUpdateWithoutInterviewersInput>
    create: XOR<InterviewSlotCreateWithoutInterviewersInput, InterviewSlotUncheckedCreateWithoutInterviewersInput>
    where?: InterviewSlotWhereInput
  }

  export type InterviewSlotUpdateToOneWithWhereWithoutInterviewersInput = {
    where?: InterviewSlotWhereInput
    data: XOR<InterviewSlotUpdateWithoutInterviewersInput, InterviewSlotUncheckedUpdateWithoutInterviewersInput>
  }

  export type InterviewSlotUpdateWithoutInterviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneWithoutInterviewSlotsNestedInput
    interviewResults?: InterviewResultUpdateManyWithoutSlotNestedInput
  }

  export type InterviewSlotUncheckedUpdateWithoutInterviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    interviewResults?: InterviewResultUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type PersonnelUpsertWithoutInterviewSlotsInput = {
    update: XOR<PersonnelUpdateWithoutInterviewSlotsInput, PersonnelUncheckedUpdateWithoutInterviewSlotsInput>
    create: XOR<PersonnelCreateWithoutInterviewSlotsInput, PersonnelUncheckedCreateWithoutInterviewSlotsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutInterviewSlotsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutInterviewSlotsInput, PersonnelUncheckedUpdateWithoutInterviewSlotsInput>
  }

  export type PersonnelUpdateWithoutInterviewSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutInterviewSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type ApplicationCreateWithoutInterviewInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutApplicationsInput
    track?: AdmissionTrackCreateNestedOneWithoutApplicationsInput
    program: ProgramCreateNestedOneWithoutApplicationsInput
    documents?: DocumentCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutInterviewInput = {
    id?: string
    applicantId: string
    trackId?: string | null
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutInterviewInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutInterviewInput, ApplicationUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewSlotCreateWithoutInterviewResultsInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    program?: ProgramCreateNestedOneWithoutInterviewSlotsInput
    interviewers?: InterviewSlotInterviewerCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotUncheckedCreateWithoutInterviewResultsInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
    programId?: string | null
    interviewers?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutSlotInput
  }

  export type InterviewSlotCreateOrConnectWithoutInterviewResultsInput = {
    where: InterviewSlotWhereUniqueInput
    create: XOR<InterviewSlotCreateWithoutInterviewResultsInput, InterviewSlotUncheckedCreateWithoutInterviewResultsInput>
  }

  export type InterviewFeedbackCreateWithoutInterviewResultInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type InterviewFeedbackUncheckedCreateWithoutInterviewResultInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type InterviewFeedbackCreateOrConnectWithoutInterviewResultInput = {
    where: InterviewFeedbackWhereUniqueInput
    create: XOR<InterviewFeedbackCreateWithoutInterviewResultInput, InterviewFeedbackUncheckedCreateWithoutInterviewResultInput>
  }

  export type ApplicationUpsertWithoutInterviewInput = {
    update: XOR<ApplicationUpdateWithoutInterviewInput, ApplicationUncheckedUpdateWithoutInterviewInput>
    create: XOR<ApplicationCreateWithoutInterviewInput, ApplicationUncheckedCreateWithoutInterviewInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutInterviewInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutInterviewInput, ApplicationUncheckedUpdateWithoutInterviewInput>
  }

  export type ApplicationUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutApplicationsNestedInput
    track?: AdmissionTrackUpdateOneWithoutApplicationsNestedInput
    program?: ProgramUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: DocumentUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type InterviewSlotUpsertWithoutInterviewResultsInput = {
    update: XOR<InterviewSlotUpdateWithoutInterviewResultsInput, InterviewSlotUncheckedUpdateWithoutInterviewResultsInput>
    create: XOR<InterviewSlotCreateWithoutInterviewResultsInput, InterviewSlotUncheckedCreateWithoutInterviewResultsInput>
    where?: InterviewSlotWhereInput
  }

  export type InterviewSlotUpdateToOneWithWhereWithoutInterviewResultsInput = {
    where?: InterviewSlotWhereInput
    data: XOR<InterviewSlotUpdateWithoutInterviewResultsInput, InterviewSlotUncheckedUpdateWithoutInterviewResultsInput>
  }

  export type InterviewSlotUpdateWithoutInterviewResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneWithoutInterviewSlotsNestedInput
    interviewers?: InterviewSlotInterviewerUpdateManyWithoutSlotNestedInput
  }

  export type InterviewSlotUncheckedUpdateWithoutInterviewResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    interviewers?: InterviewSlotInterviewerUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type InterviewFeedbackUpsertWithoutInterviewResultInput = {
    update: XOR<InterviewFeedbackUpdateWithoutInterviewResultInput, InterviewFeedbackUncheckedUpdateWithoutInterviewResultInput>
    create: XOR<InterviewFeedbackCreateWithoutInterviewResultInput, InterviewFeedbackUncheckedCreateWithoutInterviewResultInput>
    where?: InterviewFeedbackWhereInput
  }

  export type InterviewFeedbackUpdateToOneWithWhereWithoutInterviewResultInput = {
    where?: InterviewFeedbackWhereInput
    data: XOR<InterviewFeedbackUpdateWithoutInterviewResultInput, InterviewFeedbackUncheckedUpdateWithoutInterviewResultInput>
  }

  export type InterviewFeedbackUpdateWithoutInterviewResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewFeedbackUncheckedUpdateWithoutInterviewResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewResultCreateWithoutFeedbackInput = {
    id?: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
    application: ApplicationCreateNestedOneWithoutInterviewInput
    slot: InterviewSlotCreateNestedOneWithoutInterviewResultsInput
  }

  export type InterviewResultUncheckedCreateWithoutFeedbackInput = {
    id?: string
    applicationId: string
    slotId: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
  }

  export type InterviewResultCreateOrConnectWithoutFeedbackInput = {
    where: InterviewResultWhereUniqueInput
    create: XOR<InterviewResultCreateWithoutFeedbackInput, InterviewResultUncheckedCreateWithoutFeedbackInput>
  }

  export type InterviewResultUpsertWithoutFeedbackInput = {
    update: XOR<InterviewResultUpdateWithoutFeedbackInput, InterviewResultUncheckedUpdateWithoutFeedbackInput>
    create: XOR<InterviewResultCreateWithoutFeedbackInput, InterviewResultUncheckedCreateWithoutFeedbackInput>
    where?: InterviewResultWhereInput
  }

  export type InterviewResultUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: InterviewResultWhereInput
    data: XOR<InterviewResultUpdateWithoutFeedbackInput, InterviewResultUncheckedUpdateWithoutFeedbackInput>
  }

  export type InterviewResultUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    application?: ApplicationUpdateOneRequiredWithoutInterviewNestedInput
    slot?: InterviewSlotUpdateOneRequiredWithoutInterviewResultsNestedInput
  }

  export type InterviewResultUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgramCreateWithoutStudentGroupsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    department: DepartmentCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    students?: StudentCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutStudentGroupsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutStudentGroupsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutStudentGroupsInput, ProgramUncheckedCreateWithoutStudentGroupsInput>
  }

  export type PersonnelCreateWithoutAdvisorGroupsInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutAdvisorGroupsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutAdvisorGroupsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutAdvisorGroupsInput, PersonnelUncheckedCreateWithoutAdvisorGroupsInput>
  }

  export type StudentCreateWithoutStudentGroupInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentGroupInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentGroupInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentGroupInput, StudentUncheckedCreateWithoutStudentGroupInput>
  }

  export type StudentCreateManyStudentGroupInputEnvelope = {
    data: StudentCreateManyStudentGroupInput | StudentCreateManyStudentGroupInput[]
    skipDuplicates?: boolean
  }

  export type ClassSectionCreateWithoutStudentGroupsInput = {
    id?: string
    sectionNumber: string
    capacity: number
    course: CourseCreateNestedOneWithoutSectionsInput
    term: AcademicTermCreateNestedOneWithoutSectionsInput
    instructor?: PersonnelCreateNestedOneWithoutInstructedSectionsInput
    schedules?: ClassScheduleCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentCreateNestedManyWithoutSectionInput
  }

  export type ClassSectionUncheckedCreateWithoutStudentGroupsInput = {
    id?: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutSectionInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type ClassSectionCreateOrConnectWithoutStudentGroupsInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutStudentGroupsInput, ClassSectionUncheckedCreateWithoutStudentGroupsInput>
  }

  export type ProgramUpsertWithoutStudentGroupsInput = {
    update: XOR<ProgramUpdateWithoutStudentGroupsInput, ProgramUncheckedUpdateWithoutStudentGroupsInput>
    create: XOR<ProgramCreateWithoutStudentGroupsInput, ProgramUncheckedCreateWithoutStudentGroupsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutStudentGroupsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutStudentGroupsInput, ProgramUncheckedUpdateWithoutStudentGroupsInput>
  }

  export type ProgramUpdateWithoutStudentGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutStudentGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type PersonnelUpsertWithoutAdvisorGroupsInput = {
    update: XOR<PersonnelUpdateWithoutAdvisorGroupsInput, PersonnelUncheckedUpdateWithoutAdvisorGroupsInput>
    create: XOR<PersonnelCreateWithoutAdvisorGroupsInput, PersonnelUncheckedCreateWithoutAdvisorGroupsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutAdvisorGroupsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutAdvisorGroupsInput, PersonnelUncheckedUpdateWithoutAdvisorGroupsInput>
  }

  export type PersonnelUpdateWithoutAdvisorGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutAdvisorGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutStudentGroupInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutStudentGroupInput, StudentUncheckedUpdateWithoutStudentGroupInput>
    create: XOR<StudentCreateWithoutStudentGroupInput, StudentUncheckedCreateWithoutStudentGroupInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutStudentGroupInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutStudentGroupInput, StudentUncheckedUpdateWithoutStudentGroupInput>
  }

  export type StudentUpdateManyWithWhereWithoutStudentGroupInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentGroupInput>
  }

  export type ClassSectionUpsertWithWhereUniqueWithoutStudentGroupsInput = {
    where: ClassSectionWhereUniqueInput
    update: XOR<ClassSectionUpdateWithoutStudentGroupsInput, ClassSectionUncheckedUpdateWithoutStudentGroupsInput>
    create: XOR<ClassSectionCreateWithoutStudentGroupsInput, ClassSectionUncheckedCreateWithoutStudentGroupsInput>
  }

  export type ClassSectionUpdateWithWhereUniqueWithoutStudentGroupsInput = {
    where: ClassSectionWhereUniqueInput
    data: XOR<ClassSectionUpdateWithoutStudentGroupsInput, ClassSectionUncheckedUpdateWithoutStudentGroupsInput>
  }

  export type ClassSectionUpdateManyWithWhereWithoutStudentGroupsInput = {
    where: ClassSectionScalarWhereInput
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyWithoutStudentGroupsInput>
  }

  export type UserCreateWithoutStudentProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantCreateNestedOneWithoutUserInput
    logs?: SystemLogCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutStudentProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelUncheckedCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantUncheckedCreateNestedOneWithoutUserInput
    logs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutStudentProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
  }

  export type ProgramCreateWithoutStudentsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    faculty: FacultyCreateNestedOneWithoutProgramsInput
    department: DepartmentCreateNestedOneWithoutProgramsInput
    applications?: ApplicationCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutStudentsInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
    departmentId: string
    applications?: ApplicationUncheckedCreateNestedManyWithoutProgramInput
    interviewSlots?: InterviewSlotUncheckedCreateNestedManyWithoutProgramInput
    courses?: ProgramCourseUncheckedCreateNestedManyWithoutProgramInput
    admissionTracks?: AdmissionTrackUncheckedCreateNestedManyWithoutProgramInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutStudentsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
  }

  export type StudentGroupCreateWithoutStudentsInput = {
    id?: string
    name: string
    admissionYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutStudentGroupsInput
    advisor?: PersonnelCreateNestedOneWithoutAdvisorGroupsInput
    sections?: ClassSectionCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    admissionYear: number
    programId: string
    advisorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: ClassSectionUncheckedCreateNestedManyWithoutStudentGroupsInput
  }

  export type StudentGroupCreateOrConnectWithoutStudentsInput = {
    where: StudentGroupWhereUniqueInput
    create: XOR<StudentGroupCreateWithoutStudentsInput, StudentGroupUncheckedCreateWithoutStudentsInput>
  }

  export type EnrollmentCreateWithoutStudentInput = {
    id?: string
    grade?: string | null
    enrolledAt?: Date | string
    section: ClassSectionCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    sectionId: string
    grade?: string | null
    enrolledAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentCreateManyStudentInputEnvelope = {
    data: EnrollmentCreateManyStudentInput | EnrollmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutStudentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    term: AcademicTermCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutStudentInput = {
    id?: string
    termId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceCreateManyStudentInputEnvelope = {
    data: InvoiceCreateManyStudentInput | InvoiceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutStudentInput = {
    id?: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer?: PersonnelCreateNestedOneWithoutReviewedLeaveRequestsInput
  }

  export type LeaveRequestUncheckedCreateWithoutStudentInput = {
    id?: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateOrConnectWithoutStudentInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutStudentInput, LeaveRequestUncheckedCreateWithoutStudentInput>
  }

  export type LeaveRequestCreateManyStudentInputEnvelope = {
    data: LeaveRequestCreateManyStudentInput | LeaveRequestCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentProfileInput = {
    update: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type UserUpdateWithoutStudentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUpdateOneWithoutUserNestedInput
    logs?: SystemLogUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUncheckedUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUncheckedUpdateOneWithoutUserNestedInput
    logs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ProgramUpsertWithoutStudentsInput = {
    update: XOR<ProgramUpdateWithoutStudentsInput, ProgramUncheckedUpdateWithoutStudentsInput>
    create: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutStudentsInput, ProgramUncheckedUpdateWithoutStudentsInput>
  }

  export type ProgramUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type StudentGroupUpsertWithoutStudentsInput = {
    update: XOR<StudentGroupUpdateWithoutStudentsInput, StudentGroupUncheckedUpdateWithoutStudentsInput>
    create: XOR<StudentGroupCreateWithoutStudentsInput, StudentGroupUncheckedCreateWithoutStudentsInput>
    where?: StudentGroupWhereInput
  }

  export type StudentGroupUpdateToOneWithWhereWithoutStudentsInput = {
    where?: StudentGroupWhereInput
    data: XOR<StudentGroupUpdateWithoutStudentsInput, StudentGroupUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentGroupUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutStudentGroupsNestedInput
    advisor?: PersonnelUpdateOneWithoutAdvisorGroupsNestedInput
    sections?: ClassSectionUpdateManyWithoutStudentGroupsNestedInput
  }

  export type StudentGroupUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: ClassSectionUncheckedUpdateManyWithoutStudentGroupsNestedInput
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    sectionId?: StringFilter<"Enrollment"> | string
    grade?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutStudentInput, InvoiceUncheckedUpdateWithoutStudentInput>
    create: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutStudentInput, InvoiceUncheckedUpdateWithoutStudentInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutStudentInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutStudentInput>
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutStudentInput, LeaveRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<LeaveRequestCreateWithoutStudentInput, LeaveRequestUncheckedCreateWithoutStudentInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutStudentInput, LeaveRequestUncheckedUpdateWithoutStudentInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutStudentInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutStudentInput>
  }

  export type CourseCreateWithoutSectionsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    programs?: ProgramCourseCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSectionsInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    programs?: ProgramCourseUncheckedCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSectionsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
  }

  export type AcademicTermCreateWithoutSectionsInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    invoices?: InvoiceCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleCreateNestedManyWithoutTermInput
  }

  export type AcademicTermUncheckedCreateWithoutSectionsInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutTermInput
  }

  export type AcademicTermCreateOrConnectWithoutSectionsInput = {
    where: AcademicTermWhereUniqueInput
    create: XOR<AcademicTermCreateWithoutSectionsInput, AcademicTermUncheckedCreateWithoutSectionsInput>
  }

  export type PersonnelCreateWithoutInstructedSectionsInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutInstructedSectionsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutInstructedSectionsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutInstructedSectionsInput, PersonnelUncheckedCreateWithoutInstructedSectionsInput>
  }

  export type ClassScheduleCreateWithoutSectionInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: RoomCreateNestedOneWithoutSchedulesInput
    course?: CourseCreateNestedOneWithoutSchedulesInput
    instructor?: PersonnelCreateNestedOneWithoutTeachingSchedulesInput
    term?: AcademicTermCreateNestedOneWithoutSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutSectionInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type ClassScheduleCreateOrConnectWithoutSectionInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutSectionInput, ClassScheduleUncheckedCreateWithoutSectionInput>
  }

  export type ClassScheduleCreateManySectionInputEnvelope = {
    data: ClassScheduleCreateManySectionInput | ClassScheduleCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutSectionInput = {
    id?: string
    grade?: string | null
    enrolledAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutSectionInput = {
    id?: string
    studentId: string
    grade?: string | null
    enrolledAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutSectionInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutSectionInput, EnrollmentUncheckedCreateWithoutSectionInput>
  }

  export type EnrollmentCreateManySectionInputEnvelope = {
    data: EnrollmentCreateManySectionInput | EnrollmentCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type StudentGroupCreateWithoutSectionsInput = {
    id?: string
    name: string
    admissionYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutStudentGroupsInput
    advisor?: PersonnelCreateNestedOneWithoutAdvisorGroupsInput
    students?: StudentCreateNestedManyWithoutStudentGroupInput
  }

  export type StudentGroupUncheckedCreateWithoutSectionsInput = {
    id?: string
    name: string
    admissionYear: number
    programId: string
    advisorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutStudentGroupInput
  }

  export type StudentGroupCreateOrConnectWithoutSectionsInput = {
    where: StudentGroupWhereUniqueInput
    create: XOR<StudentGroupCreateWithoutSectionsInput, StudentGroupUncheckedCreateWithoutSectionsInput>
  }

  export type CourseUpsertWithoutSectionsInput = {
    update: XOR<CourseUpdateWithoutSectionsInput, CourseUncheckedUpdateWithoutSectionsInput>
    create: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSectionsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSectionsInput, CourseUncheckedUpdateWithoutSectionsInput>
  }

  export type CourseUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    programs?: ProgramCourseUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    programs?: ProgramCourseUncheckedUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicTermUpsertWithoutSectionsInput = {
    update: XOR<AcademicTermUpdateWithoutSectionsInput, AcademicTermUncheckedUpdateWithoutSectionsInput>
    create: XOR<AcademicTermCreateWithoutSectionsInput, AcademicTermUncheckedCreateWithoutSectionsInput>
    where?: AcademicTermWhereInput
  }

  export type AcademicTermUpdateToOneWithWhereWithoutSectionsInput = {
    where?: AcademicTermWhereInput
    data: XOR<AcademicTermUpdateWithoutSectionsInput, AcademicTermUncheckedUpdateWithoutSectionsInput>
  }

  export type AcademicTermUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUpdateManyWithoutTermNestedInput
  }

  export type AcademicTermUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutTermNestedInput
  }

  export type PersonnelUpsertWithoutInstructedSectionsInput = {
    update: XOR<PersonnelUpdateWithoutInstructedSectionsInput, PersonnelUncheckedUpdateWithoutInstructedSectionsInput>
    create: XOR<PersonnelCreateWithoutInstructedSectionsInput, PersonnelUncheckedCreateWithoutInstructedSectionsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutInstructedSectionsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutInstructedSectionsInput, PersonnelUncheckedUpdateWithoutInstructedSectionsInput>
  }

  export type PersonnelUpdateWithoutInstructedSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutInstructedSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutSectionInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutSectionInput, ClassScheduleUncheckedUpdateWithoutSectionInput>
    create: XOR<ClassScheduleCreateWithoutSectionInput, ClassScheduleUncheckedCreateWithoutSectionInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutSectionInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutSectionInput, ClassScheduleUncheckedUpdateWithoutSectionInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutSectionInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutSectionInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutSectionInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutSectionInput, EnrollmentUncheckedUpdateWithoutSectionInput>
    create: XOR<EnrollmentCreateWithoutSectionInput, EnrollmentUncheckedCreateWithoutSectionInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutSectionInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutSectionInput, EnrollmentUncheckedUpdateWithoutSectionInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutSectionInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutSectionInput>
  }

  export type StudentGroupUpsertWithWhereUniqueWithoutSectionsInput = {
    where: StudentGroupWhereUniqueInput
    update: XOR<StudentGroupUpdateWithoutSectionsInput, StudentGroupUncheckedUpdateWithoutSectionsInput>
    create: XOR<StudentGroupCreateWithoutSectionsInput, StudentGroupUncheckedCreateWithoutSectionsInput>
  }

  export type StudentGroupUpdateWithWhereUniqueWithoutSectionsInput = {
    where: StudentGroupWhereUniqueInput
    data: XOR<StudentGroupUpdateWithoutSectionsInput, StudentGroupUncheckedUpdateWithoutSectionsInput>
  }

  export type StudentGroupUpdateManyWithWhereWithoutSectionsInput = {
    where: StudentGroupScalarWhereInput
    data: XOR<StudentGroupUpdateManyMutationInput, StudentGroupUncheckedUpdateManyWithoutSectionsInput>
  }

  export type ClassSectionCreateWithoutSchedulesInput = {
    id?: string
    sectionNumber: string
    capacity: number
    course: CourseCreateNestedOneWithoutSectionsInput
    term: AcademicTermCreateNestedOneWithoutSectionsInput
    instructor?: PersonnelCreateNestedOneWithoutInstructedSectionsInput
    enrollments?: EnrollmentCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionUncheckedCreateWithoutSchedulesInput = {
    id?: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionCreateOrConnectWithoutSchedulesInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutSchedulesInput, ClassSectionUncheckedCreateWithoutSchedulesInput>
  }

  export type RoomCreateWithoutSchedulesInput = {
    id?: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examSlots?: ExamSlotCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutSchedulesInput = {
    id?: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examSlots?: ExamSlotUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutSchedulesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutSchedulesInput, RoomUncheckedCreateWithoutSchedulesInput>
  }

  export type CourseCreateWithoutSchedulesInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionCreateNestedManyWithoutCourseInput
    programs?: ProgramCourseCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSchedulesInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutCourseInput
    programs?: ProgramCourseUncheckedCreateNestedManyWithoutCourseInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSchedulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSchedulesInput, CourseUncheckedCreateWithoutSchedulesInput>
  }

  export type PersonnelCreateWithoutTeachingSchedulesInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutTeachingSchedulesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutTeachingSchedulesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutTeachingSchedulesInput, PersonnelUncheckedCreateWithoutTeachingSchedulesInput>
  }

  export type AcademicTermCreateWithoutSchedulesInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionCreateNestedManyWithoutTermInput
    invoices?: InvoiceCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutTermInput
  }

  export type AcademicTermUncheckedCreateWithoutSchedulesInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutTermInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutTermInput
  }

  export type AcademicTermCreateOrConnectWithoutSchedulesInput = {
    where: AcademicTermWhereUniqueInput
    create: XOR<AcademicTermCreateWithoutSchedulesInput, AcademicTermUncheckedCreateWithoutSchedulesInput>
  }

  export type ClassSectionUpsertWithoutSchedulesInput = {
    update: XOR<ClassSectionUpdateWithoutSchedulesInput, ClassSectionUncheckedUpdateWithoutSchedulesInput>
    create: XOR<ClassSectionCreateWithoutSchedulesInput, ClassSectionUncheckedCreateWithoutSchedulesInput>
    where?: ClassSectionWhereInput
  }

  export type ClassSectionUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: ClassSectionWhereInput
    data: XOR<ClassSectionUpdateWithoutSchedulesInput, ClassSectionUncheckedUpdateWithoutSchedulesInput>
  }

  export type ClassSectionUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonnelUpdateOneWithoutInstructedSectionsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type RoomUpsertWithoutSchedulesInput = {
    update: XOR<RoomUpdateWithoutSchedulesInput, RoomUncheckedUpdateWithoutSchedulesInput>
    create: XOR<RoomCreateWithoutSchedulesInput, RoomUncheckedCreateWithoutSchedulesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutSchedulesInput, RoomUncheckedUpdateWithoutSchedulesInput>
  }

  export type RoomUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSlots?: ExamSlotUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSlots?: ExamSlotUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type CourseUpsertWithoutSchedulesInput = {
    update: XOR<CourseUpdateWithoutSchedulesInput, CourseUncheckedUpdateWithoutSchedulesInput>
    create: XOR<CourseCreateWithoutSchedulesInput, CourseUncheckedCreateWithoutSchedulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSchedulesInput, CourseUncheckedUpdateWithoutSchedulesInput>
  }

  export type CourseUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutCourseNestedInput
    programs?: ProgramCourseUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutCourseNestedInput
    programs?: ProgramCourseUncheckedUpdateManyWithoutCourseNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type PersonnelUpsertWithoutTeachingSchedulesInput = {
    update: XOR<PersonnelUpdateWithoutTeachingSchedulesInput, PersonnelUncheckedUpdateWithoutTeachingSchedulesInput>
    create: XOR<PersonnelCreateWithoutTeachingSchedulesInput, PersonnelUncheckedCreateWithoutTeachingSchedulesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutTeachingSchedulesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutTeachingSchedulesInput, PersonnelUncheckedUpdateWithoutTeachingSchedulesInput>
  }

  export type PersonnelUpdateWithoutTeachingSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutTeachingSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type AcademicTermUpsertWithoutSchedulesInput = {
    update: XOR<AcademicTermUpdateWithoutSchedulesInput, AcademicTermUncheckedUpdateWithoutSchedulesInput>
    create: XOR<AcademicTermCreateWithoutSchedulesInput, AcademicTermUncheckedCreateWithoutSchedulesInput>
    where?: AcademicTermWhereInput
  }

  export type AcademicTermUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: AcademicTermWhereInput
    data: XOR<AcademicTermUpdateWithoutSchedulesInput, AcademicTermUncheckedUpdateWithoutSchedulesInput>
  }

  export type AcademicTermUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutTermNestedInput
  }

  export type AcademicTermUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutTermNestedInput
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    studentGroup?: StudentGroupCreateNestedOneWithoutStudentsInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ClassSectionCreateWithoutEnrollmentsInput = {
    id?: string
    sectionNumber: string
    capacity: number
    course: CourseCreateNestedOneWithoutSectionsInput
    term: AcademicTermCreateNestedOneWithoutSectionsInput
    instructor?: PersonnelCreateNestedOneWithoutInstructedSectionsInput
    schedules?: ClassScheduleCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutSectionInput
    studentGroups?: StudentGroupUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type ClassSectionCreateOrConnectWithoutEnrollmentsInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutEnrollmentsInput, ClassSectionUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    studentGroup?: StudentGroupUpdateOneWithoutStudentsNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassSectionUpsertWithoutEnrollmentsInput = {
    update: XOR<ClassSectionUpdateWithoutEnrollmentsInput, ClassSectionUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<ClassSectionCreateWithoutEnrollmentsInput, ClassSectionUncheckedCreateWithoutEnrollmentsInput>
    where?: ClassSectionWhereInput
  }

  export type ClassSectionUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: ClassSectionWhereInput
    data: XOR<ClassSectionUpdateWithoutEnrollmentsInput, ClassSectionUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassSectionUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonnelUpdateOneWithoutInstructedSectionsNestedInput
    schedules?: ClassScheduleUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    schedules?: ClassScheduleUncheckedUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type StudentCreateWithoutInvoicesInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    studentGroup?: StudentGroupCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInvoicesInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInvoicesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
  }

  export type AcademicTermCreateWithoutInvoicesInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleCreateNestedManyWithoutTermInput
  }

  export type AcademicTermUncheckedCreateWithoutInvoicesInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutTermInput
  }

  export type AcademicTermCreateOrConnectWithoutInvoicesInput = {
    where: AcademicTermWhereUniqueInput
    create: XOR<AcademicTermCreateWithoutInvoicesInput, AcademicTermUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    slipUrl?: string | null
    paidAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    slipUrl?: string | null
    paidAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutInvoicesInput = {
    update: XOR<StudentUpdateWithoutInvoicesInput, StudentUncheckedUpdateWithoutInvoicesInput>
    create: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutInvoicesInput, StudentUncheckedUpdateWithoutInvoicesInput>
  }

  export type StudentUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    studentGroup?: StudentGroupUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicTermUpsertWithoutInvoicesInput = {
    update: XOR<AcademicTermUpdateWithoutInvoicesInput, AcademicTermUncheckedUpdateWithoutInvoicesInput>
    create: XOR<AcademicTermCreateWithoutInvoicesInput, AcademicTermUncheckedCreateWithoutInvoicesInput>
    where?: AcademicTermWhereInput
  }

  export type AcademicTermUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: AcademicTermWhereInput
    data: XOR<AcademicTermUpdateWithoutInvoicesInput, AcademicTermUncheckedUpdateWithoutInvoicesInput>
  }

  export type AcademicTermUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUpdateManyWithoutTermNestedInput
  }

  export type AcademicTermUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutTermNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    slipUrl?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verifiedBy?: StringNullableFilter<"Payment"> | string | null
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutInvoicesInput
    term: AcademicTermCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    studentId: string
    termId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutInvoicesInput
    term: AcademicTermCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    studentId: string
    termId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserCreateWithoutAnnouncementsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelCreateNestedOneWithoutUserInput
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantCreateNestedOneWithoutUserInput
    logs?: SystemLogCreateNestedManyWithoutUserInput
    helpArticles?: HelpArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantUncheckedCreateNestedOneWithoutUserInput
    logs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    helpArticles?: HelpArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
  }

  export type UserUpsertWithoutAnnouncementsInput = {
    update: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUpdateOneWithoutUserNestedInput
    logs?: SystemLogUpdateManyWithoutUserNestedInput
    helpArticles?: HelpArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUncheckedUpdateOneWithoutUserNestedInput
    logs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    helpArticles?: HelpArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AiMessageCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AiMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AiMessageCreateOrConnectWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    create: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput>
  }

  export type AiMessageCreateManyConversationInputEnvelope = {
    data: AiMessageCreateManyConversationInput | AiMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type AiMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    update: XOR<AiMessageUpdateWithoutConversationInput, AiMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput>
  }

  export type AiMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    data: XOR<AiMessageUpdateWithoutConversationInput, AiMessageUncheckedUpdateWithoutConversationInput>
  }

  export type AiMessageUpdateManyWithWhereWithoutConversationInput = {
    where: AiMessageScalarWhereInput
    data: XOR<AiMessageUpdateManyMutationInput, AiMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type AiMessageScalarWhereInput = {
    AND?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
    OR?: AiMessageScalarWhereInput[]
    NOT?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
    id?: StringFilter<"AiMessage"> | string
    conversationId?: StringFilter<"AiMessage"> | string
    role?: StringFilter<"AiMessage"> | string
    content?: StringFilter<"AiMessage"> | string
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
  }

  export type AiConversationCreateWithoutMessagesInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationCreateOrConnectWithoutMessagesInput = {
    where: AiConversationWhereUniqueInput
    create: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
  }

  export type AiConversationUpsertWithoutMessagesInput = {
    update: XOR<AiConversationUpdateWithoutMessagesInput, AiConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    where?: AiConversationWhereInput
  }

  export type AiConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AiConversationWhereInput
    data: XOR<AiConversationUpdateWithoutMessagesInput, AiConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type AiConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutHelpArticlesInput
  }

  export type HelpArticleUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    authorId: string
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleCreateOrConnectWithoutCategoryInput = {
    where: HelpArticleWhereUniqueInput
    create: XOR<HelpArticleCreateWithoutCategoryInput, HelpArticleUncheckedCreateWithoutCategoryInput>
  }

  export type HelpArticleCreateManyCategoryInputEnvelope = {
    data: HelpArticleCreateManyCategoryInput | HelpArticleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type HelpArticleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: HelpArticleWhereUniqueInput
    update: XOR<HelpArticleUpdateWithoutCategoryInput, HelpArticleUncheckedUpdateWithoutCategoryInput>
    create: XOR<HelpArticleCreateWithoutCategoryInput, HelpArticleUncheckedCreateWithoutCategoryInput>
  }

  export type HelpArticleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: HelpArticleWhereUniqueInput
    data: XOR<HelpArticleUpdateWithoutCategoryInput, HelpArticleUncheckedUpdateWithoutCategoryInput>
  }

  export type HelpArticleUpdateManyWithWhereWithoutCategoryInput = {
    where: HelpArticleScalarWhereInput
    data: XOR<HelpArticleUpdateManyMutationInput, HelpArticleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type HelpCategoryCreateWithoutArticlesInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpCategoryUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpCategoryCreateOrConnectWithoutArticlesInput = {
    where: HelpCategoryWhereUniqueInput
    create: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
  }

  export type UserCreateWithoutHelpArticlesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelCreateNestedOneWithoutUserInput
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantCreateNestedOneWithoutUserInput
    logs?: SystemLogCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutHelpArticlesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantUncheckedCreateNestedOneWithoutUserInput
    logs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutHelpArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHelpArticlesInput, UserUncheckedCreateWithoutHelpArticlesInput>
  }

  export type HelpCategoryUpsertWithoutArticlesInput = {
    update: XOR<HelpCategoryUpdateWithoutArticlesInput, HelpCategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
    where?: HelpCategoryWhereInput
  }

  export type HelpCategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: HelpCategoryWhereInput
    data: XOR<HelpCategoryUpdateWithoutArticlesInput, HelpCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type HelpCategoryUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCategoryUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutHelpArticlesInput = {
    update: XOR<UserUpdateWithoutHelpArticlesInput, UserUncheckedUpdateWithoutHelpArticlesInput>
    create: XOR<UserCreateWithoutHelpArticlesInput, UserUncheckedCreateWithoutHelpArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHelpArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHelpArticlesInput, UserUncheckedUpdateWithoutHelpArticlesInput>
  }

  export type UserUpdateWithoutHelpArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUpdateOneWithoutUserNestedInput
    logs?: SystemLogUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutHelpArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUncheckedUpdateOneWithoutUserNestedInput
    logs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelCreateNestedOneWithoutUserInput
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantCreateNestedOneWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: string | null
    personnelProfile?: PersonnelUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    applicantProfile?: ApplicantUncheckedCreateNestedOneWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    helpArticles?: HelpArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUpdateOneWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    personnelProfile?: PersonnelUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    applicantProfile?: ApplicantUncheckedUpdateOneWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    helpArticles?: HelpArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ClassScheduleCreateWithoutRoomInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    section: ClassSectionCreateNestedOneWithoutSchedulesInput
    course?: CourseCreateNestedOneWithoutSchedulesInput
    instructor?: PersonnelCreateNestedOneWithoutTeachingSchedulesInput
    term?: AcademicTermCreateNestedOneWithoutSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutRoomInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    courseId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type ClassScheduleCreateOrConnectWithoutRoomInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutRoomInput, ClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type ClassScheduleCreateManyRoomInputEnvelope = {
    data: ClassScheduleCreateManyRoomInput | ClassScheduleCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ExamSlotCreateWithoutRoomInput = {
    id?: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examSchedule: ExamScheduleCreateNestedOneWithoutExamSlotsInput
    proctors?: ExamProctorCreateNestedManyWithoutExamSlotInput
  }

  export type ExamSlotUncheckedCreateWithoutRoomInput = {
    id?: string
    examScheduleId: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proctors?: ExamProctorUncheckedCreateNestedManyWithoutExamSlotInput
  }

  export type ExamSlotCreateOrConnectWithoutRoomInput = {
    where: ExamSlotWhereUniqueInput
    create: XOR<ExamSlotCreateWithoutRoomInput, ExamSlotUncheckedCreateWithoutRoomInput>
  }

  export type ExamSlotCreateManyRoomInputEnvelope = {
    data: ExamSlotCreateManyRoomInput | ExamSlotCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutRoomInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutRoomInput, ClassScheduleUncheckedUpdateWithoutRoomInput>
    create: XOR<ClassScheduleCreateWithoutRoomInput, ClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutRoomInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutRoomInput, ClassScheduleUncheckedUpdateWithoutRoomInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutRoomInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutRoomInput>
  }

  export type ExamSlotUpsertWithWhereUniqueWithoutRoomInput = {
    where: ExamSlotWhereUniqueInput
    update: XOR<ExamSlotUpdateWithoutRoomInput, ExamSlotUncheckedUpdateWithoutRoomInput>
    create: XOR<ExamSlotCreateWithoutRoomInput, ExamSlotUncheckedCreateWithoutRoomInput>
  }

  export type ExamSlotUpdateWithWhereUniqueWithoutRoomInput = {
    where: ExamSlotWhereUniqueInput
    data: XOR<ExamSlotUpdateWithoutRoomInput, ExamSlotUncheckedUpdateWithoutRoomInput>
  }

  export type ExamSlotUpdateManyWithWhereWithoutRoomInput = {
    where: ExamSlotScalarWhereInput
    data: XOR<ExamSlotUpdateManyMutationInput, ExamSlotUncheckedUpdateManyWithoutRoomInput>
  }

  export type ExamSlotScalarWhereInput = {
    AND?: ExamSlotScalarWhereInput | ExamSlotScalarWhereInput[]
    OR?: ExamSlotScalarWhereInput[]
    NOT?: ExamSlotScalarWhereInput | ExamSlotScalarWhereInput[]
    id?: StringFilter<"ExamSlot"> | string
    examScheduleId?: StringFilter<"ExamSlot"> | string
    roomId?: StringFilter<"ExamSlot"> | string
    capacity?: IntFilter<"ExamSlot"> | number
    assignedCount?: IntFilter<"ExamSlot"> | number
    createdAt?: DateTimeFilter<"ExamSlot"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSlot"> | Date | string
  }

  export type CourseCreateWithoutExamSchedulesInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionCreateNestedManyWithoutCourseInput
    programs?: ProgramCourseCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutExamSchedulesInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    credits: number
    description?: string | null
    learningOutcomes?: string | null
    syllabusUrl?: string | null
    minYearLevel?: number | null
    allowedStudentTypes?: string | null
    allowedPrograms?: string | null
    minGpax?: number | null
    prerequisiteCourses?: string | null
    maxEnrollment?: number | null
    requiresApproval?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutCourseInput
    programs?: ProgramCourseUncheckedCreateNestedManyWithoutCourseInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutExamSchedulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutExamSchedulesInput, CourseUncheckedCreateWithoutExamSchedulesInput>
  }

  export type AcademicTermCreateWithoutExamSchedulesInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionCreateNestedManyWithoutTermInput
    invoices?: InvoiceCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleCreateNestedManyWithoutTermInput
  }

  export type AcademicTermUncheckedCreateWithoutExamSchedulesInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutTermInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutTermInput
  }

  export type AcademicTermCreateOrConnectWithoutExamSchedulesInput = {
    where: AcademicTermWhereUniqueInput
    create: XOR<AcademicTermCreateWithoutExamSchedulesInput, AcademicTermUncheckedCreateWithoutExamSchedulesInput>
  }

  export type ExamSlotCreateWithoutExamScheduleInput = {
    id?: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutExamSlotsInput
    proctors?: ExamProctorCreateNestedManyWithoutExamSlotInput
  }

  export type ExamSlotUncheckedCreateWithoutExamScheduleInput = {
    id?: string
    roomId: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proctors?: ExamProctorUncheckedCreateNestedManyWithoutExamSlotInput
  }

  export type ExamSlotCreateOrConnectWithoutExamScheduleInput = {
    where: ExamSlotWhereUniqueInput
    create: XOR<ExamSlotCreateWithoutExamScheduleInput, ExamSlotUncheckedCreateWithoutExamScheduleInput>
  }

  export type ExamSlotCreateManyExamScheduleInputEnvelope = {
    data: ExamSlotCreateManyExamScheduleInput | ExamSlotCreateManyExamScheduleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutExamSchedulesInput = {
    update: XOR<CourseUpdateWithoutExamSchedulesInput, CourseUncheckedUpdateWithoutExamSchedulesInput>
    create: XOR<CourseCreateWithoutExamSchedulesInput, CourseUncheckedCreateWithoutExamSchedulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutExamSchedulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutExamSchedulesInput, CourseUncheckedUpdateWithoutExamSchedulesInput>
  }

  export type CourseUpdateWithoutExamSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutCourseNestedInput
    programs?: ProgramCourseUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutExamSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    learningOutcomes?: NullableStringFieldUpdateOperationsInput | string | null
    syllabusUrl?: NullableStringFieldUpdateOperationsInput | string | null
    minYearLevel?: NullableIntFieldUpdateOperationsInput | number | null
    allowedStudentTypes?: NullableStringFieldUpdateOperationsInput | string | null
    allowedPrograms?: NullableStringFieldUpdateOperationsInput | string | null
    minGpax?: NullableFloatFieldUpdateOperationsInput | number | null
    prerequisiteCourses?: NullableStringFieldUpdateOperationsInput | string | null
    maxEnrollment?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutCourseNestedInput
    programs?: ProgramCourseUncheckedUpdateManyWithoutCourseNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicTermUpsertWithoutExamSchedulesInput = {
    update: XOR<AcademicTermUpdateWithoutExamSchedulesInput, AcademicTermUncheckedUpdateWithoutExamSchedulesInput>
    create: XOR<AcademicTermCreateWithoutExamSchedulesInput, AcademicTermUncheckedCreateWithoutExamSchedulesInput>
    where?: AcademicTermWhereInput
  }

  export type AcademicTermUpdateToOneWithWhereWithoutExamSchedulesInput = {
    where?: AcademicTermWhereInput
    data: XOR<AcademicTermUpdateWithoutExamSchedulesInput, AcademicTermUncheckedUpdateWithoutExamSchedulesInput>
  }

  export type AcademicTermUpdateWithoutExamSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUpdateManyWithoutTermNestedInput
  }

  export type AcademicTermUncheckedUpdateWithoutExamSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutTermNestedInput
  }

  export type ExamSlotUpsertWithWhereUniqueWithoutExamScheduleInput = {
    where: ExamSlotWhereUniqueInput
    update: XOR<ExamSlotUpdateWithoutExamScheduleInput, ExamSlotUncheckedUpdateWithoutExamScheduleInput>
    create: XOR<ExamSlotCreateWithoutExamScheduleInput, ExamSlotUncheckedCreateWithoutExamScheduleInput>
  }

  export type ExamSlotUpdateWithWhereUniqueWithoutExamScheduleInput = {
    where: ExamSlotWhereUniqueInput
    data: XOR<ExamSlotUpdateWithoutExamScheduleInput, ExamSlotUncheckedUpdateWithoutExamScheduleInput>
  }

  export type ExamSlotUpdateManyWithWhereWithoutExamScheduleInput = {
    where: ExamSlotScalarWhereInput
    data: XOR<ExamSlotUpdateManyMutationInput, ExamSlotUncheckedUpdateManyWithoutExamScheduleInput>
  }

  export type ExamScheduleCreateWithoutExamSlotsInput = {
    id?: string
    section: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutExamSchedulesInput
    term: AcademicTermCreateNestedOneWithoutExamSchedulesInput
  }

  export type ExamScheduleUncheckedCreateWithoutExamSlotsInput = {
    id?: string
    courseId: string
    section: string
    termId: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScheduleCreateOrConnectWithoutExamSlotsInput = {
    where: ExamScheduleWhereUniqueInput
    create: XOR<ExamScheduleCreateWithoutExamSlotsInput, ExamScheduleUncheckedCreateWithoutExamSlotsInput>
  }

  export type RoomCreateWithoutExamSlotsInput = {
    id?: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ClassScheduleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutExamSlotsInput = {
    id?: string
    code: string
    name: string
    building: string
    floor: number
    capacity: number
    roomType: $Enums.RoomType
    facilities?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutExamSlotsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutExamSlotsInput, RoomUncheckedCreateWithoutExamSlotsInput>
  }

  export type ExamProctorCreateWithoutExamSlotInput = {
    id?: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    proctor: PersonnelCreateNestedOneWithoutProctorDutiesInput
  }

  export type ExamProctorUncheckedCreateWithoutExamSlotInput = {
    id?: string
    proctorId: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamProctorCreateOrConnectWithoutExamSlotInput = {
    where: ExamProctorWhereUniqueInput
    create: XOR<ExamProctorCreateWithoutExamSlotInput, ExamProctorUncheckedCreateWithoutExamSlotInput>
  }

  export type ExamProctorCreateManyExamSlotInputEnvelope = {
    data: ExamProctorCreateManyExamSlotInput | ExamProctorCreateManyExamSlotInput[]
    skipDuplicates?: boolean
  }

  export type ExamScheduleUpsertWithoutExamSlotsInput = {
    update: XOR<ExamScheduleUpdateWithoutExamSlotsInput, ExamScheduleUncheckedUpdateWithoutExamSlotsInput>
    create: XOR<ExamScheduleCreateWithoutExamSlotsInput, ExamScheduleUncheckedCreateWithoutExamSlotsInput>
    where?: ExamScheduleWhereInput
  }

  export type ExamScheduleUpdateToOneWithWhereWithoutExamSlotsInput = {
    where?: ExamScheduleWhereInput
    data: XOR<ExamScheduleUpdateWithoutExamSlotsInput, ExamScheduleUncheckedUpdateWithoutExamSlotsInput>
  }

  export type ExamScheduleUpdateWithoutExamSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutExamSchedulesNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutExamSchedulesNestedInput
  }

  export type ExamScheduleUncheckedUpdateWithoutExamSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpsertWithoutExamSlotsInput = {
    update: XOR<RoomUpdateWithoutExamSlotsInput, RoomUncheckedUpdateWithoutExamSlotsInput>
    create: XOR<RoomCreateWithoutExamSlotsInput, RoomUncheckedCreateWithoutExamSlotsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutExamSlotsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutExamSlotsInput, RoomUncheckedUpdateWithoutExamSlotsInput>
  }

  export type RoomUpdateWithoutExamSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ClassScheduleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutExamSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    building?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    facilities?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ExamProctorUpsertWithWhereUniqueWithoutExamSlotInput = {
    where: ExamProctorWhereUniqueInput
    update: XOR<ExamProctorUpdateWithoutExamSlotInput, ExamProctorUncheckedUpdateWithoutExamSlotInput>
    create: XOR<ExamProctorCreateWithoutExamSlotInput, ExamProctorUncheckedCreateWithoutExamSlotInput>
  }

  export type ExamProctorUpdateWithWhereUniqueWithoutExamSlotInput = {
    where: ExamProctorWhereUniqueInput
    data: XOR<ExamProctorUpdateWithoutExamSlotInput, ExamProctorUncheckedUpdateWithoutExamSlotInput>
  }

  export type ExamProctorUpdateManyWithWhereWithoutExamSlotInput = {
    where: ExamProctorScalarWhereInput
    data: XOR<ExamProctorUpdateManyMutationInput, ExamProctorUncheckedUpdateManyWithoutExamSlotInput>
  }

  export type ExamSlotCreateWithoutProctorsInput = {
    id?: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examSchedule: ExamScheduleCreateNestedOneWithoutExamSlotsInput
    room: RoomCreateNestedOneWithoutExamSlotsInput
  }

  export type ExamSlotUncheckedCreateWithoutProctorsInput = {
    id?: string
    examScheduleId: string
    roomId: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamSlotCreateOrConnectWithoutProctorsInput = {
    where: ExamSlotWhereUniqueInput
    create: XOR<ExamSlotCreateWithoutProctorsInput, ExamSlotUncheckedCreateWithoutProctorsInput>
  }

  export type PersonnelCreateWithoutProctorDutiesInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutProctorDutiesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutProctorDutiesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutProctorDutiesInput, PersonnelUncheckedCreateWithoutProctorDutiesInput>
  }

  export type ExamSlotUpsertWithoutProctorsInput = {
    update: XOR<ExamSlotUpdateWithoutProctorsInput, ExamSlotUncheckedUpdateWithoutProctorsInput>
    create: XOR<ExamSlotCreateWithoutProctorsInput, ExamSlotUncheckedCreateWithoutProctorsInput>
    where?: ExamSlotWhereInput
  }

  export type ExamSlotUpdateToOneWithWhereWithoutProctorsInput = {
    where?: ExamSlotWhereInput
    data: XOR<ExamSlotUpdateWithoutProctorsInput, ExamSlotUncheckedUpdateWithoutProctorsInput>
  }

  export type ExamSlotUpdateWithoutProctorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSchedule?: ExamScheduleUpdateOneRequiredWithoutExamSlotsNestedInput
    room?: RoomUpdateOneRequiredWithoutExamSlotsNestedInput
  }

  export type ExamSlotUncheckedUpdateWithoutProctorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    examScheduleId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelUpsertWithoutProctorDutiesInput = {
    update: XOR<PersonnelUpdateWithoutProctorDutiesInput, PersonnelUncheckedUpdateWithoutProctorDutiesInput>
    create: XOR<PersonnelCreateWithoutProctorDutiesInput, PersonnelUncheckedCreateWithoutProctorDutiesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutProctorDutiesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutProctorDutiesInput, PersonnelUncheckedUpdateWithoutProctorDutiesInput>
  }

  export type PersonnelUpdateWithoutProctorDutiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutProctorDutiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelCreateWithoutTeachingLoadsInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelUncheckedCreateWithoutTeachingLoadsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
    reviewedLeaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type PersonnelCreateOrConnectWithoutTeachingLoadsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutTeachingLoadsInput, PersonnelUncheckedCreateWithoutTeachingLoadsInput>
  }

  export type AcademicTermCreateWithoutTeachingLoadsInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionCreateNestedManyWithoutTermInput
    invoices?: InvoiceCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleCreateNestedManyWithoutTermInput
  }

  export type AcademicTermUncheckedCreateWithoutTeachingLoadsInput = {
    id?: string
    year: number
    semester: number
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    sections?: ClassSectionUncheckedCreateNestedManyWithoutTermInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
    examSchedules?: ExamScheduleUncheckedCreateNestedManyWithoutTermInput
    schedules?: ClassScheduleUncheckedCreateNestedManyWithoutTermInput
  }

  export type AcademicTermCreateOrConnectWithoutTeachingLoadsInput = {
    where: AcademicTermWhereUniqueInput
    create: XOR<AcademicTermCreateWithoutTeachingLoadsInput, AcademicTermUncheckedCreateWithoutTeachingLoadsInput>
  }

  export type PersonnelUpsertWithoutTeachingLoadsInput = {
    update: XOR<PersonnelUpdateWithoutTeachingLoadsInput, PersonnelUncheckedUpdateWithoutTeachingLoadsInput>
    create: XOR<PersonnelCreateWithoutTeachingLoadsInput, PersonnelUncheckedCreateWithoutTeachingLoadsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutTeachingLoadsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutTeachingLoadsInput, PersonnelUncheckedUpdateWithoutTeachingLoadsInput>
  }

  export type PersonnelUpdateWithoutTeachingLoadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutTeachingLoadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type AcademicTermUpsertWithoutTeachingLoadsInput = {
    update: XOR<AcademicTermUpdateWithoutTeachingLoadsInput, AcademicTermUncheckedUpdateWithoutTeachingLoadsInput>
    create: XOR<AcademicTermCreateWithoutTeachingLoadsInput, AcademicTermUncheckedCreateWithoutTeachingLoadsInput>
    where?: AcademicTermWhereInput
  }

  export type AcademicTermUpdateToOneWithWhereWithoutTeachingLoadsInput = {
    where?: AcademicTermWhereInput
    data: XOR<AcademicTermUpdateWithoutTeachingLoadsInput, AcademicTermUncheckedUpdateWithoutTeachingLoadsInput>
  }

  export type AcademicTermUpdateWithoutTeachingLoadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUpdateManyWithoutTermNestedInput
  }

  export type AcademicTermUncheckedUpdateWithoutTeachingLoadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    sections?: ClassSectionUncheckedUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
    examSchedules?: ExamScheduleUncheckedUpdateManyWithoutTermNestedInput
    schedules?: ClassScheduleUncheckedUpdateManyWithoutTermNestedInput
  }

  export type StudentCreateWithoutLeaveRequestsInput = {
    id?: string
    studentId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    studentGroup?: StudentGroupCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutLeaveRequestsInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutLeaveRequestsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutLeaveRequestsInput, StudentUncheckedCreateWithoutLeaveRequestsInput>
  }

  export type PersonnelCreateWithoutReviewedLeaveRequestsInput = {
    id?: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonnelProfileInput
    faculty?: FacultyCreateNestedOneWithoutPersonnelInput
    department?: DepartmentCreateNestedOneWithoutPersonnelInput
    instructedSections?: ClassSectionCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupCreateNestedManyWithoutAdvisorInput
  }

  export type PersonnelUncheckedCreateWithoutReviewedLeaveRequestsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructedSections?: ClassSectionUncheckedCreateNestedManyWithoutInstructorInput
    interviewSlots?: InterviewSlotInterviewerUncheckedCreateNestedManyWithoutInterviewerInput
    teachingSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutInstructorInput
    teachingLoads?: TeachingLoadUncheckedCreateNestedManyWithoutInstructorInput
    proctorDuties?: ExamProctorUncheckedCreateNestedManyWithoutProctorInput
    advisorGroups?: StudentGroupUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type PersonnelCreateOrConnectWithoutReviewedLeaveRequestsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutReviewedLeaveRequestsInput, PersonnelUncheckedCreateWithoutReviewedLeaveRequestsInput>
  }

  export type StudentUpsertWithoutLeaveRequestsInput = {
    update: XOR<StudentUpdateWithoutLeaveRequestsInput, StudentUncheckedUpdateWithoutLeaveRequestsInput>
    create: XOR<StudentCreateWithoutLeaveRequestsInput, StudentUncheckedCreateWithoutLeaveRequestsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutLeaveRequestsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutLeaveRequestsInput, StudentUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type StudentUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    studentGroup?: StudentGroupUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PersonnelUpsertWithoutReviewedLeaveRequestsInput = {
    update: XOR<PersonnelUpdateWithoutReviewedLeaveRequestsInput, PersonnelUncheckedUpdateWithoutReviewedLeaveRequestsInput>
    create: XOR<PersonnelCreateWithoutReviewedLeaveRequestsInput, PersonnelUncheckedCreateWithoutReviewedLeaveRequestsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutReviewedLeaveRequestsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutReviewedLeaveRequestsInput, PersonnelUncheckedUpdateWithoutReviewedLeaveRequestsInput>
  }

  export type PersonnelUpdateWithoutReviewedLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutReviewedLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type SystemLogCreateManyUserInput = {
    id?: string
    action: string
    details?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AnnouncementCreateManyAuthorInput = {
    id?: string
    title: string
    imageUrl?: string | null
    content: string
    target?: $Enums.AnnouncementTarget
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    target?: EnumAnnouncementTargetFieldUpdateOperationsInput | $Enums.AnnouncementTarget
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    target?: EnumAnnouncementTargetFieldUpdateOperationsInput | $Enums.AnnouncementTarget
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    target?: EnumAnnouncementTargetFieldUpdateOperationsInput | $Enums.AnnouncementTarget
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HelpCategoryUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type HelpArticleUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSectionCreateManyInstructorInput = {
    id?: string
    courseId: string
    termId: string
    sectionNumber: string
    capacity: number
  }

  export type InterviewSlotInterviewerCreateManyInterviewerInput = {
    id?: string
    slotId: string
  }

  export type ClassScheduleCreateManyInstructorInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    termId?: string | null
  }

  export type TeachingLoadCreateManyInstructorInput = {
    id?: string
    termId: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamProctorCreateManyProctorInput = {
    id?: string
    examSlotId: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGroupCreateManyAdvisorInput = {
    id?: string
    name: string
    admissionYear: number
    programId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateManyReviewerInput = {
    id?: string
    studentId: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSectionUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutSectionsNestedInput
    schedules?: ClassScheduleUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    schedules?: ClassScheduleUncheckedUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type InterviewSlotInterviewerUpdateWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: InterviewSlotUpdateOneRequiredWithoutInterviewersNestedInput
  }

  export type InterviewSlotInterviewerUncheckedUpdateWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    section?: ClassSectionUpdateOneRequiredWithoutSchedulesNestedInput
    room?: RoomUpdateOneWithoutSchedulesNestedInput
    course?: CourseUpdateOneWithoutSchedulesNestedInput
    term?: AcademicTermUpdateOneWithoutSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassScheduleUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingLoadUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: AcademicTermUpdateOneRequiredWithoutTeachingLoadsNestedInput
  }

  export type TeachingLoadUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingLoadUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamProctorUpdateWithoutProctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSlot?: ExamSlotUpdateOneRequiredWithoutProctorsNestedInput
  }

  export type ExamProctorUncheckedUpdateWithoutProctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    examSlotId?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamProctorUncheckedUpdateManyWithoutProctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    examSlotId?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGroupUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutStudentGroupsNestedInput
    students?: StudentUpdateManyWithoutStudentGroupNestedInput
    sections?: ClassSectionUpdateManyWithoutStudentGroupsNestedInput
  }

  export type StudentGroupUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutStudentGroupNestedInput
    sections?: ClassSectionUncheckedUpdateManyWithoutStudentGroupsNestedInput
  }

  export type StudentGroupUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLeaveRequestsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyFacultyInput = {
    id?: string
    nameTh: string
    nameEn: string
    description?: string | null
  }

  export type ProgramCreateManyFacultyInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    departmentId: string
  }

  export type PersonnelCreateManyFacultyInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    departmentId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programs?: ProgramUpdateManyWithoutDepartmentNestedInput
    personnel?: PersonnelUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programs?: ProgramUncheckedUpdateManyWithoutDepartmentNestedInput
    personnel?: PersonnelUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonnelUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    department?: DepartmentUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateManyDepartmentInput = {
    id?: string
    nameTh: string
    nameEn: string
    degreeLevel: $Enums.DegreeLevel
    description?: string | null
    isAcceptingApplications?: boolean
    credits?: number | null
    duration?: string | null
    objectives?: string | null
    structure?: string | null
    admissionRequirements?: string | null
    careerOpportunities?: string | null
    facultyId: string
  }

  export type PersonnelCreateManyDepartmentInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    title?: string | null
    position?: string | null
    phone?: string | null
    profileImageUrl?: string | null
    facultyId?: string | null
    bio?: string | null
    expertise?: string | null
    education?: string | null
    publications?: string | null
    officeHours?: string | null
    officeLocation?: string | null
    isProfilePublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: FacultyUpdateOneRequiredWithoutProgramsNestedInput
    applications?: ApplicationUpdateManyWithoutProgramNestedInput
    students?: StudentUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
    applications?: ApplicationUncheckedUpdateManyWithoutProgramNestedInput
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
    interviewSlots?: InterviewSlotUncheckedUpdateManyWithoutProgramNestedInput
    courses?: ProgramCourseUncheckedUpdateManyWithoutProgramNestedInput
    admissionTracks?: AdmissionTrackUncheckedUpdateManyWithoutProgramNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    degreeLevel?: EnumDegreeLevelFieldUpdateOperationsInput | $Enums.DegreeLevel
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAcceptingApplications?: BoolFieldUpdateOperationsInput | boolean
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: NullableStringFieldUpdateOperationsInput | string | null
    admissionRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    careerOpportunities?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonnelUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonnelProfileNestedInput
    faculty?: FacultyUpdateOneWithoutPersonnelNestedInput
    instructedSections?: ClassSectionUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructedSections?: ClassSectionUncheckedUpdateManyWithoutInstructorNestedInput
    interviewSlots?: InterviewSlotInterviewerUncheckedUpdateManyWithoutInterviewerNestedInput
    teachingSchedules?: ClassScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    teachingLoads?: TeachingLoadUncheckedUpdateManyWithoutInstructorNestedInput
    proctorDuties?: ExamProctorUncheckedUpdateManyWithoutProctorNestedInput
    advisorGroups?: StudentGroupUncheckedUpdateManyWithoutAdvisorNestedInput
    reviewedLeaveRequests?: LeaveRequestUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type PersonnelUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: NullableStringFieldUpdateOperationsInput | string | null
    officeHours?: NullableStringFieldUpdateOperationsInput | string | null
    officeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyProgramInput = {
    id?: string
    applicantId: string
    trackId?: string | null
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyProgramInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    studentGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSlotCreateManyProgramInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coordinatorName?: string | null
    coordinatorPhone?: string | null
    description?: string | null
  }

  export type ProgramCourseCreateManyProgramInput = {
    id?: string
    courseId: string
    isRequired?: boolean
    semester?: number | null
  }

  export type AdmissionTrackCreateManyProgramInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    typeId: string
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGroupCreateManyProgramInput = {
    id?: string
    name: string
    admissionYear: number
    advisorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutApplicationsNestedInput
    track?: AdmissionTrackUpdateOneWithoutApplicationsNestedInput
    documents?: DocumentUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    studentGroup?: StudentGroupUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    studentGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSlotUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    interviewResults?: InterviewResultUpdateManyWithoutSlotNestedInput
    interviewers?: InterviewSlotInterviewerUpdateManyWithoutSlotNestedInput
  }

  export type InterviewSlotUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    interviewResults?: InterviewResultUncheckedUpdateManyWithoutSlotNestedInput
    interviewers?: InterviewSlotInterviewerUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type InterviewSlotUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorName?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramCourseUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneRequiredWithoutProgramsNestedInput
  }

  export type ProgramCourseUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramCourseUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdmissionTrackUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: AdmissionTrackTypeUpdateOneRequiredWithoutTracksNestedInput
    applications?: ApplicationUpdateManyWithoutTrackNestedInput
  }

  export type AdmissionTrackUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutTrackNestedInput
  }

  export type AdmissionTrackUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGroupUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: PersonnelUpdateOneWithoutAdvisorGroupsNestedInput
    students?: StudentUpdateManyWithoutStudentGroupNestedInput
    sections?: ClassSectionUpdateManyWithoutStudentGroupsNestedInput
  }

  export type StudentGroupUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutStudentGroupNestedInput
    sections?: ClassSectionUncheckedUpdateManyWithoutStudentGroupsNestedInput
  }

  export type StudentGroupUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSectionCreateManyCourseInput = {
    id?: string
    termId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
  }

  export type ProgramCourseCreateManyCourseInput = {
    id?: string
    programId: string
    isRequired?: boolean
    semester?: number | null
  }

  export type ClassScheduleCreateManyCourseInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type ExamScheduleCreateManyCourseInput = {
    id?: string
    section: string
    termId: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSectionUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    term?: AcademicTermUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonnelUpdateOneWithoutInstructedSectionsNestedInput
    schedules?: ClassScheduleUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    schedules?: ClassScheduleUncheckedUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type ProgramCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassScheduleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    section?: ClassSectionUpdateOneRequiredWithoutSchedulesNestedInput
    room?: RoomUpdateOneWithoutSchedulesNestedInput
    instructor?: PersonnelUpdateOneWithoutTeachingSchedulesNestedInput
    term?: AcademicTermUpdateOneWithoutSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassScheduleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamScheduleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: AcademicTermUpdateOneRequiredWithoutExamSchedulesNestedInput
    examSlots?: ExamSlotUpdateManyWithoutExamScheduleNestedInput
  }

  export type ExamScheduleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSlots?: ExamSlotUncheckedUpdateManyWithoutExamScheduleNestedInput
  }

  export type ExamScheduleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSectionCreateManyTermInput = {
    id?: string
    courseId: string
    sectionNumber: string
    capacity: number
    instructorId?: string | null
  }

  export type InvoiceCreateManyTermInput = {
    id?: string
    studentId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
  }

  export type ExamScheduleCreateManyTermInput = {
    id?: string
    courseId: string
    section: string
    examType: $Enums.ExamType
    examDate: Date | string
    startTime: string
    endTime: string
    duration: number
    examFormat?: $Enums.ExamFormat
    instructions?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingLoadCreateManyTermInput = {
    id?: string
    instructorId: string
    lectureHours?: number
    labHours?: number
    totalHours?: number
    courseCount?: number
    isApproved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassScheduleCreateManyTermInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    instructorId?: string | null
  }

  export type ClassSectionUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonnelUpdateOneWithoutInstructedSectionsNestedInput
    schedules?: ClassScheduleUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    schedules?: ClassScheduleUncheckedUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutSectionNestedInput
    studentGroups?: StudentGroupUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScheduleUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutExamSchedulesNestedInput
    examSlots?: ExamSlotUpdateManyWithoutExamScheduleNestedInput
  }

  export type ExamScheduleUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSlots?: ExamSlotUncheckedUpdateManyWithoutExamScheduleNestedInput
  }

  export type ExamScheduleUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    examFormat?: EnumExamFormatFieldUpdateOperationsInput | $Enums.ExamFormat
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingLoadUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: PersonnelUpdateOneRequiredWithoutTeachingLoadsNestedInput
  }

  export type TeachingLoadUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingLoadUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    lectureHours?: FloatFieldUpdateOperationsInput | number
    labHours?: FloatFieldUpdateOperationsInput | number
    totalHours?: FloatFieldUpdateOperationsInput | number
    courseCount?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassScheduleUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    section?: ClassSectionUpdateOneRequiredWithoutSchedulesNestedInput
    room?: RoomUpdateOneWithoutSchedulesNestedInput
    course?: CourseUpdateOneWithoutSchedulesNestedInput
    instructor?: PersonnelUpdateOneWithoutTeachingSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassScheduleUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationHistoryCreateManyApplicantInput = {
    id?: string
    level: string
    degreeName: string
    institution: string
    gpa?: string | null
    graduationYear?: number | null
  }

  export type ApplicationCreateManyApplicantInput = {
    id?: string
    trackId?: string | null
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationHistoryUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EducationHistoryUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EducationHistoryUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApplicationUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    track?: AdmissionTrackUpdateOneWithoutApplicationsNestedInput
    program?: ProgramUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: DocumentUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionTrackCreateManyTypeInput = {
    id?: string
    code: string
    nameTh: string
    nameEn: string
    description?: string | null
    programId: string
    academicYear: string
    openDate: Date | string
    closeDate: Date | string
    announceDate?: Date | string | null
    totalSeats: number
    filledSeats?: number
    reservedSeats?: number | null
    enableWaitlist?: boolean
    requirements?: string | null
    applicationFee?: number | null
    isActive?: boolean
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionTrackUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutAdmissionTracksNestedInput
    applications?: ApplicationUpdateManyWithoutTrackNestedInput
  }

  export type AdmissionTrackUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutTrackNestedInput
  }

  export type AdmissionTrackUncheckedUpdateManyWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    announceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    filledSeats?: IntFieldUpdateOperationsInput | number
    reservedSeats?: NullableIntFieldUpdateOperationsInput | number | null
    enableWaitlist?: BoolFieldUpdateOperationsInput | boolean
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyTrackInput = {
    id?: string
    applicantId: string
    programId: string
    status?: $Enums.ApplicationStatus
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutApplicationsNestedInput
    program?: ProgramUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: DocumentUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutApplicationNestedInput
    interview?: InterviewResultUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyApplicationInput = {
    id?: string
    type: string
    url: string
    uploadedAt?: Date | string
  }

  export type DocumentUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewResultCreateManySlotInput = {
    id?: string
    applicationId: string
    score?: number | null
    comments?: string | null
    isPassed?: boolean | null
    confirmedAt?: Date | string | null
    rescheduleRequested?: boolean
    rescheduleReason?: string | null
    checkedInAt?: Date | string | null
  }

  export type InterviewSlotInterviewerCreateManySlotInput = {
    id?: string
    interviewerId: string
  }

  export type InterviewResultUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    application?: ApplicationUpdateOneRequiredWithoutInterviewNestedInput
    feedback?: InterviewFeedbackUpdateOneWithoutInterviewResultNestedInput
  }

  export type InterviewResultUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: InterviewFeedbackUncheckedUpdateOneWithoutInterviewResultNestedInput
  }

  export type InterviewResultUncheckedUpdateManyWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rescheduleRequested?: BoolFieldUpdateOperationsInput | boolean
    rescheduleReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InterviewSlotInterviewerUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewer?: PersonnelUpdateOneRequiredWithoutInterviewSlotsNestedInput
  }

  export type InterviewSlotInterviewerUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewerId?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewSlotInterviewerUncheckedUpdateManyWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewerId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateManyStudentGroupInput = {
    id?: string
    studentId: string
    userId: string
    title?: string | null
    firstName: string
    lastName: string
    firstNameTh?: string | null
    lastNameTh?: string | null
    nationality?: string | null
    citizenId?: string | null
    birthDate: Date | string
    gender?: $Enums.Gender | null
    phone?: string | null
    profileImageUrl?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    zipCode?: string | null
    programId: string
    studentType?: $Enums.StudentType
    status?: $Enums.StudentStatus
    gpax?: number
    bio?: string | null
    interests?: string | null
    skills?: string | null
    socialLinks?: string | null
    isProfilePublic?: boolean
    showGPA?: boolean
    admissionYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutStudentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    gpax?: FloatFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    showGPA?: BoolFieldUpdateOperationsInput | boolean
    admissionYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSectionUpdateWithoutStudentGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    term?: AcademicTermUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonnelUpdateOneWithoutInstructedSectionsNestedInput
    schedules?: ClassScheduleUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUpdateManyWithoutSectionNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutStudentGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    schedules?: ClassScheduleUncheckedUpdateManyWithoutSectionNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type ClassSectionUncheckedUpdateManyWithoutStudentGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    sectionNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentCreateManyStudentInput = {
    id?: string
    sectionId: string
    grade?: string | null
    enrolledAt?: Date | string
  }

  export type InvoiceCreateManyStudentInput = {
    id?: string
    termId: string
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
  }

  export type LeaveRequestCreateManyStudentInput = {
    id?: string
    reason: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveRequestStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNote?: string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: ClassSectionUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: AcademicTermUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: PersonnelUpdateOneWithoutReviewedLeaveRequestsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveRequestStatusFieldUpdateOperationsInput | $Enums.LeaveRequestStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassScheduleCreateManySectionInput = {
    id?: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    roomId?: string | null
    courseId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type EnrollmentCreateManySectionInput = {
    id?: string
    studentId: string
    grade?: string | null
    enrolledAt?: Date | string
  }

  export type ClassScheduleUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneWithoutSchedulesNestedInput
    course?: CourseUpdateOneWithoutSchedulesNestedInput
    instructor?: PersonnelUpdateOneWithoutTeachingSchedulesNestedInput
    term?: AcademicTermUpdateOneWithoutSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassScheduleUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGroupUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutStudentGroupsNestedInput
    advisor?: PersonnelUpdateOneWithoutAdvisorGroupsNestedInput
    students?: StudentUpdateManyWithoutStudentGroupNestedInput
  }

  export type StudentGroupUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutStudentGroupNestedInput
  }

  export type StudentGroupUncheckedUpdateManyWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    admissionYear?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    slipUrl?: string | null
    paidAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiMessageCreateManyConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AiMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleCreateManyCategoryInput = {
    id?: string
    title: string
    content: string
    visibility?: $Enums.HelpArticleVisibility
    isPublished?: boolean
    authorId: string
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutHelpArticlesNestedInput
  }

  export type HelpArticleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibility?: EnumHelpArticleVisibilityFieldUpdateOperationsInput | $Enums.HelpArticleVisibility
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassScheduleCreateManyRoomInput = {
    id?: string
    sectionId: string
    day: $Enums.DayOfWeek
    startTime: string
    endTime: string
    courseId?: string | null
    instructorId?: string | null
    termId?: string | null
  }

  export type ExamSlotCreateManyRoomInput = {
    id?: string
    examScheduleId: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassScheduleUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    section?: ClassSectionUpdateOneRequiredWithoutSchedulesNestedInput
    course?: CourseUpdateOneWithoutSchedulesNestedInput
    instructor?: PersonnelUpdateOneWithoutTeachingSchedulesNestedInput
    term?: AcademicTermUpdateOneWithoutSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassScheduleUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    termId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamSlotUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSchedule?: ExamScheduleUpdateOneRequiredWithoutExamSlotsNestedInput
    proctors?: ExamProctorUpdateManyWithoutExamSlotNestedInput
  }

  export type ExamSlotUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    examScheduleId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proctors?: ExamProctorUncheckedUpdateManyWithoutExamSlotNestedInput
  }

  export type ExamSlotUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    examScheduleId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSlotCreateManyExamScheduleInput = {
    id?: string
    roomId: string
    capacity: number
    assignedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamSlotUpdateWithoutExamScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutExamSlotsNestedInput
    proctors?: ExamProctorUpdateManyWithoutExamSlotNestedInput
  }

  export type ExamSlotUncheckedUpdateWithoutExamScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proctors?: ExamProctorUncheckedUpdateManyWithoutExamSlotNestedInput
  }

  export type ExamSlotUncheckedUpdateManyWithoutExamScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    assignedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamProctorCreateManyExamSlotInput = {
    id?: string
    proctorId: string
    role?: $Enums.ProctorRole
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamProctorUpdateWithoutExamSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proctor?: PersonnelUpdateOneRequiredWithoutProctorDutiesNestedInput
  }

  export type ExamProctorUncheckedUpdateWithoutExamSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    proctorId?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamProctorUncheckedUpdateManyWithoutExamSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    proctorId?: StringFieldUpdateOperationsInput | string
    role?: EnumProctorRoleFieldUpdateOperationsInput | $Enums.ProctorRole
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnelCountOutputTypeDefaultArgs instead
     */
    export type PersonnelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacultyCountOutputTypeDefaultArgs instead
     */
    export type FacultyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacultyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramCountOutputTypeDefaultArgs instead
     */
    export type ProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicTermCountOutputTypeDefaultArgs instead
     */
    export type AcademicTermCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicTermCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicantCountOutputTypeDefaultArgs instead
     */
    export type ApplicantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionTrackTypeCountOutputTypeDefaultArgs instead
     */
    export type AdmissionTrackTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionTrackTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionTrackCountOutputTypeDefaultArgs instead
     */
    export type AdmissionTrackCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionTrackCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationCountOutputTypeDefaultArgs instead
     */
    export type ApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewSlotCountOutputTypeDefaultArgs instead
     */
    export type InterviewSlotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewSlotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentGroupCountOutputTypeDefaultArgs instead
     */
    export type StudentGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassSectionCountOutputTypeDefaultArgs instead
     */
    export type ClassSectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassSectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiConversationCountOutputTypeDefaultArgs instead
     */
    export type AiConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCategoryCountOutputTypeDefaultArgs instead
     */
    export type HelpCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamScheduleCountOutputTypeDefaultArgs instead
     */
    export type ExamScheduleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamScheduleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamSlotCountOutputTypeDefaultArgs instead
     */
    export type ExamSlotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamSlotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnelDefaultArgs instead
     */
    export type PersonnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacultyDefaultArgs instead
     */
    export type FacultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacultyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramDefaultArgs instead
     */
    export type ProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramCourseDefaultArgs instead
     */
    export type ProgramCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicTermDefaultArgs instead
     */
    export type AcademicTermArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicTermDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicantDefaultArgs instead
     */
    export type ApplicantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EducationHistoryDefaultArgs instead
     */
    export type EducationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EducationHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionTrackTypeDefaultArgs instead
     */
    export type AdmissionTrackTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionTrackTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionTrackDefaultArgs instead
     */
    export type AdmissionTrackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionTrackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationDefaultArgs instead
     */
    export type ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewSlotDefaultArgs instead
     */
    export type InterviewSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewSlotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewSlotInterviewerDefaultArgs instead
     */
    export type InterviewSlotInterviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewSlotInterviewerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewResultDefaultArgs instead
     */
    export type InterviewResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewFeedbackDefaultArgs instead
     */
    export type InterviewFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentGroupDefaultArgs instead
     */
    export type StudentGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassSectionDefaultArgs instead
     */
    export type ClassSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassScheduleDefaultArgs instead
     */
    export type ClassScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnrollmentDefaultArgs instead
     */
    export type EnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnrollmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnouncementDefaultArgs instead
     */
    export type AnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnouncementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BannerDefaultArgs instead
     */
    export type BannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiSettingsDefaultArgs instead
     */
    export type AiSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiKnowledgeBaseDefaultArgs instead
     */
    export type AiKnowledgeBaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiKnowledgeBaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiConversationDefaultArgs instead
     */
    export type AiConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiMessageDefaultArgs instead
     */
    export type AiMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCategoryDefaultArgs instead
     */
    export type HelpCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpArticleDefaultArgs instead
     */
    export type HelpArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingsDefaultArgs instead
     */
    export type SystemSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemLogDefaultArgs instead
     */
    export type SystemLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationDefaultArgs instead
     */
    export type TranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamScheduleDefaultArgs instead
     */
    export type ExamScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamSlotDefaultArgs instead
     */
    export type ExamSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamSlotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamProctorDefaultArgs instead
     */
    export type ExamProctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamProctorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeachingLoadDefaultArgs instead
     */
    export type TeachingLoadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeachingLoadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveRequestDefaultArgs instead
     */
    export type LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveRequestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}