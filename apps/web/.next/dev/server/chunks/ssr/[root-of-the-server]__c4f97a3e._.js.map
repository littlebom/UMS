{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/packages/lib/calendar/ics-generator.ts"],"sourcesContent":["export function generateICS(\n    title: string,\n    description: string,\n    location: string,\n    startTime: Date,\n    endTime: Date,\n    url?: string\n): string {\n    const formatDate = (date: Date): string => {\n        return date.toISOString().replace(/[-:]/g, \"\").split(\".\")[0] + \"Z\";\n    };\n\n    const now = formatDate(new Date());\n    const start = formatDate(startTime);\n    const end = formatDate(endTime);\n\n    const content = [\n        \"BEGIN:VCALENDAR\",\n        \"VERSION:2.0\",\n        \"PRODID:-//University Management System//Admissions//EN\",\n        \"CALSCALE:GREGORIAN\",\n        \"METHOD:PUBLISH\",\n        \"BEGIN:VEVENT\",\n        `DTSTAMP:${now}`,\n        `DTSTART:${start}`,\n        `DTEND:${end}`,\n        `SUMMARY:${title}`,\n        `DESCRIPTION:${description.replace(/\\n/g, \"\\\\n\")}`,\n        `LOCATION:${location}`,\n        url ? `URL:${url}` : \"\",\n        \"STATUS:CONFIRMED\",\n        \"END:VEVENT\",\n        \"END:VCALENDAR\",\n    ];\n\n    return content.filter(Boolean).join(\"\\r\\n\");\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,YACZ,KAAa,EACb,WAAmB,EACnB,QAAgB,EAChB,SAAe,EACf,OAAa,EACb,GAAY;IAEZ,MAAM,aAAa,CAAC;QAChB,OAAO,KAAK,WAAW,GAAG,OAAO,CAAC,SAAS,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG;IACnE;IAEA,MAAM,MAAM,WAAW,IAAI;IAC3B,MAAM,QAAQ,WAAW;IACzB,MAAM,MAAM,WAAW;IAEvB,MAAM,UAAU;QACZ;QACA;QACA;QACA;QACA;QACA;QACA,CAAC,QAAQ,EAAE,KAAK;QAChB,CAAC,QAAQ,EAAE,OAAO;QAClB,CAAC,MAAM,EAAE,KAAK;QACd,CAAC,QAAQ,EAAE,OAAO;QAClB,CAAC,YAAY,EAAE,YAAY,OAAO,CAAC,OAAO,QAAQ;QAClD,CAAC,SAAS,EAAE,UAAU;QACtB,MAAM,CAAC,IAAI,EAAE,KAAK,GAAG;QACrB;QACA;QACA;KACH;IAED,OAAO,QAAQ,MAAM,CAAC,SAAS,IAAI,CAAC;AACxC"}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/packages/lib/email/templates.ts"],"sourcesContent":["export const getInterviewInvitationTemplate = (\n    applicantName: string,\n    programName: string,\n    date: string,\n    time: string,\n    location: string,\n    link: string\n) => `\n<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }\n        .header { background-color: #033675; color: white; padding: 15px; text-align: center; border-radius: 5px 5px 0 0; }\n        .content { padding: 20px; }\n        .details { background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0; }\n        .button { display: inline-block; background-color: #03ccba; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; margin-top: 20px; }\n        .footer { text-align: center; font-size: 12px; color: #777; margin-top: 20px; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h2>Interview Invitation</h2>\n        </div>\n        <div class=\"content\">\n            <p>Dear ${applicantName},</p>\n            <p>We are pleased to invite you to an interview for the <strong>${programName}</strong> program at our university.</p>\n            \n            <div class=\"details\">\n                <p><strong>Date:</strong> ${date}</p>\n                <p><strong>Time:</strong> ${time}</p>\n                <p><strong>Location:</strong> ${location}</p>\n            </div>\n\n            <p>Please review the details and confirm your attendance by clicking the button below:</p>\n            \n            <center>\n                <a href=\"${link}\" class=\"button\">View Details & Confirm</a>\n            </center>\n\n            <p>If you have any questions or need to reschedule, please contact us immediately.</p>\n        </div>\n        <div class=\"footer\">\n            <p>This is an automated message. Please do not reply directly to this email.</p>\n            <p>&copy; ${new Date().getFullYear()} University Management System</p>\n        </div>\n    </div>\n</body>\n</html>\n`;\n\nexport const getInterviewReminderTemplate = (\n    applicantName: string,\n    programName: string,\n    date: string,\n    time: string,\n    location: string,\n    link: string,\n    daysLeft: number\n) => `\n<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }\n        .header { background-color: #f59e0b; color: white; padding: 15px; text-align: center; border-radius: 5px 5px 0 0; }\n        .content { padding: 20px; }\n        .details { background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0; }\n        .button { display: inline-block; background-color: #033675; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; margin-top: 20px; }\n        .footer { text-align: center; font-size: 12px; color: #777; margin-top: 20px; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h2>Interview Reminder</h2>\n        </div>\n        <div class=\"content\">\n            <p>Dear ${applicantName},</p>\n            <p>This is a reminder that your interview for <strong>${programName}</strong> is coming up in <strong>${daysLeft} day(s)</strong>.</p>\n            \n            <div class=\"details\">\n                <p><strong>Date:</strong> ${date}</p>\n                <p><strong>Time:</strong> ${time}</p>\n                <p><strong>Location:</strong> ${location}</p>\n            </div>\n\n            <p>Please ensure you are prepared and arrive on time. You can view the full details here:</p>\n            \n            <center>\n                <a href=\"${link}\" class=\"button\">View Interview Details</a>\n            </center>\n        </div>\n        <div class=\"footer\">\n            <p>&copy; ${new Date().getFullYear()} University Management System</p>\n        </div>\n    </div>\n</body>\n</html>\n`;\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,iCAAiC,CAC1C,eACA,aACA,MACA,MACA,UACA,OACC,CAAC;;;;;;;;;;;;;;;;;;;;oBAoBc,EAAE,cAAc;4EACwC,EAAE,YAAY;;;0CAGhD,EAAE,KAAK;0CACP,EAAE,KAAK;8CACH,EAAE,SAAS;;;;;;yBAMhC,EAAE,KAAK;;;;;;;sBAOV,EAAE,IAAI,OAAO,WAAW,GAAG;;;;;AAKjD,CAAC;AAEM,MAAM,+BAA+B,CACxC,eACA,aACA,MACA,MACA,UACA,MACA,WACC,CAAC;;;;;;;;;;;;;;;;;;;;oBAoBc,EAAE,cAAc;kEAC8B,EAAE,YAAY,kCAAkC,EAAE,SAAS;;;0CAGnF,EAAE,KAAK;0CACP,EAAE,KAAK;8CACH,EAAE,SAAS;;;;;;yBAMhC,EAAE,KAAK;;;;sBAIV,EAAE,IAAI,OAAO,WAAW,GAAG;;;;;AAKjD,CAAC"}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/packages/lib/email/index.ts"],"sourcesContent":["import nodemailer from \"nodemailer\";\nimport { prisma } from \"..\"; // Import prisma from lib root\nimport { getInterviewInvitationTemplate, getInterviewReminderTemplate } from \"./templates\";\n\n// Helper to get transporter based on DB settings or Env vars\nasync function getTransporter() {\n    // Try to get settings from DB\n    const settings = await prisma.systemSettings.findFirst();\n\n    if (settings && settings.smtpHost) {\n        return nodemailer.createTransport({\n            host: settings.smtpHost,\n            port: settings.smtpPort,\n            secure: settings.smtpSecure,\n            auth: {\n                user: settings.smtpUser || \"\",\n                pass: settings.smtpPassword || \"\",\n            },\n        });\n    }\n\n    // Fallback to Env vars\n    return nodemailer.createTransport({\n        host: process.env.SMTP_HOST || \"smtp.ethereal.email\",\n        port: parseInt(process.env.SMTP_PORT || \"587\"),\n        secure: process.env.SMTP_SECURE === \"true\",\n        auth: {\n            user: process.env.SMTP_USER || \"ethereal_user\",\n            pass: process.env.SMTP_PASS || \"ethereal_pass\",\n        },\n    });\n}\n\ninterface SendEmailOptions {\n    to: string;\n    subject: string;\n    html: string;\n}\n\nexport async function sendEmail({ to, subject, html }: SendEmailOptions) {\n    try {\n        const settings = await prisma.systemSettings.findFirst();\n\n        // In development, if no real SMTP is configured (neither in DB nor Env), we log\n        if (process.env.NODE_ENV !== \"production\" && !process.env.SMTP_HOST && (!settings || !settings.smtpHost)) {\n            console.log(\"üìß [MOCK EMAIL] -----------------------------------\");\n            console.log(`To: ${to}`);\n            console.log(`Subject: ${subject}`);\n            console.log(\"---------------------------------------------------\");\n            return { success: true, messageId: \"mock-id\" };\n        }\n\n        const transporter = await getTransporter();\n\n        const fromName = settings?.smtpFromName || \"UMS Admissions\";\n        const fromEmail = settings?.smtpFromEmail || \"noreply@ums.ac.th\";\n\n        const info = await transporter.sendMail({\n            from: `\"${fromName}\" <${fromEmail}>`,\n            to,\n            subject,\n            html,\n        });\n\n        console.log(\"Message sent: %s\", info.messageId);\n        return { success: true, messageId: info.messageId };\n    } catch (error) {\n        console.error(\"Error sending email:\", error);\n        return { success: false, error };\n    }\n}\n\nexport async function sendInterviewInvitation(\n    email: string,\n    applicantName: string,\n    programName: string,\n    date: Date,\n    startTime: Date,\n    endTime: Date,\n    location: string | null,\n    applicationId: string\n) {\n    const dateStr = date.toLocaleDateString(\"en-US\", {\n        weekday: \"long\",\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\",\n    });\n\n    const timeStr = `${startTime.toLocaleTimeString(\"en-US\", { hour: \"2-digit\", minute: \"2-digit\" })} - ${endTime.toLocaleTimeString(\"en-US\", { hour: \"2-digit\", minute: \"2-digit\" })}`;\n\n    const link = `${process.env.NEXT_PUBLIC_BASE_URL || \"http://localhost:3000\"}/admissions/application/${applicationId}`;\n    const locationStr = location || \"Online / To be announced\";\n\n    const html = getInterviewInvitationTemplate(\n        applicantName,\n        programName,\n        dateStr,\n        timeStr,\n        locationStr,\n        link\n    );\n\n    return sendEmail({\n        to: email,\n        subject: `Interview Invitation: ${programName}`,\n        html,\n    });\n}\n\nexport async function sendInterviewReminder(\n    email: string,\n    applicantName: string,\n    programName: string,\n    date: Date,\n    startTime: Date,\n    endTime: Date,\n    location: string | null,\n    applicationId: string,\n    daysLeft: number\n) {\n    const dateStr = date.toLocaleDateString(\"en-US\", {\n        weekday: \"long\",\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\",\n    });\n\n    const timeStr = `${startTime.toLocaleTimeString(\"en-US\", { hour: \"2-digit\", minute: \"2-digit\" })} - ${endTime.toLocaleTimeString(\"en-US\", { hour: \"2-digit\", minute: \"2-digit\" })}`;\n\n    const link = `${process.env.NEXT_PUBLIC_BASE_URL || \"http://localhost:3000\"}/admissions/application/${applicationId}`;\n    const locationStr = location || \"Online / To be announced\";\n\n    const html = getInterviewReminderTemplate(\n        applicantName,\n        programName,\n        dateStr,\n        timeStr,\n        locationStr,\n        link,\n        daysLeft\n    );\n\n    return sendEmail({\n        to: email,\n        subject: `Reminder: Interview in ${daysLeft} day(s) - ${programName}`,\n        html,\n    });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/packages/lib/index.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = global as unknown as { prisma_new: PrismaClient };\n\nexport const prisma =\n    globalForPrisma.prisma_new ||\n    new PrismaClient({\n        log: [\"query\"],\n    });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma_new = prisma;\n\nexport * from \"@prisma/client\";\nexport * from \"./calendar/ics-generator\";\nexport * from \"./email\";\n"],"names":[],"mappings":";;;;AAAA;AAaA;AACA;;AAZA,MAAM;AAEC,MAAM,SACT,gBAAgB,UAAU,IAC1B,IAAI,gLAAY,CAAC;IACb,KAAK;QAAC;KAAQ;AAClB;AAEJ,wCAA2C,gBAAgB,UAAU,GAAG"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/lib/dictionary.ts"],"sourcesContent":["export type Locale = \"en\" | \"th\";\n\nexport const dictionary = {\n    en: {\n        common: {\n            searchPlaceholder: \"Search...\",\n            signOut: \"Sign Out\",\n            adminLogin: \"Admin Login\",\n            studentPortal: \"Student Portal\",\n            help: \"Help\",\n            admissions: \"Admissions\",\n            language: \"Language\",\n        },\n        menu: {\n            home: \"Home\",\n            curriculum: \"Curriculum\",\n            students: \"Students\",\n            dashboard: \"Dashboard\",\n            overview: \"Overview\",\n            coreManagement: \"Core Management\",\n            programManagement: \"Program Management\",\n            personnelManagement: \"Personnel Management\",\n            studentManagement: \"Student Management\",\n            academic: \"Academic\",\n            academicManagement: \"Academic Management\",\n            finance: \"Finance\",\n            contentManagement: \"Content Management\",\n            announcements: \"Announcements\",\n            websiteBanners: \"Website Banners\",\n            system: \"System\",\n            reportsAnalytics: \"Reports & Analytics\",\n            aiAgent: \"AI Agent\",\n            helpCenter: \"Help Center\",\n            fileManagement: \"File Management\",\n            settings: \"Settings\",\n        },\n        landing: {\n            welcome: \"Welcome to University Management System\",\n            description: \"A comprehensive platform for managing academic and administrative tasks.\",\n            getStarted: \"Get Started\",\n            latestNews: \"Latest News\",\n            noNews: \"No news available at the moment.\",\n            readMore: \"Read full story\",\n            copyright: \"University Management System. All rights reserved.\",\n        },\n        student: {\n            myProfile: \"My Profile\",\n            grades: \"Grades\",\n            schedule: \"Class Schedule\",\n            registration: \"Registration\",\n            transcript: \"Transcript\",\n            finance: \"Finance\",\n            announcements: \"Announcements\",\n        },\n        applicant: {\n            title: \"UMS Admissions\",\n            register: \"Register\",\n            login: \"Login\",\n            applicationStatus: \"Application Status\",\n        }\n    },\n    th: {\n        common: {\n            searchPlaceholder: \"‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤...\",\n            signOut: \"‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö\",\n            adminLogin: \"‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•\",\n            studentPortal: \"‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤\",\n            help: \"‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠\",\n            admissions: \"‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤\",\n            language: \"‡∏†‡∏≤‡∏©‡∏≤\",\n        },\n        menu: {\n            home: \"‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å\",\n            curriculum: \"‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏π‡∏ï‡∏£\",\n            students: \"‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤\",\n            dashboard: \"‡πÅ‡∏î‡∏ä‡∏ö‡∏≠‡∏£‡πå‡∏î\",\n            overview: \"‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°\",\n            coreManagement: \"‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å\",\n            programManagement: \"‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏π‡∏ï‡∏£\",\n            personnelManagement: \"‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏∏‡∏Ñ‡∏•‡∏≤‡∏Å‡∏£\",\n            studentManagement: \"‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤\",\n            academic: \"‡∏ß‡∏¥‡∏ä‡∏≤‡∏Å‡∏≤‡∏£\",\n            academicManagement: \"‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡∏ä‡∏≤‡∏Å‡∏≤‡∏£\",\n            finance: \"‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô\",\n            contentManagement: \"‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤\",\n            announcements: \"‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®\",\n            websiteBanners: \"‡πÅ‡∏ö‡∏ô‡πÄ‡∏ô‡∏≠‡∏£‡πå‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏ã‡∏ï‡πå\",\n            system: \"‡∏£‡∏∞‡∏ö‡∏ö\",\n            reportsAnalytics: \"‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥\",\n            aiAgent: \"AI Agent\",\n            helpCenter: \"‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠\",\n            fileManagement: \"‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå\",\n            settings: \"‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö\",\n        },\n        landing: {\n            welcome: \"‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢\",\n            description: \"‡πÅ‡∏û‡∏•‡∏ï‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏Ñ‡∏£‡∏ö‡∏ß‡∏á‡∏à‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô‡∏ß‡∏¥‡∏ä‡∏≤‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡∏∞‡∏ò‡∏∏‡∏£‡∏Å‡∏≤‡∏£\",\n            getStarted: \"‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô\",\n            latestNews: \"‡∏Ç‡πà‡∏≤‡∏ß‡∏™‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î\",\n            noNews: \"‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πà‡∏≤‡∏ß‡∏™‡∏≤‡∏£‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ\",\n            readMore: \"‡∏≠‡πà‡∏≤‡∏ô‡∏ï‡πà‡∏≠\",\n            copyright: \"‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢ ‡∏™‡∏á‡∏ß‡∏ô‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå\",\n        },\n        student: {\n            myProfile: \"‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏â‡∏±‡∏ô\",\n            grades: \"‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô\",\n            schedule: \"‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô\",\n            registration: \"‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ô\",\n            transcript: \"‡∏ó‡∏£‡∏≤‡∏ô‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå\",\n            finance: \"‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô\",\n            announcements: \"‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®\",\n        },\n        applicant: {\n            title: \"‡∏£‡∏∞‡∏ö‡∏ö‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤\",\n            register: \"‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô\",\n            login: \"‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö\",\n            applicationStatus: \"‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£\",\n        }\n    },\n};\n"],"names":[],"mappings":";;;;AAEO,MAAM,aAAa;IACtB,IAAI;QACA,QAAQ;YACJ,mBAAmB;YACnB,SAAS;YACT,YAAY;YACZ,eAAe;YACf,MAAM;YACN,YAAY;YACZ,UAAU;QACd;QACA,MAAM;YACF,MAAM;YACN,YAAY;YACZ,UAAU;YACV,WAAW;YACX,UAAU;YACV,gBAAgB;YAChB,mBAAmB;YACnB,qBAAqB;YACrB,mBAAmB;YACnB,UAAU;YACV,oBAAoB;YACpB,SAAS;YACT,mBAAmB;YACnB,eAAe;YACf,gBAAgB;YAChB,QAAQ;YACR,kBAAkB;YAClB,SAAS;YACT,YAAY;YACZ,gBAAgB;YAChB,UAAU;QACd;QACA,SAAS;YACL,SAAS;YACT,aAAa;YACb,YAAY;YACZ,YAAY;YACZ,QAAQ;YACR,UAAU;YACV,WAAW;QACf;QACA,SAAS;YACL,WAAW;YACX,QAAQ;YACR,UAAU;YACV,cAAc;YACd,YAAY;YACZ,SAAS;YACT,eAAe;QACnB;QACA,WAAW;YACP,OAAO;YACP,UAAU;YACV,OAAO;YACP,mBAAmB;QACvB;IACJ;IACA,IAAI;QACA,QAAQ;YACJ,mBAAmB;YACnB,SAAS;YACT,YAAY;YACZ,eAAe;YACf,MAAM;YACN,YAAY;YACZ,UAAU;QACd;QACA,MAAM;YACF,MAAM;YACN,YAAY;YACZ,UAAU;YACV,WAAW;YACX,UAAU;YACV,gBAAgB;YAChB,mBAAmB;YACnB,qBAAqB;YACrB,mBAAmB;YACnB,UAAU;YACV,oBAAoB;YACpB,SAAS;YACT,mBAAmB;YACnB,eAAe;YACf,gBAAgB;YAChB,QAAQ;YACR,kBAAkB;YAClB,SAAS;YACT,YAAY;YACZ,gBAAgB;YAChB,UAAU;QACd;QACA,SAAS;YACL,SAAS;YACT,aAAa;YACb,YAAY;YACZ,YAAY;YACZ,QAAQ;YACR,UAAU;YACV,WAAW;QACf;QACA,SAAS;YACL,WAAW;YACX,QAAQ;YACR,UAAU;YACV,cAAc;YACd,YAAY;YACZ,SAAS;YACT,eAAe;QACnB;QACA,WAAW;YACP,OAAO;YACP,UAAU;YACV,OAAO;YACP,mBAAmB;QACvB;IACJ;AACJ"}},
    {"offset": {"line": 506, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/translation.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\nimport { dictionary } from \"@/lib/dictionary\";\n\nexport async function getTranslations() {\n    try {\n        // @ts-ignore - Prisma client update might not be picked up by IDE yet\n        const translations = await prisma.translation.findMany();\n\n        // Convert array to object { key: { en: valueEn, th: valueTh } }\n        const translationMap: Record<string, { en: string; th: string }> = {};\n\n        translations.forEach((t: any) => {\n            translationMap[t.key] = {\n                en: t.valueEn,\n                th: t.valueTh,\n            };\n        });\n\n        return translationMap;\n    } catch (error) {\n        console.error(\"Failed to fetch translations:\", error);\n        return {};\n    }\n}\n\nexport async function updateTranslation(key: string, values: { en: string; th: string }) {\n    try {\n        // @ts-ignore\n        await prisma.translation.upsert({\n            where: { key },\n            update: {\n                valueEn: values.en,\n                valueTh: values.th,\n            },\n            create: {\n                key,\n                valueEn: values.en,\n                valueTh: values.th,\n            },\n        });\n\n        revalidatePath(\"/\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update translation:\", error);\n        return { success: false, error: \"Failed to update translation\" };\n    }\n}\n\nexport async function seedTranslations() {\n    try {\n        const operations = [];\n\n        // Helper to flatten the dictionary\n        const flattenDictionary = (obj: any, prefix = \"\") => {\n            let result: Record<string, string> = {};\n            for (const key in obj) {\n                if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                    const nested = flattenDictionary(obj[key], `${prefix}${key}.`);\n                    result = { ...result, ...nested };\n                } else {\n                    result[`${prefix}${key}`] = obj[key];\n                }\n            }\n            return result;\n        };\n\n        const enFlat = flattenDictionary(dictionary.en);\n        const thFlat = flattenDictionary(dictionary.th);\n\n        // Get all unique keys\n        const allKeys = new Set([...Object.keys(enFlat), ...Object.keys(thFlat)]);\n\n        for (const key of Array.from(allKeys)) {\n            operations.push(\n                // @ts-ignore\n                prisma.translation.upsert({\n                    where: { key },\n                    update: {\n                        // Only update if missing? Or overwrite? \n                        // Let's overwrite to ensure sync with file initially, \n                        // but in production we might want to be careful.\n                        // For this task, we assume file is source of truth for initial seed.\n                        valueEn: enFlat[key] || \"\",\n                        valueTh: thFlat[key] || \"\",\n                    },\n                    create: {\n                        key,\n                        valueEn: enFlat[key] || \"\",\n                        valueTh: thFlat[key] || \"\",\n                    },\n                })\n            );\n        }\n\n        await prisma.$transaction(operations);\n\n        revalidatePath(\"/\");\n        return { success: true, count: operations.length };\n    } catch (error) {\n        console.error(\"Failed to seed translations:\", error);\n        return { success: false, error: String(error) };\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IAClB,IAAI;QACA,sEAAsE;QACtE,MAAM,eAAe,MAAM,kJAAM,CAAC,WAAW,CAAC,QAAQ;QAEtD,gEAAgE;QAChE,MAAM,iBAA6D,CAAC;QAEpE,aAAa,OAAO,CAAC,CAAC;YAClB,cAAc,CAAC,EAAE,GAAG,CAAC,GAAG;gBACpB,IAAI,EAAE,OAAO;gBACb,IAAI,EAAE,OAAO;YACjB;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,CAAC;IACZ;AACJ;AAEO,eAAe,kBAAkB,GAAW,EAAE,MAAkC;IACnF,IAAI;QACA,aAAa;QACb,MAAM,kJAAM,CAAC,WAAW,CAAC,MAAM,CAAC;YAC5B,OAAO;gBAAE;YAAI;YACb,QAAQ;gBACJ,SAAS,OAAO,EAAE;gBAClB,SAAS,OAAO,EAAE;YACtB;YACA,QAAQ;gBACJ;gBACA,SAAS,OAAO,EAAE;gBAClB,SAAS,OAAO,EAAE;YACtB;QACJ;QAEA,IAAA,+IAAc,EAAC;QACf,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA+B;IACnE;AACJ;AAEO,eAAe;IAClB,IAAI;QACA,MAAM,aAAa,EAAE;QAErB,mCAAmC;QACnC,MAAM,oBAAoB,CAAC,KAAU,SAAS,EAAE;YAC5C,IAAI,SAAiC,CAAC;YACtC,IAAK,MAAM,OAAO,IAAK;gBACnB,IAAI,OAAO,GAAG,CAAC,IAAI,KAAK,YAAY,GAAG,CAAC,IAAI,KAAK,MAAM;oBACnD,MAAM,SAAS,kBAAkB,GAAG,CAAC,IAAI,EAAE,GAAG,SAAS,IAAI,CAAC,CAAC;oBAC7D,SAAS;wBAAE,GAAG,MAAM;wBAAE,GAAG,MAAM;oBAAC;gBACpC,OAAO;oBACH,MAAM,CAAC,GAAG,SAAS,KAAK,CAAC,GAAG,GAAG,CAAC,IAAI;gBACxC;YACJ;YACA,OAAO;QACX;QAEA,MAAM,SAAS,kBAAkB,8IAAU,CAAC,EAAE;QAC9C,MAAM,SAAS,kBAAkB,8IAAU,CAAC,EAAE;QAE9C,sBAAsB;QACtB,MAAM,UAAU,IAAI,IAAI;eAAI,OAAO,IAAI,CAAC;eAAY,OAAO,IAAI,CAAC;SAAQ;QAExE,KAAK,MAAM,OAAO,MAAM,IAAI,CAAC,SAAU;YACnC,WAAW,IAAI,CACX,aAAa;YACb,kJAAM,CAAC,WAAW,CAAC,MAAM,CAAC;gBACtB,OAAO;oBAAE;gBAAI;gBACb,QAAQ;oBACJ,yCAAyC;oBACzC,uDAAuD;oBACvD,iDAAiD;oBACjD,qEAAqE;oBACrE,SAAS,MAAM,CAAC,IAAI,IAAI;oBACxB,SAAS,MAAM,CAAC,IAAI,IAAI;gBAC5B;gBACA,QAAQ;oBACJ;oBACA,SAAS,MAAM,CAAC,IAAI,IAAI;oBACxB,SAAS,MAAM,CAAC,IAAI,IAAI;gBAC5B;YACJ;QAER;QAEA,MAAM,kJAAM,CAAC,YAAY,CAAC;QAE1B,IAAA,+IAAc,EAAC;QACf,OAAO;YAAE,SAAS;YAAM,OAAO,WAAW,MAAM;QAAC;IACrD,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;YAAE,SAAS;YAAO,OAAO,OAAO;QAAO;IAClD;AACJ;;;IApGsB;IAsBA;IAwBA;;AA9CA,+OAAA;AAsBA,+OAAA;AAwBA,+OAAA"}},
    {"offset": {"line": 644, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/lib/csrf.ts"],"sourcesContent":["\"use server\";\n\nimport { cookies } from \"next/headers\";\nimport crypto from \"crypto\";\n\n/**\n * Generate a CSRF token and store it in cookies\n */\nexport async function generateCsrfToken(): Promise<string> {\n    const token = crypto.randomBytes(32).toString(\"hex\");\n\n    (await cookies()).set({\n        name: \"csrf_token\",\n        value: token,\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: \"strict\",\n        maxAge: 60 * 60 * 24, // 24 hours\n        path: \"/\",\n    });\n\n    return token;\n}\n\n/**\n * Verify CSRF token from form data against cookie\n */\nexport async function verifyCsrfToken(formToken: string): Promise<boolean> {\n    const cookieToken = (await cookies()).get(\"csrf_token\");\n\n    if (!cookieToken || !formToken) {\n        return false;\n    }\n\n    // Use timing-safe comparison to prevent timing attacks\n    return crypto.timingSafeEqual(\n        Buffer.from(cookieToken.value),\n        Buffer.from(formToken)\n    );\n}\n\n/**\n * Get current CSRF token from cookies\n */\nexport async function getCsrfToken(): Promise<string | null> {\n    const token = (await cookies()).get(\"csrf_token\");\n    return token?.value || null;\n}\n\n/**\n * Middleware helper to validate CSRF token\n * Throws error if token is invalid\n */\nexport async function requireCsrfToken(formData: FormData): Promise<void> {\n    const formToken = formData.get(\"csrf_token\") as string;\n\n    if (!formToken) {\n        throw new Error(\"CSRF token is missing\");\n    }\n\n    const isValid = await verifyCsrfToken(formToken);\n\n    if (!isValid) {\n        throw new Error(\"Invalid CSRF token. Please refresh the page and try again.\");\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAEA;AACA;;;;;AAKO,eAAe;IAClB,MAAM,QAAQ,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;IAE9C,CAAC,MAAM,IAAA,0IAAO,GAAE,EAAE,GAAG,CAAC;QAClB,MAAM;QACN,OAAO;QACP,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,KAAK,KAAK;QAClB,MAAM;IACV;IAEA,OAAO;AACX;AAKO,eAAe,gBAAgB,SAAiB;IACnD,MAAM,cAAc,CAAC,MAAM,IAAA,0IAAO,GAAE,EAAE,GAAG,CAAC;IAE1C,IAAI,CAAC,eAAe,CAAC,WAAW;QAC5B,OAAO;IACX;IAEA,uDAAuD;IACvD,OAAO,gHAAM,CAAC,eAAe,CACzB,OAAO,IAAI,CAAC,YAAY,KAAK,GAC7B,OAAO,IAAI,CAAC;AAEpB;AAKO,eAAe;IAClB,MAAM,QAAQ,CAAC,MAAM,IAAA,0IAAO,GAAE,EAAE,GAAG,CAAC;IACpC,OAAO,OAAO,SAAS;AAC3B;AAMO,eAAe,iBAAiB,QAAkB;IACrD,MAAM,YAAY,SAAS,GAAG,CAAC;IAE/B,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,UAAU,MAAM,gBAAgB;IAEtC,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;AACJ;;;IAzDsB;IAmBA;IAiBA;IASA;;AA7CA,+OAAA;AAmBA,+OAAA;AAiBA,+OAAA;AASA,+OAAA"}},
    {"offset": {"line": 711, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/lib/rate-limit.ts"],"sourcesContent":["\"use server\";\n\nimport { cookies } from \"next/headers\";\nimport { loginAttemptsStore, RATE_LIMIT_CONFIG } from \"./rate-limit-cleanup\";\n\n// Re-export for backward compatibility\nconst loginAttempts = loginAttemptsStore;\n\n/**\n * Get client identifier (IP address or session ID)\n */\nasync function getClientId(): Promise<string> {\n    // Try to get from cookies first (for consistent tracking)\n    const clientCookie = (await cookies()).get(\"client_id\");\n\n    if (clientCookie) {\n        return clientCookie.value;\n    }\n\n    // Generate new client ID\n    const newClientId = crypto.randomUUID();\n    (await cookies()).set({\n        name: \"client_id\",\n        value: newClientId,\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: \"strict\",\n        maxAge: 60 * 60 * 24 * 365, // 1 year\n        path: \"/\",\n    });\n\n    return newClientId;\n}\n\n/**\n * Check if client is rate limited\n * Returns error message if blocked, null if allowed\n */\nexport async function checkRateLimit(identifier?: string): Promise<string | null> {\n    const clientId = identifier || await getClientId();\n    const now = Date.now();\n    const attempt = loginAttempts.get(clientId);\n\n    if (!attempt) {\n        return null; // No previous attempts\n    }\n\n    // Check if currently blocked\n    if (attempt.blockedUntil && now < attempt.blockedUntil) {\n        const remainingMinutes = Math.ceil((attempt.blockedUntil - now) / 60000);\n        return `Too many login attempts. Please try again in ${remainingMinutes} minute${remainingMinutes > 1 ? 's' : ''}.`;\n    }\n\n    // Check if window has expired\n    if (now - attempt.firstAttempt > RATE_LIMIT_CONFIG.windowMs) {\n        // Reset the attempt counter\n        loginAttempts.delete(clientId);\n        return null;\n    }\n\n    // Check if max attempts reached\n    if (attempt.count >= RATE_LIMIT_CONFIG.maxAttempts) {\n        // Block the client\n        attempt.blockedUntil = now + RATE_LIMIT_CONFIG.blockDurationMs;\n        loginAttempts.set(clientId, attempt);\n\n        const blockMinutes = Math.ceil(RATE_LIMIT_CONFIG.blockDurationMs / 60000);\n        return `Too many login attempts. Your account has been temporarily blocked for ${blockMinutes} minutes.`;\n    }\n\n    return null; // Allowed\n}\n\n/**\n * Record a failed login attempt\n */\nexport async function recordFailedAttempt(identifier?: string): Promise<void> {\n    const clientId = identifier || await getClientId();\n    const now = Date.now();\n    const attempt = loginAttempts.get(clientId);\n\n    if (!attempt) {\n        // First attempt\n        loginAttempts.set(clientId, {\n            count: 1,\n            firstAttempt: now,\n        });\n    } else if (now - attempt.firstAttempt > RATE_LIMIT_CONFIG.windowMs) {\n        // Window expired, reset\n        loginAttempts.set(clientId, {\n            count: 1,\n            firstAttempt: now,\n        });\n    } else {\n        // Increment counter\n        attempt.count++;\n        loginAttempts.set(clientId, attempt);\n    }\n}\n\n/**\n * Reset rate limit for a client (on successful login)\n */\nexport async function resetRateLimit(identifier?: string): Promise<void> {\n    const clientId = identifier || await getClientId();\n    loginAttempts.delete(clientId);\n}\n\n/**\n * Get remaining attempts for a client\n */\nexport async function getRemainingAttempts(identifier?: string): Promise<number> {\n    const clientId = identifier || await getClientId();\n    const attempt = loginAttempts.get(clientId);\n\n    if (!attempt) {\n        return RATE_LIMIT_CONFIG.maxAttempts;\n    }\n\n    const now = Date.now();\n\n    // Check if window expired\n    if (now - attempt.firstAttempt > RATE_LIMIT_CONFIG.windowMs) {\n        return RATE_LIMIT_CONFIG.maxAttempts;\n    }\n\n    return Math.max(0, RATE_LIMIT_CONFIG.maxAttempts - attempt.count);\n}\n\n/**\n * Clean up old entries (should be called periodically)\n */\nexport async function cleanupRateLimitStore(): Promise<void> {\n    const now = Date.now();\n    const expiredTime = now - RATE_LIMIT_CONFIG.windowMs - RATE_LIMIT_CONFIG.blockDurationMs;\n\n    const entries = Array.from(loginAttempts.entries());\n    for (const [clientId, attempt] of entries) {\n        if (attempt.firstAttempt < expiredTime) {\n            loginAttempts.delete(clientId);\n        }\n    }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 847, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/admin-auth.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { cookies } from \"next/headers\";\nimport bcrypt from \"bcryptjs\";\nimport { redirect } from \"next/navigation\";\nimport { requireCsrfToken } from \"@/lib/csrf\";\nimport { checkRateLimit, recordFailedAttempt, resetRateLimit } from \"@/lib/rate-limit\";\n\n/**\n * Login Admin ‚Äì ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö email/password ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏±‡πâ‡∏á cookie admin_session\n */\nexport async function loginAdmin(formData: FormData) {\n    // CSRF Protection\n    await requireCsrfToken(formData);\n\n    // Rate Limiting Check\n    const rateLimitError = await checkRateLimit();\n    if (rateLimitError) {\n        throw new Error(rateLimitError);\n    }\n\n    const email = (formData.get(\"email\") as string)?.trim();\n    const password = (formData.get(\"password\") as string);\n\n    if (!email || !password) {\n        throw new Error(\"Email and password are required\");\n    }\n\n    const user = await prisma.user.findUnique({\n        where: { email },\n        select: {\n            id: true,\n            email: true,\n            passwordHash: true,\n            role: true,\n            twoFactorEnabled: true,\n            twoFactorSecret: true,\n            personnelProfile: {\n                select: {\n                    id: true,\n                    firstName: true,\n                    lastName: true,\n                },\n            },\n        },\n    });\n\n    if (!user || user.role !== \"ADMIN\" || !user.personnelProfile) {\n        await recordFailedAttempt(); // Record failed attempt\n        throw new Error(\"Invalid credentials\");\n    }\n\n    const passwordMatch = await bcrypt.compare(password, user.passwordHash);\n    if (!passwordMatch) {\n        await recordFailedAttempt(); // Record failed attempt\n        throw new Error(\"Invalid credentials\");\n    }\n\n    // Check if user has 2FA enabled\n    if (user.twoFactorEnabled && user.twoFactorSecret) {\n        // Store temporary session for 2FA verification\n        (await cookies()).set({\n            name: \"admin_2fa_pending\",\n            value: JSON.stringify({\n                userId: user.id,\n                role: user.role,\n                personnelId: user.personnelProfile.id,\n            }),\n            httpOnly: true,\n            path: \"/\",\n            maxAge: 5 * 60, // 5 minutes\n        });\n\n        // Redirect to 2FA verification page\n        redirect(\"/admin/login/verify\");\n    }\n\n    // No 2FA - proceed with normal login\n    const session = {\n        userId: user.id,\n        role: user.role,\n        personnelId: user.personnelProfile.id,\n    };\n\n    // Reset rate limit on successful login\n    await resetRateLimit();\n\n    (await cookies()).set({\n        name: \"admin_session\",\n        value: JSON.stringify(session),\n        httpOnly: true,\n        path: \"/\",\n        // secure: process.env.NODE_ENV === \"production\",\n        maxAge: 60 * 60 * 24 * 7,\n    });\n\n    redirect(\"/admin\");\n}\n\n/** Logout Admin */\nexport async function logoutAdmin() {\n    (await cookies()).delete(\"admin_session\");\n    redirect(\"/admin/login\");\n}\n\n/**\n * Verify 2FA code and complete login\n */\nexport async function verify2FALogin(code: string) {\n    // Get pending session\n    const pendingCookie = (await cookies()).get(\"admin_2fa_pending\");\n\n    if (!pendingCookie) {\n        throw new Error(\"No pending 2FA verification. Please login again.\");\n    }\n\n    let pendingSession;\n    try {\n        pendingSession = JSON.parse(pendingCookie.value);\n    } catch (e) {\n        throw new Error(\"Invalid session data\");\n    }\n\n    // Import verify function\n    const { verify2FACode } = await import(\"@/lib/two-factor\");\n\n    // Verify the 2FA code\n    const isValid = await verify2FACode(pendingSession.userId, code);\n\n    if (!isValid) {\n        await recordFailedAttempt();\n        throw new Error(\"Invalid verification code\");\n    }\n\n    // Delete pending session\n    (await cookies()).delete(\"admin_2fa_pending\");\n\n    // Reset rate limit\n    await resetRateLimit();\n\n    // Create actual session\n    (await cookies()).set({\n        name: \"admin_session\",\n        value: JSON.stringify(pendingSession),\n        httpOnly: true,\n        path: \"/\",\n        // secure: process.env.NODE_ENV === \"production\",\n        maxAge: 60 * 60 * 24 * 7,\n    });\n\n    redirect(\"/admin\");\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1000, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { cookies } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\n\nexport async function registerApplicant(formData: FormData) {\n    const email = formData.get(\"email\") as string;\n    const password = formData.get(\"password\") as string;\n    const firstName = formData.get(\"firstName\") as string;\n    const lastName = formData.get(\"lastName\") as string;\n    const confirmPassword = formData.get(\"confirmPassword\") as string;\n\n    if (password !== confirmPassword) {\n        throw new Error(\"Passwords do not match\");\n    }\n\n    // Check if user exists\n    const existingUser = await prisma.user.findUnique({\n        where: { email },\n    });\n\n    if (existingUser) {\n        throw new Error(\"Email already registered\");\n    }\n\n    const bcrypt = require(\"bcryptjs\");\n    const passwordHash = await bcrypt.hash(password, 10);\n\n    // Create User & Applicant Profile\n    const user = await prisma.user.create({\n        data: {\n            email,\n            passwordHash,\n            role: \"APPLICANT\",\n            applicantProfile: {\n                create: {\n                    firstName,\n                    lastName,\n                },\n            },\n        },\n        include: {\n            applicantProfile: true,\n        },\n    });\n\n    // Set Session Cookie (Simple implementation)\n    // In production, use a secure session library or JWT\n    const sessionData = JSON.stringify({ userId: user.id, role: user.role, applicantId: user.applicantProfile?.id });\n    (await cookies()).set(\"applicant_session\", sessionData, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        maxAge: 60 * 60 * 24 * 7, // 1 week\n        path: \"/\",\n    });\n\n    redirect(\"/admissions/dashboard\");\n}\n\nexport async function loginApplicant(formData: FormData) {\n    const email = formData.get(\"email\") as string;\n    const password = formData.get(\"password\") as string;\n\n    const user = await prisma.user.findUnique({\n        where: { email },\n        include: {\n            applicantProfile: true,\n        },\n    });\n\n    if (!user || user.role !== \"APPLICANT\") {\n        throw new Error(\"Invalid credentials\");\n    }\n\n    const bcrypt = require(\"bcryptjs\");\n    const isValid = await bcrypt.compare(password, user.passwordHash);\n\n    if (!isValid) {\n        throw new Error(\"Invalid credentials\");\n    }\n\n    // Set Session Cookie\n    const sessionData = JSON.stringify({ userId: user.id, role: user.role, applicantId: user.applicantProfile?.id });\n    (await cookies()).set(\"applicant_session\", sessionData, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        maxAge: 60 * 60 * 24 * 7, // 1 week\n        path: \"/\",\n    });\n\n    redirect(\"/admissions/dashboard\");\n}\n\nexport async function logoutApplicant() {\n    (await cookies()).delete(\"applicant_session\");\n    redirect(\"/admissions/login\");\n}\n\nexport async function getApplicantSession() {\n    const sessionCookie = (await cookies()).get(\"applicant_session\");\n    if (!sessionCookie) return null;\n    try {\n        return JSON.parse(sessionCookie.value);\n    } catch (e) {\n        return null;\n    }\n}\n\nexport async function getAdminSession() {\n    const sessionCookie = (await cookies()).get(\"admin_session\");\n    if (!sessionCookie) return null;\n    try {\n        return JSON.parse(sessionCookie.value);\n    } catch (e) {\n        return null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1146, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/settings.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\nimport { getAdminSession } from \"./auth\";\n\nexport async function getSystemSettings() {\n    let settings = await prisma.systemSettings.findFirst();\n\n    if (!settings) {\n        // Create default settings if not exists\n        settings = await prisma.systemSettings.create({\n            data: {},\n        });\n    } else {\n        // Auto-update legacy defaults if they match the old defaults\n        // This ensures the user sees the requested default values\n        const isOldDefaultName = settings.universityName === \"University Management System\";\n        const isOldDefaultNameTh = settings.universityNameTh === \"‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢\";\n\n        if (isOldDefaultName || isOldDefaultNameTh) {\n            settings = await prisma.systemSettings.update({\n                where: { id: settings.id },\n                data: {\n                    universityName: isOldDefaultName ? \"University MS\" : settings.universityName,\n                    universityNameTh: isOldDefaultNameTh ? \"‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢\" : settings.universityNameTh,\n                }\n            });\n        }\n    }\n\n    return settings;\n}\n\nexport async function updateSystemSettings(formData: FormData) {\n    const session = await getAdminSession();\n    if (!session) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const universityName = formData.get(\"universityName\") as string;\n    const universityNameTh = formData.get(\"universityNameTh\") as string;\n    const logoUrl = formData.get(\"logoUrl\") as string;\n    const primaryColor = formData.get(\"primaryColor\") as string;\n    const secondaryColor = formData.get(\"secondaryColor\") as string;\n    const backgroundColor = formData.get(\"backgroundColor\") as string;\n    const studentIdFormat = formData.get(\"studentIdFormat\") as string;\n    const defaultLanguage = formData.get(\"defaultLanguage\") as string;\n\n    console.log(\"Updating settings:\", { universityName, universityNameTh, logoUrl });\n\n    const settings = await getSystemSettings();\n\n    await prisma.systemSettings.update({\n        where: { id: settings.id },\n        data: {\n            universityName,\n            universityNameTh,\n            logoUrl: logoUrl || null,\n            primaryColor,\n            secondaryColor,\n            backgroundColor,\n            studentIdFormat,\n            defaultLanguage,\n        },\n    });\n\n    revalidatePath(\"/admin/settings\");\n    revalidatePath(\"/\");\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IAClB,IAAI,WAAW,MAAM,kJAAM,CAAC,cAAc,CAAC,SAAS;IAEpD,IAAI,CAAC,UAAU;QACX,wCAAwC;QACxC,WAAW,MAAM,kJAAM,CAAC,cAAc,CAAC,MAAM,CAAC;YAC1C,MAAM,CAAC;QACX;IACJ,OAAO;QACH,6DAA6D;QAC7D,0DAA0D;QAC1D,MAAM,mBAAmB,SAAS,cAAc,KAAK;QACrD,MAAM,qBAAqB,SAAS,gBAAgB,KAAK;QAEzD,IAAI,oBAAoB,oBAAoB;YACxC,WAAW,MAAM,kJAAM,CAAC,cAAc,CAAC,MAAM,CAAC;gBAC1C,OAAO;oBAAE,IAAI,SAAS,EAAE;gBAAC;gBACzB,MAAM;oBACF,gBAAgB,mBAAmB,kBAAkB,SAAS,cAAc;oBAC5E,kBAAkB,qBAAqB,gCAAgC,SAAS,gBAAgB;gBACpG;YACJ;QACJ;IACJ;IAEA,OAAO;AACX;AAEO,eAAe,qBAAqB,QAAkB;IACzD,MAAM,UAAU,MAAM,IAAA,iJAAe;IACrC,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,iBAAiB,SAAS,GAAG,CAAC;IACpC,MAAM,mBAAmB,SAAS,GAAG,CAAC;IACtC,MAAM,UAAU,SAAS,GAAG,CAAC;IAC7B,MAAM,eAAe,SAAS,GAAG,CAAC;IAClC,MAAM,iBAAiB,SAAS,GAAG,CAAC;IACpC,MAAM,kBAAkB,SAAS,GAAG,CAAC;IACrC,MAAM,kBAAkB,SAAS,GAAG,CAAC;IACrC,MAAM,kBAAkB,SAAS,GAAG,CAAC;IAErC,QAAQ,GAAG,CAAC,sBAAsB;QAAE;QAAgB;QAAkB;IAAQ;IAE9E,MAAM,WAAW,MAAM;IAEvB,MAAM,kJAAM,CAAC,cAAc,CAAC,MAAM,CAAC;QAC/B,OAAO;YAAE,IAAI,SAAS,EAAE;QAAC;QACzB,MAAM;YACF;YACA;YACA,SAAS,WAAW;YACpB;YACA;YACA;YACA;YACA;QACJ;IACJ;IAEA,IAAA,+IAAc,EAAC;IACf,IAAA,+IAAc,EAAC;AACnB;;;IA/DsB;IA4BA;;AA5BA,+OAAA;AA4BA,+OAAA"}},
    {"offset": {"line": 1235, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/academic.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma, DayOfWeek } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\n\nexport async function getAcademicTerms() {\n    return await prisma.academicTerm.findMany({\n        orderBy: [{ year: \"desc\" }, { semester: \"desc\" }],\n    });\n}\n\nexport async function createAcademicTerm(formData: FormData) {\n    const year = parseInt(formData.get(\"year\") as string);\n    const semester = parseInt(formData.get(\"semester\") as string);\n    const startDate = new Date(formData.get(\"startDate\") as string);\n    const endDate = new Date(formData.get(\"endDate\") as string);\n    const isCurrent = formData.get(\"isCurrent\") === \"true\";\n\n    // If setting as current, unset all others\n    if (isCurrent) {\n        await prisma.academicTerm.updateMany({\n            where: { isCurrent: true },\n            data: { isCurrent: false },\n        });\n    }\n\n    await prisma.academicTerm.create({\n        data: {\n            year,\n            semester,\n            startDate,\n            endDate,\n            isCurrent,\n        },\n    });\n\n    revalidatePath(\"/admin/academic\");\n    revalidatePath(\"/admin/academic/terms\");\n}\n\nexport async function getClassSections(termId?: string) {\n    return await prisma.classSection.findMany({\n        where: termId ? { termId } : undefined,\n        include: {\n            course: true,\n            term: true,\n            instructor: true,\n            schedules: true,\n            _count: {\n                select: {\n                    enrollments: true,\n                },\n            },\n        },\n        orderBy: {\n            sectionNumber: \"asc\",\n        },\n    });\n}\n\nexport async function createClassSection(formData: FormData) {\n    const courseId = formData.get(\"courseId\") as string;\n    const termId = formData.get(\"termId\") as string;\n    const sectionNumber = formData.get(\"sectionNumber\") as string;\n    const capacity = parseInt(formData.get(\"capacity\") as string);\n    const instructorId = formData.get(\"instructorId\") as string;\n\n    const day = formData.get(\"day\") as DayOfWeek;\n    const startTime = formData.get(\"startTime\") as string;\n    const endTime = formData.get(\"endTime\") as string;\n    const room = formData.get(\"room\") as string;\n\n    const section = await prisma.classSection.create({\n        data: {\n            courseId,\n            termId,\n            sectionNumber,\n            capacity,\n            instructorId: instructorId || undefined,\n            schedules: {\n                create: [\n                    {\n                        day,\n                        startTime,\n                        endTime,\n                        room,\n                    },\n                ],\n            },\n        },\n    });\n\n    revalidatePath(\"/admin/academic/sections\");\n    return section.id;\n}\n\nexport async function deleteClassSection(id: string) {\n    await prisma.classSection.delete({\n        where: { id },\n    });\n\n    revalidatePath(\"/admin/academic/sections\");\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AACA;;;;;AAEO,eAAe;IAClB,OAAO,MAAM,kJAAM,CAAC,YAAY,CAAC,QAAQ,CAAC;QACtC,SAAS;YAAC;gBAAE,MAAM;YAAO;YAAG;gBAAE,UAAU;YAAO;SAAE;IACrD;AACJ;AAEO,eAAe,mBAAmB,QAAkB;IACvD,MAAM,OAAO,SAAS,SAAS,GAAG,CAAC;IACnC,MAAM,WAAW,SAAS,SAAS,GAAG,CAAC;IACvC,MAAM,YAAY,IAAI,KAAK,SAAS,GAAG,CAAC;IACxC,MAAM,UAAU,IAAI,KAAK,SAAS,GAAG,CAAC;IACtC,MAAM,YAAY,SAAS,GAAG,CAAC,iBAAiB;IAEhD,0CAA0C;IAC1C,IAAI,WAAW;QACX,MAAM,kJAAM,CAAC,YAAY,CAAC,UAAU,CAAC;YACjC,OAAO;gBAAE,WAAW;YAAK;YACzB,MAAM;gBAAE,WAAW;YAAM;QAC7B;IACJ;IAEA,MAAM,kJAAM,CAAC,YAAY,CAAC,MAAM,CAAC;QAC7B,MAAM;YACF;YACA;YACA;YACA;YACA;QACJ;IACJ;IAEA,IAAA,+IAAc,EAAC;IACf,IAAA,+IAAc,EAAC;AACnB;AAEO,eAAe,iBAAiB,MAAe;IAClD,OAAO,MAAM,kJAAM,CAAC,YAAY,CAAC,QAAQ,CAAC;QACtC,OAAO,SAAS;YAAE;QAAO,IAAI;QAC7B,SAAS;YACL,QAAQ;YACR,MAAM;YACN,YAAY;YACZ,WAAW;YACX,QAAQ;gBACJ,QAAQ;oBACJ,aAAa;gBACjB;YACJ;QACJ;QACA,SAAS;YACL,eAAe;QACnB;IACJ;AACJ;AAEO,eAAe,mBAAmB,QAAkB;IACvD,MAAM,WAAW,SAAS,GAAG,CAAC;IAC9B,MAAM,SAAS,SAAS,GAAG,CAAC;IAC5B,MAAM,gBAAgB,SAAS,GAAG,CAAC;IACnC,MAAM,WAAW,SAAS,SAAS,GAAG,CAAC;IACvC,MAAM,eAAe,SAAS,GAAG,CAAC;IAElC,MAAM,MAAM,SAAS,GAAG,CAAC;IACzB,MAAM,YAAY,SAAS,GAAG,CAAC;IAC/B,MAAM,UAAU,SAAS,GAAG,CAAC;IAC7B,MAAM,OAAO,SAAS,GAAG,CAAC;IAE1B,MAAM,UAAU,MAAM,kJAAM,CAAC,YAAY,CAAC,MAAM,CAAC;QAC7C,MAAM;YACF;YACA;YACA;YACA;YACA,cAAc,gBAAgB;YAC9B,WAAW;gBACP,QAAQ;oBACJ;wBACI;wBACA;wBACA;wBACA;oBACJ;iBACH;YACL;QACJ;IACJ;IAEA,IAAA,+IAAc,EAAC;IACf,OAAO,QAAQ,EAAE;AACrB;AAEO,eAAe,mBAAmB,EAAU;IAC/C,MAAM,kJAAM,CAAC,YAAY,CAAC,MAAM,CAAC;QAC7B,OAAO;YAAE;QAAG;IAChB;IAEA,IAAA,+IAAc,EAAC;AACnB;;;IAjGsB;IAMA;IA6BA;IAoBA;IAoCA;;AA3FA,+OAAA;AAMA,+OAAA;AA6BA,+OAAA;AAoBA,+OAAA;AAoCA,+OAAA"}},
    {"offset": {"line": 1373, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/schedule-rooms.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all rooms with filters\nexport async function getRooms(filters?: {\n    search?: string;\n    roomType?: string;\n    building?: string;\n    isAvailable?: boolean;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.search) {\n            where.OR = [\n                { code: { contains: filters.search } },\n                { name: { contains: filters.search } },\n                { building: { contains: filters.search } },\n            ];\n        }\n\n        if (filters?.roomType && filters.roomType !== \"ALL\") {\n            where.roomType = filters.roomType;\n        }\n\n        if (filters?.building) {\n            where.building = filters.building;\n        }\n\n        if (filters?.isAvailable !== undefined) {\n            where.isAvailable = filters.isAvailable;\n        }\n\n        const rooms = await prisma.room.findMany({\n            where,\n            include: {\n                schedules: {\n                    select: {\n                        id: true,\n                        day: true,\n                        startTime: true,\n                        endTime: true,\n                    },\n                },\n                examSlots: {\n                    select: {\n                        id: true,\n                    },\n                },\n            },\n            orderBy: [\n                { building: \"asc\" },\n                { floor: \"asc\" },\n                { code: \"asc\" },\n            ],\n        });\n\n        return { success: true, rooms };\n    } catch (error) {\n        console.error(\"Error fetching rooms:\", error);\n        return { success: false, error: \"Failed to fetch rooms\" };\n    }\n}\n\n// Get room statistics\nexport async function getRoomStats() {\n    try {\n        const [total, available, inUse] = await Promise.all([\n            prisma.room.count({ where: { isActive: true } }),\n            prisma.room.count({ where: { isActive: true, isAvailable: true } }),\n            prisma.room.count({ where: { isActive: true, isAvailable: false } }),\n        ]);\n\n        // Count by room type\n        const roomsByType = await prisma.room.groupBy({\n            by: [\"roomType\"],\n            where: { isActive: true },\n            _count: true,\n        });\n\n        const typeBreakdown: Record<string, number> = {};\n        roomsByType.forEach((item) => {\n            typeBreakdown[item.roomType] = item._count;\n        });\n\n        // Calculate utilization (rooms with schedules / total rooms)\n        const roomsWithSchedules = await prisma.room.count({\n            where: {\n                isActive: true,\n                schedules: {\n                    some: {},\n                },\n            },\n        });\n\n        const utilization = total > 0 ? Math.round((roomsWithSchedules / total) * 100) : 0;\n\n        return {\n            success: true,\n            stats: {\n                total,\n                available,\n                inUse,\n                utilization,\n                byType: typeBreakdown,\n            },\n        };\n    } catch (error) {\n        console.error(\"Error fetching room stats:\", error);\n        return { success: false, error: \"Failed to fetch statistics\" };\n    }\n}\n\n// Get room by ID\nexport async function getRoomById(id: string) {\n    try {\n        const room = await prisma.room.findUnique({\n            where: { id },\n            include: {\n                schedules: {\n                    include: {\n                        section: {\n                            include: {\n                                course: {\n                                    select: {\n                                        code: true,\n                                        nameEn: true,\n                                    },\n                                },\n                                instructor: {\n                                    select: {\n                                        firstName: true,\n                                        lastName: true,\n                                    },\n                                },\n                            },\n                        },\n                    },\n                },\n                examSlots: {\n                    include: {\n                        examSchedule: {\n                            include: {\n                                course: {\n                                    select: {\n                                        code: true,\n                                        nameEn: true,\n                                    },\n                                },\n                            },\n                        },\n                    },\n                },\n            },\n        });\n\n        if (!room) {\n            return { success: false, error: \"Room not found\" };\n        }\n\n        return { success: true, room };\n    } catch (error) {\n        console.error(\"Error fetching room:\", error);\n        return { success: false, error: \"Failed to fetch room\" };\n    }\n}\n\n// Create room\nexport async function createRoom(data: {\n    code: string;\n    name: string;\n    building: string;\n    floor: number;\n    capacity: number;\n    roomType: string;\n    facilities?: string;\n}) {\n    try {\n        const room = await prisma.room.create({\n            data: {\n                code: data.code,\n                name: data.name,\n                building: data.building,\n                floor: data.floor,\n                capacity: data.capacity,\n                roomType: data.roomType as any,\n                facilities: data.facilities,\n                isActive: true,\n                isAvailable: true,\n            },\n        });\n\n        revalidatePath(\"/admin/schedule/rooms\");\n        return { success: true, room };\n    } catch (error) {\n        console.error(\"Error creating room:\", error);\n        return { success: false, error: \"Failed to create room\" };\n    }\n}\n\n// Update room\nexport async function updateRoom(\n    id: string,\n    data: {\n        code?: string;\n        name?: string;\n        building?: string;\n        floor?: number;\n        capacity?: number;\n        roomType?: string;\n        facilities?: string;\n        isAvailable?: boolean;\n    }\n) {\n    try {\n        const room = await prisma.room.update({\n            where: { id },\n            data: {\n                ...(data.code && { code: data.code }),\n                ...(data.name && { name: data.name }),\n                ...(data.building && { building: data.building }),\n                ...(data.floor !== undefined && { floor: data.floor }),\n                ...(data.capacity !== undefined && { capacity: data.capacity }),\n                ...(data.roomType && { roomType: data.roomType as any }),\n                ...(data.facilities !== undefined && { facilities: data.facilities }),\n                ...(data.isAvailable !== undefined && { isAvailable: data.isAvailable }),\n            },\n        });\n\n        revalidatePath(\"/admin/schedule/rooms\");\n        return { success: true, room };\n    } catch (error) {\n        console.error(\"Error updating room:\", error);\n        return { success: false, error: \"Failed to update room\" };\n    }\n}\n\n// Delete room\nexport async function deleteRoom(id: string) {\n    try {\n        await prisma.room.delete({\n            where: { id },\n        });\n\n        revalidatePath(\"/admin/schedule/rooms\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error deleting room:\", error);\n        return { success: false, error: \"Failed to delete room\" };\n    }\n}\n\n// Check room availability\nexport async function checkRoomAvailability(\n    roomId: string,\n    day: string,\n    startTime: string,\n    endTime: string,\n    excludeScheduleId?: string\n) {\n    try {\n        const conflicts = await prisma.classSchedule.findMany({\n            where: {\n                roomId,\n                day: day as any,\n                ...(excludeScheduleId && { id: { not: excludeScheduleId } }),\n                OR: [\n                    {\n                        AND: [\n                            { startTime: { lte: startTime } },\n                            { endTime: { gt: startTime } },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { startTime: { lt: endTime } },\n                            { endTime: { gte: endTime } },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { startTime: { gte: startTime } },\n                            { endTime: { lte: endTime } },\n                        ],\n                    },\n                ],\n            },\n            include: {\n                section: {\n                    include: {\n                        course: {\n                            select: {\n                                code: true,\n                                nameEn: true,\n                            },\n                        },\n                    },\n                },\n            },\n        });\n\n        return {\n            success: true,\n            isAvailable: conflicts.length === 0,\n            conflicts,\n        };\n    } catch (error) {\n        console.error(\"Error checking room availability:\", error);\n        return { success: false, error: \"Failed to check availability\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1788, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/user-instructors.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all instructors with filters\nexport async function getInstructors(filters?: {\n    employmentType?: \"FULL_TIME\" | \"PART_TIME\";\n    search?: string;\n    facultyId?: string;\n    departmentId?: string;\n}) {\n    try {\n        const where: any = {};\n\n        // Search by name\n        if (filters?.search) {\n            where.OR = [\n                { firstName: { contains: filters.search } },\n                { lastName: { contains: filters.search } },\n            ];\n        }\n\n        // Filter by faculty\n        if (filters?.facultyId) {\n            where.facultyId = filters.facultyId;\n        }\n\n        // Filter by department\n        if (filters?.departmentId) {\n            where.departmentId = filters.departmentId;\n        }\n\n        const instructors = await prisma.personnel.findMany({\n            where,\n            include: {\n                user: {\n                    select: {\n                        email: true,\n                        role: true,\n                    },\n                },\n                faculty: {\n                    select: {\n                        nameTh: true,\n                        nameEn: true,\n                    },\n                },\n                department: {\n                    select: {\n                        nameTh: true,\n                        nameEn: true,\n                    },\n                },\n                instructedSections: {\n                    select: {\n                        id: true,\n                    },\n                },\n            },\n            orderBy: {\n                user: {\n                    createdAt: \"desc\",\n                },\n            },\n        });\n\n        // Filter by role (only instructors)\n        const filteredInstructors = instructors.filter(\n            (p) => p.user.role === \"INSTRUCTOR\" || p.user.role === \"ADMIN\"\n        );\n\n        return { success: true, instructors: filteredInstructors };\n    } catch (error) {\n        console.error(\"Error fetching instructors:\", error);\n        return { success: false, error: \"Failed to fetch instructors\" };\n    }\n}\n\n// Get instructor by ID\nexport async function getInstructorById(id: string) {\n    try {\n        const instructor = await prisma.personnel.findUnique({\n            where: { id },\n            include: {\n                user: {\n                    select: {\n                        email: true,\n                        role: true,\n                    },\n                },\n                faculty: true,\n                department: true,\n                instructedSections: {\n                    include: {\n                        course: true,\n                        term: true,\n                    },\n                },\n            },\n        });\n\n        if (!instructor) {\n            return { success: false, error: \"Instructor not found\" };\n        }\n\n        return { success: true, instructor };\n    } catch (error) {\n        console.error(\"Error fetching instructor:\", error);\n        return { success: false, error: \"Failed to fetch instructor\" };\n    }\n}\n\n// Get instructor statistics\nexport async function getInstructorStats() {\n    try {\n        const allPersonnel = await prisma.personnel.findMany({\n            include: {\n                user: {\n                    select: {\n                        role: true,\n                    },\n                },\n                instructedSections: true,\n            },\n        });\n\n        const instructors = allPersonnel.filter(\n            (p) => p.user.role === \"INSTRUCTOR\" || p.user.role === \"ADMIN\"\n        );\n\n        const total = instructors.length;\n\n        // Calculate average teaching hours (assuming each section = 3 hours/week)\n        const totalSections = instructors.reduce(\n            (sum, i) => sum + i.instructedSections.length,\n            0\n        );\n        const avgTeachingHours = total > 0 ? Math.round((totalSections * 3) / total) : 0;\n\n        return {\n            success: true,\n            stats: {\n                total,\n                fullTime: 0, // TODO: Add employment type to Personnel model\n                partTime: 0,\n                avgTeachingHours,\n            },\n        };\n    } catch (error) {\n        console.error(\"Error fetching instructor stats:\", error);\n        return { success: false, error: \"Failed to fetch statistics\" };\n    }\n}\n\n// Delete instructor\nexport async function deleteInstructor(id: string) {\n    try {\n        // Check if instructor has sections\n        const sectionCount = await prisma.classSection.count({\n            where: { instructorId: id },\n        });\n\n        if (sectionCount > 0) {\n            return {\n                success: false,\n                error: \"Cannot delete instructor with assigned sections\",\n            };\n        }\n\n        await prisma.personnel.delete({\n            where: { id },\n        });\n\n        revalidatePath(\"/admin/users/instructors\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error deleting instructor:\", error);\n        return { success: false, error: \"Failed to delete instructor\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1999, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/student-group.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all student groups with filters\nexport async function getStudentGroups(filters?: {\n    programId?: string;\n    admissionYear?: number;\n    search?: string;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.admissionYear) {\n            where.admissionYear = filters.admissionYear;\n        }\n\n        if (filters?.search) {\n            where.name = { contains: filters.search };\n        }\n\n        const groups = await prisma.studentGroup.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameTh: true,\n                        nameEn: true,\n                        degreeLevel: true,\n                        faculty: {\n                            select: {\n                                code: true,\n                                nameTh: true,\n                                nameEn: true,\n                            },\n                        },\n                    },\n                },\n                advisor: {\n                    select: {\n                        id: true,\n                        firstName: true,\n                        lastName: true,\n                        title: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        students: true,\n                        sections: true,\n                    },\n                },\n            },\n            orderBy: [\n                { admissionYear: \"desc\" },\n                { program: { nameEn: \"asc\" } },\n                { name: \"asc\" },\n            ],\n        });\n\n        return { success: true, groups };\n    } catch (error) {\n        console.error(\"Error fetching student groups:\", error);\n        return { success: false, error: \"Failed to fetch student groups\" };\n    }\n}\n\n// Get a single student group by ID\nexport async function getStudentGroupById(id: string) {\n    try {\n        const group = await prisma.studentGroup.findUnique({\n            where: { id },\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameTh: true,\n                        nameEn: true,\n                        degreeLevel: true,\n                        faculty: {\n                            select: {\n                                code: true,\n                                nameTh: true,\n                                nameEn: true,\n                            },\n                        },\n                    },\n                },\n                advisor: {\n                    select: {\n                        id: true,\n                        firstName: true,\n                        lastName: true,\n                        title: true,\n                    },\n                },\n                students: {\n                    select: {\n                        id: true,\n                        studentId: true,\n                        firstName: true,\n                        lastName: true,\n                        status: true,\n                    },\n                    orderBy: { studentId: \"asc\" },\n                },\n                sections: {\n                    include: {\n                        course: {\n                            select: {\n                                code: true,\n                                nameEn: true,\n                            },\n                        },\n                        term: {\n                            select: {\n                                year: true,\n                                semester: true,\n                            },\n                        },\n                    },\n                },\n            },\n        });\n\n        if (!group) {\n            return { success: false, error: \"Student group not found\" };\n        }\n\n        return { success: true, group };\n    } catch (error) {\n        console.error(\"Error fetching student group:\", error);\n        return { success: false, error: \"Failed to fetch student group\" };\n    }\n}\n\n// Get timetable/schedules for a specific student group\nexport async function getGroupTimetable(groupId: string) {\n    try {\n        // Get all sections assigned to this group\n        const group = await prisma.studentGroup.findUnique({\n            where: { id: groupId },\n            include: {\n                sections: {\n                    select: { id: true }\n                }\n            }\n        });\n\n        if (!group) {\n            return { success: false, error: \"Student group not found\" };\n        }\n\n        const sectionIds = group.sections.map(s => s.id);\n\n        // Get all schedules for these sections\n        const schedules = await prisma.classSchedule.findMany({\n            where: {\n                sectionId: { in: sectionIds }\n            },\n            include: {\n                section: {\n                    include: {\n                        course: {\n                            select: {\n                                code: true,\n                                nameEn: true,\n                                nameTh: true,\n                            }\n                        }\n                    }\n                },\n                course: {\n                    select: {\n                        code: true,\n                        nameEn: true,\n                        nameTh: true,\n                    }\n                },\n                room: {\n                    select: {\n                        code: true,\n                        name: true,\n                        building: true,\n                    }\n                },\n                instructor: {\n                    select: {\n                        firstName: true,\n                        lastName: true,\n                        title: true,\n                    }\n                },\n                term: {\n                    select: {\n                        year: true,\n                        semester: true,\n                    }\n                }\n            },\n            orderBy: [\n                { day: 'asc' },\n                { startTime: 'asc' }\n            ]\n        });\n\n        return { success: true, schedules };\n    } catch (error) {\n        console.error(\"Error fetching group timetable:\", error);\n        return { success: false, error: \"Failed to fetch timetable\" };\n    }\n}\n\n// Create a new student group\nexport async function createStudentGroup(data: {\n    name: string;\n    admissionYear: number;\n    programId: string;\n    advisorId?: string;\n}) {\n    try {\n        // Check for duplicate\n        const existing = await prisma.studentGroup.findUnique({\n            where: {\n                programId_admissionYear_name: {\n                    programId: data.programId,\n                    admissionYear: data.admissionYear,\n                    name: data.name,\n                },\n            },\n        });\n\n        if (existing) {\n            return {\n                success: false,\n                error: \"A group with this name already exists for this program and year\",\n            };\n        }\n\n        const group = await prisma.studentGroup.create({\n            data: {\n                name: data.name,\n                admissionYear: data.admissionYear,\n                programId: data.programId,\n                advisorId: data.advisorId || null,\n            },\n            include: {\n                program: true,\n                advisor: true,\n            },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        return { success: true, group };\n    } catch (error) {\n        console.error(\"Error creating student group:\", error);\n        return { success: false, error: \"Failed to create student group\" };\n    }\n}\n\n// Update a student group\nexport async function updateStudentGroup(\n    id: string,\n    data: {\n        name?: string;\n        admissionYear?: number;\n        programId?: string;\n        advisorId?: string | null;\n    }\n) {\n    try {\n        // If changing name/year/program, check for duplicate\n        if (data.name || data.admissionYear || data.programId) {\n            const current = await prisma.studentGroup.findUnique({\n                where: { id },\n            });\n\n            if (current) {\n                const checkData = {\n                    programId: data.programId || current.programId,\n                    admissionYear: data.admissionYear || current.admissionYear,\n                    name: data.name || current.name,\n                };\n\n                const existing = await prisma.studentGroup.findFirst({\n                    where: {\n                        AND: [\n                            { id: { not: id } },\n                            { programId: checkData.programId },\n                            { admissionYear: checkData.admissionYear },\n                            { name: checkData.name },\n                        ],\n                    },\n                });\n\n                if (existing) {\n                    return {\n                        success: false,\n                        error: \"A group with this name already exists for this program and year\",\n                    };\n                }\n            }\n        }\n\n        const group = await prisma.studentGroup.update({\n            where: { id },\n            data: {\n                name: data.name,\n                admissionYear: data.admissionYear,\n                programId: data.programId,\n                advisorId: data.advisorId,\n            },\n            include: {\n                program: true,\n                advisor: true,\n            },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        revalidatePath(`/admin/academic/groups/${id}`);\n        return { success: true, group };\n    } catch (error) {\n        console.error(\"Error updating student group:\", error);\n        return { success: false, error: \"Failed to update student group\" };\n    }\n}\n\n// Delete a student group\nexport async function deleteStudentGroup(id: string) {\n    try {\n        // Check if group has students\n        const group = await prisma.studentGroup.findUnique({\n            where: { id },\n            include: {\n                _count: {\n                    select: {\n                        students: true,\n                        sections: true,\n                    },\n                },\n            },\n        });\n\n        if (!group) {\n            return { success: false, error: \"Student group not found\" };\n        }\n\n        if (group._count.students > 0) {\n            return {\n                success: false,\n                error: `Cannot delete group with ${group._count.students} student(s). Please reassign them first.`,\n            };\n        }\n\n        await prisma.studentGroup.delete({\n            where: { id },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error deleting student group:\", error);\n        return { success: false, error: \"Failed to delete student group\" };\n    }\n}\n\n// Assign students to a group\nexport async function assignStudentsToGroup(\n    groupId: string,\n    studentIds: string[]\n) {\n    try {\n        await prisma.student.updateMany({\n            where: { id: { in: studentIds } },\n            data: { studentGroupId: groupId },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        revalidatePath(`/admin/academic/groups/${groupId}`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning students to group:\", error);\n        return { success: false, error: \"Failed to assign students\" };\n    }\n}\n\n// Remove students from a group\nexport async function removeStudentsFromGroup(studentIds: string[]) {\n    try {\n        await prisma.student.updateMany({\n            where: { id: { in: studentIds } },\n            data: { studentGroupId: null },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error removing students from group:\", error);\n        return { success: false, error: \"Failed to remove students\" };\n    }\n}\n\n// Get students not assigned to any group (for assignment)\nexport async function getUnassignedStudents(filters?: {\n    programId?: string;\n    admissionYear?: number;\n}) {\n    try {\n        const where: any = {\n            studentGroupId: null,\n        };\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.admissionYear) {\n            where.admissionYear = filters.admissionYear;\n        }\n\n        const students = await prisma.student.findMany({\n            where,\n            select: {\n                id: true,\n                studentId: true,\n                firstName: true,\n                lastName: true,\n                admissionYear: true,\n                program: {\n                    select: {\n                        nameEn: true,\n                    },\n                },\n            },\n            orderBy: { studentId: \"asc\" },\n        });\n\n        return { success: true, students };\n    } catch (error) {\n        console.error(\"Error fetching unassigned students:\", error);\n        return { success: false, error: \"Failed to fetch students\" };\n    }\n}\n\n// Calculate year level from admission year (internal helper function)\nfunction calculateYearLevel(admissionYear: number): number {\n    const currentYear = new Date().getFullYear();\n    const currentMonth = new Date().getMonth(); // 0-11\n\n    // Academic year typically starts in August (month 7)\n    // If we're past August, we're in the new academic year\n    const academicYear = currentMonth >= 7 ? currentYear : currentYear - 1;\n\n    // +1 because first year students have yearLevel = 1\n    return academicYear - admissionYear + 1;\n}\n\n// Get student groups with year level calculated\nexport async function getStudentGroupsWithYearLevel(filters?: {\n    programId?: string;\n    yearLevel?: number;\n}) {\n    const result = await getStudentGroups(filters);\n\n    if (!result.success || !result.groups) {\n        return result;\n    }\n\n    const groupsWithYearLevel = result.groups.map((group) => ({\n        ...group,\n        yearLevel: calculateYearLevel(group.admissionYear),\n    }));\n\n    // Filter by year level if specified\n    if (filters?.yearLevel) {\n        return {\n            success: true,\n            groups: groupsWithYearLevel.filter(\n                (g) => g.yearLevel === filters.yearLevel\n            ),\n        };\n    }\n\n    return { success: true, groups: groupsWithYearLevel };\n}\n\n// Add a class section to a student group\nexport async function addSectionToGroup(groupId: string, sectionId: string) {\n    try {\n        await (prisma.studentGroup.update as any)({\n            where: { id: groupId },\n            data: {\n                sections: {\n                    connect: { id: sectionId }\n                }\n            }\n        });\n\n        revalidatePath(`/admin/academic/groups/${groupId}`);\n        revalidatePath(`/admin/academic/groups/${groupId}/schedule`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error adding section to group:\", error);\n        return { success: false, error: \"Failed to add section to group\" };\n    }\n}\n\n// Remove a class section from a student group\nexport async function removeSectionFromGroup(groupId: string, sectionId: string) {\n    try {\n        await (prisma.studentGroup.update as any)({\n            where: { id: groupId },\n            data: {\n                sections: {\n                    disconnect: { id: sectionId }\n                }\n            }\n        });\n\n        revalidatePath(`/admin/academic/groups/${groupId}`);\n        revalidatePath(`/admin/academic/groups/${groupId}/schedule`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error removing section from group:\", error);\n        return { success: false, error: \"Failed to remove section from group\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2639, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/schedule-timetable.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all class schedules with filters\nexport async function getClassSchedules(filters?: {\n    search?: string;\n    termId?: string;\n    day?: string;\n    instructorId?: string;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.termId) {\n            where.termId = filters.termId;\n        }\n\n        if (filters?.day && filters.day !== \"ALL\") {\n            where.day = filters.day;\n        }\n\n        if (filters?.instructorId) {\n            where.instructorId = filters.instructorId;\n        }\n\n        if (filters?.search) {\n            where.OR = [\n                {\n                    course: {\n                        OR: [\n                            { code: { contains: filters.search } },\n                            { nameEn: { contains: filters.search } },\n                        ],\n                    },\n                },\n                {\n                    instructor: {\n                        OR: [\n                            { firstName: { contains: filters.search } },\n                            { lastName: { contains: filters.search } },\n                        ],\n                    },\n                },\n            ];\n        }\n\n        const schedules = await prisma.classSchedule.findMany({\n            where,\n            include: {\n                section: {\n                    include: {\n                        course: {\n                            select: {\n                                code: true,\n                                nameEn: true,\n                                nameTh: true,\n                            },\n                        },\n                        instructor: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                            },\n                        },\n                    },\n                },\n                room: {\n                    select: {\n                        code: true,\n                        name: true,\n                        building: true,\n                    },\n                },\n                course: {\n                    select: {\n                        code: true,\n                        nameEn: true,\n                    },\n                },\n                instructor: {\n                    select: {\n                        firstName: true,\n                        lastName: true,\n                    },\n                },\n                term: {\n                    select: {\n                        year: true,\n                        semester: true,\n                    },\n                },\n            },\n            orderBy: [\n                { day: \"asc\" },\n                { startTime: \"asc\" },\n            ],\n        });\n\n        return { success: true, schedules };\n    } catch (error) {\n        console.error(\"Error fetching schedules:\", error);\n        return { success: false, error: \"Failed to fetch schedules\" };\n    }\n}\n\n// Get schedule statistics\nexport async function getScheduleStats(termId?: string) {\n    try {\n        const where = termId ? { termId } : {};\n\n        const [totalSchedules, activeCourses, roomsUsed] = await Promise.all([\n            prisma.classSchedule.count({ where }),\n            prisma.classSchedule.findMany({\n                where,\n                distinct: [\"courseId\"],\n                select: { courseId: true },\n            }),\n            prisma.classSchedule.findMany({\n                where,\n                distinct: [\"roomId\"],\n                select: { roomId: true },\n            }),\n        ]);\n\n        // Get current week's schedules\n        const thisWeek = await prisma.classSchedule.count({\n            where: {\n                ...where,\n                // Add date range filter if needed\n            },\n        });\n\n        return {\n            success: true,\n            stats: {\n                totalSchedules,\n                activeCourses: activeCourses.length,\n                roomsUsed: roomsUsed.filter((r) => r.roomId).length,\n                thisWeek,\n            },\n        };\n    } catch (error) {\n        console.error(\"Error fetching schedule stats:\", error);\n        return { success: false, error: \"Failed to fetch statistics\" };\n    }\n}\n\n// Get schedule by ID\nexport async function getScheduleById(id: string) {\n    try {\n        const schedule = await prisma.classSchedule.findUnique({\n            where: { id },\n            include: {\n                section: {\n                    include: {\n                        course: true,\n                        instructor: true,\n                        enrollments: {\n                            include: {\n                                student: {\n                                    select: {\n                                        studentId: true,\n                                        firstName: true,\n                                        lastName: true,\n                                    },\n                                },\n                            },\n                        },\n                    },\n                },\n                room: true,\n                course: true,\n                instructor: true,\n                term: true,\n            },\n        });\n\n        if (!schedule) {\n            return { success: false, error: \"Schedule not found\" };\n        }\n\n        return { success: true, schedule };\n    } catch (error) {\n        console.error(\"Error fetching schedule:\", error);\n        return { success: false, error: \"Failed to fetch schedule\" };\n    }\n}\n\n// Create class schedule\nexport async function createClassSchedule(data: {\n    sectionId: string;\n    day: string;\n    startTime: string;\n    endTime: string;\n    roomId?: string;\n    courseId?: string;\n    instructorId?: string;\n    termId?: string;\n    studentGroupIds?: string[];\n}) {\n    try {\n        // Check for conflicts\n        if (data.roomId) {\n            const roomConflicts = await prisma.classSchedule.findMany({\n                where: {\n                    roomId: data.roomId,\n                    day: data.day as any,\n                    OR: [\n                        {\n                            AND: [\n                                { startTime: { lte: data.startTime } },\n                                { endTime: { gt: data.startTime } },\n                            ],\n                        },\n                        {\n                            AND: [\n                                { startTime: { lt: data.endTime } },\n                                { endTime: { gte: data.endTime } },\n                            ],\n                        },\n                    ],\n                },\n            });\n\n            if (roomConflicts.length > 0) {\n                return {\n                    success: false,\n                    error: \"Room is already booked for this time slot\",\n                };\n            }\n        }\n\n        // Check for student group schedule conflicts (if groups are specified)\n        if (data.studentGroupIds && data.studentGroupIds.length > 0) {\n            // Find existing schedules for the same groups at the same time\n            const groupConflicts = await (prisma.classSchedule.findMany as any)({\n                where: {\n                    day: data.day as any,\n                    section: {\n                        studentGroups: {\n                            some: {\n                                id: { in: data.studentGroupIds }\n                            }\n                        }\n                    },\n                    OR: [\n                        {\n                            AND: [\n                                { startTime: { lte: data.startTime } },\n                                { endTime: { gt: data.startTime } },\n                            ],\n                        },\n                        {\n                            AND: [\n                                { startTime: { lt: data.endTime } },\n                                { endTime: { gte: data.endTime } },\n                            ],\n                        },\n                    ],\n                },\n                include: {\n                    course: { select: { code: true, nameEn: true } },\n                    section: {\n                        include: {\n                            studentGroups: { select: { name: true } }\n                        }\n                    }\n                }\n            });\n\n            if (groupConflicts.length > 0) {\n                const conflictInfo = groupConflicts[0] as any;\n                return {\n                    success: false,\n                    error: `Schedule conflict! The selected student group(s) already have \"${conflictInfo?.course?.code || 'another class'}\" at this time.`,\n                };\n            }\n        }\n\n        // Create the schedule\n        const schedule = await prisma.classSchedule.create({\n            data: {\n                sectionId: data.sectionId,\n                day: data.day as any,\n                startTime: data.startTime,\n                endTime: data.endTime,\n                ...(data.roomId && { roomId: data.roomId }),\n                ...(data.courseId && { courseId: data.courseId }),\n                ...(data.instructorId && { instructorId: data.instructorId }),\n                ...(data.termId && { termId: data.termId }),\n            },\n        });\n\n        // If student groups are specified, connect them to the section\n        if (data.studentGroupIds && data.studentGroupIds.length > 0) {\n            await (prisma.classSection.update as any)({\n                where: { id: data.sectionId },\n                data: {\n                    studentGroups: {\n                        connect: data.studentGroupIds.map(id => ({ id }))\n                    }\n                }\n            });\n        }\n\n        revalidatePath(\"/admin/schedule/timetable\");\n        return { success: true, schedule };\n    } catch (error) {\n        console.error(\"Error creating schedule:\", error);\n        return { success: false, error: \"Failed to create schedule\" };\n    }\n}\n\n// Update class schedule\nexport async function updateClassSchedule(\n    id: string,\n    data: {\n        day?: string;\n        startTime?: string;\n        endTime?: string;\n        roomId?: string;\n    }\n) {\n    try {\n        const schedule = await prisma.classSchedule.update({\n            where: { id },\n            data: {\n                ...(data.day && { day: data.day as any }),\n                ...(data.startTime && { startTime: data.startTime }),\n                ...(data.endTime && { endTime: data.endTime }),\n                ...(data.roomId !== undefined && { roomId: data.roomId }),\n            },\n        });\n\n        revalidatePath(\"/admin/schedule/timetable\");\n        return { success: true, schedule };\n    } catch (error) {\n        console.error(\"Error updating schedule:\", error);\n        return { success: false, error: \"Failed to update schedule\" };\n    }\n}\n\n// Delete class schedule\nexport async function deleteClassSchedule(id: string) {\n    try {\n        await prisma.classSchedule.delete({\n            where: { id },\n        });\n\n        revalidatePath(\"/admin/schedule/timetable\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error deleting schedule:\", error);\n        return { success: false, error: \"Failed to delete schedule\" };\n    }\n}\n\n// Get weekly timetable\nexport async function getWeeklyTimetable(termId?: string) {\n    try {\n        const where = termId ? { termId } : {};\n\n        const schedules = await prisma.classSchedule.findMany({\n            where,\n            include: {\n                section: {\n                    include: {\n                        course: {\n                            select: {\n                                code: true,\n                                nameEn: true,\n                            },\n                        },\n                    },\n                },\n                room: {\n                    select: {\n                        code: true,\n                    },\n                },\n                course: {\n                    select: {\n                        code: true,\n                        nameEn: true,\n                    },\n                },\n            },\n            orderBy: [\n                { day: \"asc\" },\n                { startTime: \"asc\" },\n            ],\n        });\n\n        // Group by day and time\n        const timetable: Record<string, any[]> = {\n            MONDAY: [],\n            TUESDAY: [],\n            WEDNESDAY: [],\n            THURSDAY: [],\n            FRIDAY: [],\n            SATURDAY: [],\n            SUNDAY: [],\n        };\n\n        schedules.forEach((schedule) => {\n            if (timetable[schedule.day]) {\n                timetable[schedule.day].push(schedule);\n            }\n        });\n\n        return { success: true, timetable };\n    } catch (error) {\n        console.error(\"Error fetching weekly timetable:\", error);\n        return { success: false, error: \"Failed to fetch timetable\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3184, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/.next-internal/server/app/admin/schedule/timetable/create/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getTranslations as '0048abae6b6c31cf4a1031d6650cdc9969ec5f17a2'} from 'ACTIONS_MODULE0'\nexport {logoutAdmin as '000f7a1cb658a9a6741f035a805f2983db08d56808'} from 'ACTIONS_MODULE1'\nexport {getSystemSettings as '0042d76f240ee2a93513d3b83c0a780d6960763f9a'} from 'ACTIONS_MODULE2'\nexport {getAcademicTerms as '00a1fd4383e6c7b044e32761a433241d44a0cc2799'} from 'ACTIONS_MODULE3'\nexport {deleteClassSection as '405df935337fa3c97bb2b1d0e0c65bc101e9c11d5b'} from 'ACTIONS_MODULE3'\nexport {createClassSection as '40b0fa9e872708e5bb0a074f1dec6e32a85267a341'} from 'ACTIONS_MODULE3'\nexport {getClassSections as '40d04cfb7840d65ed5621248993e49eb17e7661a40'} from 'ACTIONS_MODULE3'\nexport {createAcademicTerm as '40ff16435c2a7e03d3da33034d775e1c2930a2241b'} from 'ACTIONS_MODULE3'\nexport {getRoomStats as '00f1477430444d03e28f78f2ecff887a02b1315377'} from 'ACTIONS_MODULE4'\nexport {getRoomById as '400773fb3e715c534af1f1839c720a8d18b96f9799'} from 'ACTIONS_MODULE4'\nexport {getRooms as '40526fbe49fbd5c36f5c9380bc7f2fa6cc01d3bef6'} from 'ACTIONS_MODULE4'\nexport {createRoom as '4072e8197f0f37b44486735a334be462cf6b5bcf24'} from 'ACTIONS_MODULE4'\nexport {deleteRoom as '407c3ba9d2d12beaf96c32d7714d60209ac8c91a8c'} from 'ACTIONS_MODULE4'\nexport {updateRoom as '60dd67f2f191f31405ff07ca4ef5384bfade7e4b75'} from 'ACTIONS_MODULE4'\nexport {checkRoomAvailability as '7caa8f330e9518e051d2e1a00ea73423d893a9bdb7'} from 'ACTIONS_MODULE4'\nexport {getInstructorStats as '00c6864fcb4b07e60f02a72f68ae5fa4c423129054'} from 'ACTIONS_MODULE5'\nexport {deleteInstructor as '400a3e532e7cf1cb18583c94fc3832adfc252ea15d'} from 'ACTIONS_MODULE5'\nexport {getInstructorById as '404ce9b1d8a5a4965230428e679315c7e2160621a2'} from 'ACTIONS_MODULE5'\nexport {getInstructors as '4059d0c789086449b36698910c0668c7d569850cce'} from 'ACTIONS_MODULE5'\nexport {getStudentGroupById as '402afe96257a83a6508e80cfd3fff0130565464bae'} from 'ACTIONS_MODULE6'\nexport {getStudentGroupsWithYearLevel as '402dcba9ecc50d7de93bbcd7fce3af4e6781e344ba'} from 'ACTIONS_MODULE6'\nexport {getStudentGroups as '4050208e4d90398286114e1600f3ebd3292651face'} from 'ACTIONS_MODULE6'\nexport {createStudentGroup as '405b92423cdb1029387bdca05b54b84bcec2b67284'} from 'ACTIONS_MODULE6'\nexport {deleteStudentGroup as '406c8db0422fcc6cff2a628e110208ab7992b75e0f'} from 'ACTIONS_MODULE6'\nexport {getGroupTimetable as '40707d3c53fce3a7da3a9c07cedea7b0a45bb68300'} from 'ACTIONS_MODULE6'\nexport {removeStudentsFromGroup as '4087a1dfefee6e3aed54e57c9dc0c531f3f1e4f957'} from 'ACTIONS_MODULE6'\nexport {getUnassignedStudents as '40a4f42c7df4213b3ad8a0efbb523470789243cae0'} from 'ACTIONS_MODULE6'\nexport {updateStudentGroup as '604e6b0590d36314a5115a7c3e516f47a1fcc2737d'} from 'ACTIONS_MODULE6'\nexport {addSectionToGroup as '60c1dbacac3e32b9113422045facf7291516d8ff73'} from 'ACTIONS_MODULE6'\nexport {assignStudentsToGroup as '60cdc3b332beb1c0f54c33661867f20630d31d3def'} from 'ACTIONS_MODULE6'\nexport {removeSectionFromGroup as '60f3514fb2f049bcbdaf4cf8fa96865ee05bd05134'} from 'ACTIONS_MODULE6'\nexport {createClassSchedule as '4073dbbda55cac31da933c408c09372119de61ad76'} from 'ACTIONS_MODULE7'\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AAKA;AAOA;AAIA;AAYA"}}]
}