{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/student-group.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all student groups with filters\nexport async function getStudentGroups(filters?: {\n    programId?: string;\n    admissionYear?: number;\n    search?: string;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.admissionYear) {\n            where.admissionYear = filters.admissionYear;\n        }\n\n        if (filters?.search) {\n            where.name = { contains: filters.search };\n        }\n\n        const groups = await prisma.studentGroup.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameTh: true,\n                        nameEn: true,\n                        degreeLevel: true,\n                        faculty: {\n                            select: {\n                                code: true,\n                                nameTh: true,\n                                nameEn: true,\n                            },\n                        },\n                    },\n                },\n                advisor: {\n                    select: {\n                        id: true,\n                        firstName: true,\n                        lastName: true,\n                        title: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        students: true,\n                        sections: true,\n                    },\n                },\n            },\n            orderBy: [\n                { admissionYear: \"desc\" },\n                { program: { nameEn: \"asc\" } },\n                { name: \"asc\" },\n            ],\n        });\n\n        return { success: true, groups };\n    } catch (error) {\n        console.error(\"Error fetching student groups:\", error);\n        return { success: false, error: \"Failed to fetch student groups\" };\n    }\n}\n\n// Get a single student group by ID\nexport async function getStudentGroupById(id: string) {\n    try {\n        const group = await prisma.studentGroup.findUnique({\n            where: { id },\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameTh: true,\n                        nameEn: true,\n                        degreeLevel: true,\n                        faculty: {\n                            select: {\n                                code: true,\n                                nameTh: true,\n                                nameEn: true,\n                            },\n                        },\n                    },\n                },\n                advisor: {\n                    select: {\n                        id: true,\n                        firstName: true,\n                        lastName: true,\n                        title: true,\n                    },\n                },\n                students: {\n                    select: {\n                        id: true,\n                        studentId: true,\n                        firstName: true,\n                        lastName: true,\n                        status: true,\n                    },\n                    orderBy: { studentId: \"asc\" },\n                },\n                sections: {\n                    include: {\n                        course: {\n                            select: {\n                                code: true,\n                                nameEn: true,\n                            },\n                        },\n                        term: {\n                            select: {\n                                year: true,\n                                semester: true,\n                            },\n                        },\n                    },\n                },\n            },\n        });\n\n        if (!group) {\n            return { success: false, error: \"Student group not found\" };\n        }\n\n        return { success: true, group };\n    } catch (error) {\n        console.error(\"Error fetching student group:\", error);\n        return { success: false, error: \"Failed to fetch student group\" };\n    }\n}\n\n// Get timetable/schedules for a specific student group\nexport async function getGroupTimetable(groupId: string) {\n    try {\n        // Get all sections assigned to this group\n        const group = await prisma.studentGroup.findUnique({\n            where: { id: groupId },\n            include: {\n                sections: {\n                    select: { id: true }\n                }\n            }\n        });\n\n        if (!group) {\n            return { success: false, error: \"Student group not found\" };\n        }\n\n        const sectionIds = group.sections.map(s => s.id);\n\n        // Get all schedules for these sections\n        const schedules = await prisma.classSchedule.findMany({\n            where: {\n                sectionId: { in: sectionIds }\n            },\n            include: {\n                section: {\n                    include: {\n                        course: {\n                            select: {\n                                code: true,\n                                nameEn: true,\n                                nameTh: true,\n                            }\n                        }\n                    }\n                },\n                course: {\n                    select: {\n                        code: true,\n                        nameEn: true,\n                        nameTh: true,\n                    }\n                },\n                room: {\n                    select: {\n                        code: true,\n                        name: true,\n                        building: true,\n                    }\n                },\n                instructor: {\n                    select: {\n                        firstName: true,\n                        lastName: true,\n                        title: true,\n                    }\n                },\n                term: {\n                    select: {\n                        year: true,\n                        semester: true,\n                    }\n                }\n            },\n            orderBy: [\n                { day: 'asc' },\n                { startTime: 'asc' }\n            ]\n        });\n\n        return { success: true, schedules };\n    } catch (error) {\n        console.error(\"Error fetching group timetable:\", error);\n        return { success: false, error: \"Failed to fetch timetable\" };\n    }\n}\n\n// Create a new student group\nexport async function createStudentGroup(data: {\n    name: string;\n    admissionYear: number;\n    programId: string;\n    advisorId?: string;\n}) {\n    try {\n        // Check for duplicate\n        const existing = await prisma.studentGroup.findUnique({\n            where: {\n                programId_admissionYear_name: {\n                    programId: data.programId,\n                    admissionYear: data.admissionYear,\n                    name: data.name,\n                },\n            },\n        });\n\n        if (existing) {\n            return {\n                success: false,\n                error: \"A group with this name already exists for this program and year\",\n            };\n        }\n\n        const group = await prisma.studentGroup.create({\n            data: {\n                name: data.name,\n                admissionYear: data.admissionYear,\n                programId: data.programId,\n                advisorId: data.advisorId || null,\n            },\n            include: {\n                program: true,\n                advisor: true,\n            },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        return { success: true, group };\n    } catch (error) {\n        console.error(\"Error creating student group:\", error);\n        return { success: false, error: \"Failed to create student group\" };\n    }\n}\n\n// Update a student group\nexport async function updateStudentGroup(\n    id: string,\n    data: {\n        name?: string;\n        admissionYear?: number;\n        programId?: string;\n        advisorId?: string | null;\n    }\n) {\n    try {\n        // If changing name/year/program, check for duplicate\n        if (data.name || data.admissionYear || data.programId) {\n            const current = await prisma.studentGroup.findUnique({\n                where: { id },\n            });\n\n            if (current) {\n                const checkData = {\n                    programId: data.programId || current.programId,\n                    admissionYear: data.admissionYear || current.admissionYear,\n                    name: data.name || current.name,\n                };\n\n                const existing = await prisma.studentGroup.findFirst({\n                    where: {\n                        AND: [\n                            { id: { not: id } },\n                            { programId: checkData.programId },\n                            { admissionYear: checkData.admissionYear },\n                            { name: checkData.name },\n                        ],\n                    },\n                });\n\n                if (existing) {\n                    return {\n                        success: false,\n                        error: \"A group with this name already exists for this program and year\",\n                    };\n                }\n            }\n        }\n\n        const group = await prisma.studentGroup.update({\n            where: { id },\n            data: {\n                name: data.name,\n                admissionYear: data.admissionYear,\n                programId: data.programId,\n                advisorId: data.advisorId,\n            },\n            include: {\n                program: true,\n                advisor: true,\n            },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        revalidatePath(`/admin/academic/groups/${id}`);\n        return { success: true, group };\n    } catch (error) {\n        console.error(\"Error updating student group:\", error);\n        return { success: false, error: \"Failed to update student group\" };\n    }\n}\n\n// Delete a student group\nexport async function deleteStudentGroup(id: string) {\n    try {\n        // Check if group has students\n        const group = await prisma.studentGroup.findUnique({\n            where: { id },\n            include: {\n                _count: {\n                    select: {\n                        students: true,\n                        sections: true,\n                    },\n                },\n            },\n        });\n\n        if (!group) {\n            return { success: false, error: \"Student group not found\" };\n        }\n\n        if (group._count.students > 0) {\n            return {\n                success: false,\n                error: `Cannot delete group with ${group._count.students} student(s). Please reassign them first.`,\n            };\n        }\n\n        await prisma.studentGroup.delete({\n            where: { id },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error deleting student group:\", error);\n        return { success: false, error: \"Failed to delete student group\" };\n    }\n}\n\n// Assign students to a group\nexport async function assignStudentsToGroup(\n    groupId: string,\n    studentIds: string[]\n) {\n    try {\n        await prisma.student.updateMany({\n            where: { id: { in: studentIds } },\n            data: { studentGroupId: groupId },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        revalidatePath(`/admin/academic/groups/${groupId}`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning students to group:\", error);\n        return { success: false, error: \"Failed to assign students\" };\n    }\n}\n\n// Remove students from a group\nexport async function removeStudentsFromGroup(studentIds: string[]) {\n    try {\n        await prisma.student.updateMany({\n            where: { id: { in: studentIds } },\n            data: { studentGroupId: null },\n        });\n\n        revalidatePath(\"/admin/academic/groups\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error removing students from group:\", error);\n        return { success: false, error: \"Failed to remove students\" };\n    }\n}\n\n// Get students not assigned to any group (for assignment)\nexport async function getUnassignedStudents(filters?: {\n    programId?: string;\n    admissionYear?: number;\n}) {\n    try {\n        const where: any = {\n            studentGroupId: null,\n        };\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.admissionYear) {\n            where.admissionYear = filters.admissionYear;\n        }\n\n        const students = await prisma.student.findMany({\n            where,\n            select: {\n                id: true,\n                studentId: true,\n                firstName: true,\n                lastName: true,\n                admissionYear: true,\n                program: {\n                    select: {\n                        nameEn: true,\n                    },\n                },\n            },\n            orderBy: { studentId: \"asc\" },\n        });\n\n        return { success: true, students };\n    } catch (error) {\n        console.error(\"Error fetching unassigned students:\", error);\n        return { success: false, error: \"Failed to fetch students\" };\n    }\n}\n\n// Calculate year level from admission year (internal helper function)\nfunction calculateYearLevel(admissionYear: number): number {\n    const currentYear = new Date().getFullYear();\n    const currentMonth = new Date().getMonth(); // 0-11\n\n    // Academic year typically starts in August (month 7)\n    // If we're past August, we're in the new academic year\n    const academicYear = currentMonth >= 7 ? currentYear : currentYear - 1;\n\n    // +1 because first year students have yearLevel = 1\n    return academicYear - admissionYear + 1;\n}\n\n// Get student groups with year level calculated\nexport async function getStudentGroupsWithYearLevel(filters?: {\n    programId?: string;\n    yearLevel?: number;\n}) {\n    const result = await getStudentGroups(filters);\n\n    if (!result.success || !result.groups) {\n        return result;\n    }\n\n    const groupsWithYearLevel = result.groups.map((group) => ({\n        ...group,\n        yearLevel: calculateYearLevel(group.admissionYear),\n    }));\n\n    // Filter by year level if specified\n    if (filters?.yearLevel) {\n        return {\n            success: true,\n            groups: groupsWithYearLevel.filter(\n                (g) => g.yearLevel === filters.yearLevel\n            ),\n        };\n    }\n\n    return { success: true, groups: groupsWithYearLevel };\n}\n\n// Add a class section to a student group\nexport async function addSectionToGroup(groupId: string, sectionId: string) {\n    try {\n        await (prisma.studentGroup.update as any)({\n            where: { id: groupId },\n            data: {\n                sections: {\n                    connect: { id: sectionId }\n                }\n            }\n        });\n\n        revalidatePath(`/admin/academic/groups/${groupId}`);\n        revalidatePath(`/admin/academic/groups/${groupId}/schedule`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error adding section to group:\", error);\n        return { success: false, error: \"Failed to add section to group\" };\n    }\n}\n\n// Remove a class section from a student group\nexport async function removeSectionFromGroup(groupId: string, sectionId: string) {\n    try {\n        await (prisma.studentGroup.update as any)({\n            where: { id: groupId },\n            data: {\n                sections: {\n                    disconnect: { id: sectionId }\n                }\n            }\n        });\n\n        revalidatePath(`/admin/academic/groups/${groupId}`);\n        revalidatePath(`/admin/academic/groups/${groupId}/schedule`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error removing section from group:\", error);\n        return { success: false, error: \"Failed to remove section from group\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA8UsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/app/admin/academic/groups/delete-group-button.tsx"],"sourcesContent":["\"use client\";\n\nimport { deleteStudentGroup } from \"@/actions/student-group\";\nimport { Trash2 } from \"lucide-react\";\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\n\ninterface DeleteGroupButtonProps {\n    groupId: string;\n    groupName: string;\n    studentCount: number;\n}\n\nexport function DeleteGroupButton({ groupId, groupName, studentCount }: DeleteGroupButtonProps) {\n    const router = useRouter();\n    const [isDeleting, setIsDeleting] = useState(false);\n    const [showConfirm, setShowConfirm] = useState(false);\n\n    async function handleDelete() {\n        setIsDeleting(true);\n        const result = await deleteStudentGroup(groupId);\n\n        if (result.success) {\n            router.refresh();\n        } else {\n            alert(result.error);\n        }\n\n        setIsDeleting(false);\n        setShowConfirm(false);\n    }\n\n    if (studentCount > 0) {\n        return (\n            <button\n                disabled\n                className=\"cursor-not-allowed rounded p-1 text-gray-300\"\n                title=\"Cannot delete group with students\"\n            >\n                <Trash2 className=\"h-4 w-4\" />\n            </button>\n        );\n    }\n\n    return (\n        <>\n            <button\n                onClick={() => setShowConfirm(true)}\n                className=\"rounded p-1 text-gray-400 hover:bg-red-50 hover:text-red-600\"\n            >\n                <Trash2 className=\"h-4 w-4\" />\n            </button>\n\n            {showConfirm && (\n                <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50\">\n                    <div className=\"w-full max-w-md rounded-lg bg-white p-6 shadow-xl\">\n                        <h3 className=\"text-lg font-semibold text-gray-900\">\n                            Delete Student Group\n                        </h3>\n                        <p className=\"mt-2 text-sm text-gray-500\">\n                            Are you sure you want to delete &quot;{groupName}&quot;? This action cannot be\n                            undone.\n                        </p>\n                        <div className=\"mt-4 flex justify-end gap-3\">\n                            <button\n                                onClick={() => setShowConfirm(false)}\n                                className=\"rounded-md border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50\"\n                                disabled={isDeleting}\n                            >\n                                Cancel\n                            </button>\n                            <button\n                                onClick={handleDelete}\n                                className=\"rounded-md bg-red-600 px-4 py-2 text-sm font-medium text-white hover:bg-red-700\"\n                                disabled={isDeleting}\n                            >\n                                {isDeleting ? \"Deleting...\" : \"Delete\"}\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            )}\n        </>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAaO,SAAS,kBAAkB,EAAE,OAAO,EAAE,SAAS,EAAE,YAAY,EAA0B;IAC1F,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAC7C,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,iNAAQ,EAAC;IAE/C,eAAe;QACX,cAAc;QACd,MAAM,SAAS,MAAM,IAAA,oLAAkB,EAAC;QAExC,IAAI,OAAO,OAAO,EAAE;YAChB,OAAO,OAAO;QAClB,OAAO;YACH,MAAM,OAAO,KAAK;QACtB;QAEA,cAAc;QACd,eAAe;IACnB;IAEA,IAAI,eAAe,GAAG;QAClB,qBACI,8OAAC;YACG,QAAQ;YACR,WAAU;YACV,OAAM;sBAEN,cAAA,8OAAC,oNAAM;gBAAC,WAAU;;;;;;;;;;;IAG9B;IAEA,qBACI;;0BACI,8OAAC;gBACG,SAAS,IAAM,eAAe;gBAC9B,WAAU;0BAEV,cAAA,8OAAC,oNAAM;oBAAC,WAAU;;;;;;;;;;;YAGrB,6BACG,8OAAC;gBAAI,WAAU;0BACX,cAAA,8OAAC;oBAAI,WAAU;;sCACX,8OAAC;4BAAG,WAAU;sCAAsC;;;;;;sCAGpD,8OAAC;4BAAE,WAAU;;gCAA6B;gCACC;gCAAU;;;;;;;sCAGrD,8OAAC;4BAAI,WAAU;;8CACX,8OAAC;oCACG,SAAS,IAAM,eAAe;oCAC9B,WAAU;oCACV,UAAU;8CACb;;;;;;8CAGD,8OAAC;oCACG,SAAS;oCACT,WAAU;oCACV,UAAU;8CAET,aAAa,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;AAQ9D"}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/trash-2.js","sources":["file:///Users/jira/UMS/node_modules/lucide-react/src/icons/trash-2.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M10 11v6', key: 'nco0om' }],\n  ['path', { d: 'M14 11v6', key: 'outv1u' }],\n  ['path', { d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6', key: 'miytrc' }],\n  ['path', { d: 'M3 6h18', key: 'd0wm0j' }],\n  ['path', { d: 'M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2', key: 'e791ji' }],\n];\n\n/**\n * @component @name Trash2\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTAgMTF2NiIgLz4KICA8cGF0aCBkPSJNMTQgMTF2NiIgLz4KICA8cGF0aCBkPSJNMTkgNnYxNGEyIDIgMCAwIDEtMiAySDdhMiAyIDAgMCAxLTItMlY2IiAvPgogIDxwYXRoIGQ9Ik0zIDZoMTgiIC8+CiAgPHBhdGggZD0iTTggNlY0YTIgMiAwIDAgMSAyLTJoNGEyIDIgMCAwIDEgMiAydjIiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/trash-2\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Trash2 = createLucideIcon('trash-2', __iconNode);\n\nexport default Trash2;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAA4C,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAW,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACxC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAA0C,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CACzE;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,MAAA,CAAA,CAAA,KAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}}]
}