{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/interview.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all interview slots for admin listing\nexport async function getInterviewSlots(filters?: {\n    programId?: string;\n    upcoming?: boolean;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.upcoming) {\n            where.startTime = { gte: new Date() };\n        }\n\n        const slots = await prisma.interviewSlot.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameEn: true,\n                        nameTh: true,\n                    },\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                id: true,\n                                firstName: true,\n                                lastName: true,\n                                title: true,\n                            },\n                        },\n                    },\n                },\n                interviewResults: {\n                    select: {\n                        id: true,\n                        confirmedAt: true,\n                        checkedInAt: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        interviewResults: true,\n                    },\n                },\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return slots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\n\nexport async function getAvailableInterviewSlots(programId: string) {\n    try {\n        const now = new Date();\n\n        const slots = await prisma.interviewSlot.findMany({\n            where: {\n                programId,\n                startTime: {\n                    gte: now // Only future slots\n                }\n            },\n            include: {\n                interviewResults: true,\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                }\n            },\n            orderBy: {\n                startTime: 'asc'\n            }\n        });\n\n        // Filter slots that still have capacity\n        const availableSlots = slots.filter(slot => {\n            // Assuming each slot can handle multiple interviews (or set a max capacity)\n            // For simplicity, we'll allow unlimited bookings per slot\n            // In production, you might want to add a capacity field\n            return true;\n        });\n\n        return availableSlots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\nexport async function bookInterviewSlot(applicationId: string, slotId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    try {\n        // Check if application exists and belongs to user\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                applicant: true,\n                interview: true\n            }\n        });\n\n        if (!application) {\n            throw new Error(\"Application not found\");\n        }\n\n        const userId = (session.user as any).id;\n        if (application.applicant.userId !== userId) {\n            throw new Error(\"Unauthorized: This application does not belong to you\");\n        }\n\n        // Check if already has interview scheduled\n        if (application.interview) {\n            throw new Error(\"You already have an interview scheduled for this application\");\n        }\n\n        // Check if slot exists and is in the future\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId }\n        });\n\n        if (!slot) {\n            throw new Error(\"Interview slot not found\");\n        }\n\n        if (new Date(slot.startTime) < new Date()) {\n            throw new Error(\"This interview slot has already passed\");\n        }\n\n        // Create interview result (booking)\n        await prisma.interviewResult.create({\n            data: {\n                applicationId,\n                slotId,\n                confirmedAt: new Date()\n            }\n        });\n\n        // Update application status\n        await prisma.application.update({\n            where: { id: applicationId },\n            data: {\n                status: \"INTERVIEW_COMPLETED\" // Will be updated after actual interview\n            }\n        });\n\n        revalidatePath(\"/applicant/dashboard\");\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error booking interview slot:\", error);\n        throw new Error(error.message || \"Failed to book interview slot\");\n    }\n}\n\nexport async function getMyInterviewDetails(applicationId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    try {\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                interview: {\n                    include: {\n                        slot: {\n                            include: {\n                                interviewers: {\n                                    include: {\n                                        interviewer: {\n                                            select: {\n                                                firstName: true,\n                                                lastName: true,\n                                                title: true\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        return application?.interview || null;\n    } catch (error) {\n        console.error(\"Error fetching interview details:\", error);\n        return null;\n    }\n}\n\nexport async function updateInterviewScore(\n    interviewResultId: string,\n    data: { score: number; comments?: string; isPassed: boolean }\n) {\n    try {\n        await prisma.interviewResult.update({\n            where: { id: interviewResultId },\n            data: {\n                score: data.score,\n                comments: data.comments,\n                isPassed: data.isPassed,\n                checkedInAt: new Date() // Mark as checked in when scored\n            }\n        });\n\n        // Update application status to INTERVIEW_COMPLETED\n        const interviewResult = await prisma.interviewResult.findUnique({\n            where: { id: interviewResultId },\n            select: { applicationId: true }\n        });\n\n        if (interviewResult) {\n            await prisma.application.update({\n                where: { id: interviewResult.applicationId },\n                data: { status: \"INTERVIEW_COMPLETED\" }\n            });\n        }\n\n        revalidatePath(\"/admin/admissions/interviews\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error updating interview score:\", error);\n        throw new Error(\"Failed to update interview score\");\n    }\n}\n\nexport async function getInterviewSlotDetails(slotId: string) {\n    try {\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId },\n            include: {\n                program: {\n                    select: {\n                        nameEn: true,\n                        nameTh: true\n                    }\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                },\n                interviewResults: {\n                    include: {\n                        application: {\n                            include: {\n                                applicant: true,\n                                program: {\n                                    select: {\n                                        nameEn: true\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return slot;\n    } catch (error) {\n        console.error(\"Error fetching interview slot details:\", error);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAQsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/interview.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all interview slots for admin listing\nexport async function getInterviewSlots(filters?: {\n    programId?: string;\n    upcoming?: boolean;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.upcoming) {\n            where.startTime = { gte: new Date() };\n        }\n\n        const slots = await prisma.interviewSlot.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameEn: true,\n                        nameTh: true,\n                    },\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                id: true,\n                                firstName: true,\n                                lastName: true,\n                                title: true,\n                            },\n                        },\n                    },\n                },\n                interviewResults: {\n                    select: {\n                        id: true,\n                        confirmedAt: true,\n                        checkedInAt: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        interviewResults: true,\n                    },\n                },\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return slots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\n\nexport async function getAvailableInterviewSlots(programId: string) {\n    try {\n        const now = new Date();\n\n        const slots = await prisma.interviewSlot.findMany({\n            where: {\n                programId,\n                startTime: {\n                    gte: now // Only future slots\n                }\n            },\n            include: {\n                interviewResults: true,\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                }\n            },\n            orderBy: {\n                startTime: 'asc'\n            }\n        });\n\n        // Filter slots that still have capacity\n        const availableSlots = slots.filter(slot => {\n            // Assuming each slot can handle multiple interviews (or set a max capacity)\n            // For simplicity, we'll allow unlimited bookings per slot\n            // In production, you might want to add a capacity field\n            return true;\n        });\n\n        return availableSlots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\nexport async function bookInterviewSlot(applicationId: string, slotId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    try {\n        // Check if application exists and belongs to user\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                applicant: true,\n                interview: true\n            }\n        });\n\n        if (!application) {\n            throw new Error(\"Application not found\");\n        }\n\n        const userId = (session.user as any).id;\n        if (application.applicant.userId !== userId) {\n            throw new Error(\"Unauthorized: This application does not belong to you\");\n        }\n\n        // Check if already has interview scheduled\n        if (application.interview) {\n            throw new Error(\"You already have an interview scheduled for this application\");\n        }\n\n        // Check if slot exists and is in the future\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId }\n        });\n\n        if (!slot) {\n            throw new Error(\"Interview slot not found\");\n        }\n\n        if (new Date(slot.startTime) < new Date()) {\n            throw new Error(\"This interview slot has already passed\");\n        }\n\n        // Create interview result (booking)\n        await prisma.interviewResult.create({\n            data: {\n                applicationId,\n                slotId,\n                confirmedAt: new Date()\n            }\n        });\n\n        // Update application status\n        await prisma.application.update({\n            where: { id: applicationId },\n            data: {\n                status: \"INTERVIEW_COMPLETED\" // Will be updated after actual interview\n            }\n        });\n\n        revalidatePath(\"/applicant/dashboard\");\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error booking interview slot:\", error);\n        throw new Error(error.message || \"Failed to book interview slot\");\n    }\n}\n\nexport async function getMyInterviewDetails(applicationId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    try {\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                interview: {\n                    include: {\n                        slot: {\n                            include: {\n                                interviewers: {\n                                    include: {\n                                        interviewer: {\n                                            select: {\n                                                firstName: true,\n                                                lastName: true,\n                                                title: true\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        return application?.interview || null;\n    } catch (error) {\n        console.error(\"Error fetching interview details:\", error);\n        return null;\n    }\n}\n\nexport async function updateInterviewScore(\n    interviewResultId: string,\n    data: { score: number; comments?: string; isPassed: boolean }\n) {\n    try {\n        await prisma.interviewResult.update({\n            where: { id: interviewResultId },\n            data: {\n                score: data.score,\n                comments: data.comments,\n                isPassed: data.isPassed,\n                checkedInAt: new Date() // Mark as checked in when scored\n            }\n        });\n\n        // Update application status to INTERVIEW_COMPLETED\n        const interviewResult = await prisma.interviewResult.findUnique({\n            where: { id: interviewResultId },\n            select: { applicationId: true }\n        });\n\n        if (interviewResult) {\n            await prisma.application.update({\n                where: { id: interviewResult.applicationId },\n                data: { status: \"INTERVIEW_COMPLETED\" }\n            });\n        }\n\n        revalidatePath(\"/admin/admissions/interviews\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error updating interview score:\", error);\n        throw new Error(\"Failed to update interview score\");\n    }\n}\n\nexport async function getInterviewSlotDetails(slotId: string) {\n    try {\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId },\n            include: {\n                program: {\n                    select: {\n                        nameEn: true,\n                        nameTh: true\n                    }\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                },\n                interviewResults: {\n                    include: {\n                        application: {\n                            include: {\n                                applicant: true,\n                                program: {\n                                    select: {\n                                        nameEn: true\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return slot;\n    } catch (error) {\n        console.error(\"Error fetching interview slot details:\", error);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAqEsB,6BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/interview.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all interview slots for admin listing\nexport async function getInterviewSlots(filters?: {\n    programId?: string;\n    upcoming?: boolean;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.upcoming) {\n            where.startTime = { gte: new Date() };\n        }\n\n        const slots = await prisma.interviewSlot.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameEn: true,\n                        nameTh: true,\n                    },\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                id: true,\n                                firstName: true,\n                                lastName: true,\n                                title: true,\n                            },\n                        },\n                    },\n                },\n                interviewResults: {\n                    select: {\n                        id: true,\n                        confirmedAt: true,\n                        checkedInAt: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        interviewResults: true,\n                    },\n                },\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return slots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\n\nexport async function getAvailableInterviewSlots(programId: string) {\n    try {\n        const now = new Date();\n\n        const slots = await prisma.interviewSlot.findMany({\n            where: {\n                programId,\n                startTime: {\n                    gte: now // Only future slots\n                }\n            },\n            include: {\n                interviewResults: true,\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                }\n            },\n            orderBy: {\n                startTime: 'asc'\n            }\n        });\n\n        // Filter slots that still have capacity\n        const availableSlots = slots.filter(slot => {\n            // Assuming each slot can handle multiple interviews (or set a max capacity)\n            // For simplicity, we'll allow unlimited bookings per slot\n            // In production, you might want to add a capacity field\n            return true;\n        });\n\n        return availableSlots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\nexport async function bookInterviewSlot(applicationId: string, slotId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    try {\n        // Check if application exists and belongs to user\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                applicant: true,\n                interview: true\n            }\n        });\n\n        if (!application) {\n            throw new Error(\"Application not found\");\n        }\n\n        const userId = (session.user as any).id;\n        if (application.applicant.userId !== userId) {\n            throw new Error(\"Unauthorized: This application does not belong to you\");\n        }\n\n        // Check if already has interview scheduled\n        if (application.interview) {\n            throw new Error(\"You already have an interview scheduled for this application\");\n        }\n\n        // Check if slot exists and is in the future\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId }\n        });\n\n        if (!slot) {\n            throw new Error(\"Interview slot not found\");\n        }\n\n        if (new Date(slot.startTime) < new Date()) {\n            throw new Error(\"This interview slot has already passed\");\n        }\n\n        // Create interview result (booking)\n        await prisma.interviewResult.create({\n            data: {\n                applicationId,\n                slotId,\n                confirmedAt: new Date()\n            }\n        });\n\n        // Update application status\n        await prisma.application.update({\n            where: { id: applicationId },\n            data: {\n                status: \"INTERVIEW_COMPLETED\" // Will be updated after actual interview\n            }\n        });\n\n        revalidatePath(\"/applicant/dashboard\");\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error booking interview slot:\", error);\n        throw new Error(error.message || \"Failed to book interview slot\");\n    }\n}\n\nexport async function getMyInterviewDetails(applicationId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    try {\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                interview: {\n                    include: {\n                        slot: {\n                            include: {\n                                interviewers: {\n                                    include: {\n                                        interviewer: {\n                                            select: {\n                                                firstName: true,\n                                                lastName: true,\n                                                title: true\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        return application?.interview || null;\n    } catch (error) {\n        console.error(\"Error fetching interview details:\", error);\n        return null;\n    }\n}\n\nexport async function updateInterviewScore(\n    interviewResultId: string,\n    data: { score: number; comments?: string; isPassed: boolean }\n) {\n    try {\n        await prisma.interviewResult.update({\n            where: { id: interviewResultId },\n            data: {\n                score: data.score,\n                comments: data.comments,\n                isPassed: data.isPassed,\n                checkedInAt: new Date() // Mark as checked in when scored\n            }\n        });\n\n        // Update application status to INTERVIEW_COMPLETED\n        const interviewResult = await prisma.interviewResult.findUnique({\n            where: { id: interviewResultId },\n            select: { applicationId: true }\n        });\n\n        if (interviewResult) {\n            await prisma.application.update({\n                where: { id: interviewResult.applicationId },\n                data: { status: \"INTERVIEW_COMPLETED\" }\n            });\n        }\n\n        revalidatePath(\"/admin/admissions/interviews\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error updating interview score:\", error);\n        throw new Error(\"Failed to update interview score\");\n    }\n}\n\nexport async function getInterviewSlotDetails(slotId: string) {\n    try {\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId },\n            include: {\n                program: {\n                    select: {\n                        nameEn: true,\n                        nameTh: true\n                    }\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                },\n                interviewResults: {\n                    include: {\n                        application: {\n                            include: {\n                                applicant: true,\n                                program: {\n                                    select: {\n                                        nameEn: true\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return slot;\n    } catch (error) {\n        console.error(\"Error fetching interview slot details:\", error);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAkHsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/interview.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all interview slots for admin listing\nexport async function getInterviewSlots(filters?: {\n    programId?: string;\n    upcoming?: boolean;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.upcoming) {\n            where.startTime = { gte: new Date() };\n        }\n\n        const slots = await prisma.interviewSlot.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameEn: true,\n                        nameTh: true,\n                    },\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                id: true,\n                                firstName: true,\n                                lastName: true,\n                                title: true,\n                            },\n                        },\n                    },\n                },\n                interviewResults: {\n                    select: {\n                        id: true,\n                        confirmedAt: true,\n                        checkedInAt: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        interviewResults: true,\n                    },\n                },\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return slots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\n\nexport async function getAvailableInterviewSlots(programId: string) {\n    try {\n        const now = new Date();\n\n        const slots = await prisma.interviewSlot.findMany({\n            where: {\n                programId,\n                startTime: {\n                    gte: now // Only future slots\n                }\n            },\n            include: {\n                interviewResults: true,\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                }\n            },\n            orderBy: {\n                startTime: 'asc'\n            }\n        });\n\n        // Filter slots that still have capacity\n        const availableSlots = slots.filter(slot => {\n            // Assuming each slot can handle multiple interviews (or set a max capacity)\n            // For simplicity, we'll allow unlimited bookings per slot\n            // In production, you might want to add a capacity field\n            return true;\n        });\n\n        return availableSlots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\nexport async function bookInterviewSlot(applicationId: string, slotId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    try {\n        // Check if application exists and belongs to user\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                applicant: true,\n                interview: true\n            }\n        });\n\n        if (!application) {\n            throw new Error(\"Application not found\");\n        }\n\n        const userId = (session.user as any).id;\n        if (application.applicant.userId !== userId) {\n            throw new Error(\"Unauthorized: This application does not belong to you\");\n        }\n\n        // Check if already has interview scheduled\n        if (application.interview) {\n            throw new Error(\"You already have an interview scheduled for this application\");\n        }\n\n        // Check if slot exists and is in the future\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId }\n        });\n\n        if (!slot) {\n            throw new Error(\"Interview slot not found\");\n        }\n\n        if (new Date(slot.startTime) < new Date()) {\n            throw new Error(\"This interview slot has already passed\");\n        }\n\n        // Create interview result (booking)\n        await prisma.interviewResult.create({\n            data: {\n                applicationId,\n                slotId,\n                confirmedAt: new Date()\n            }\n        });\n\n        // Update application status\n        await prisma.application.update({\n            where: { id: applicationId },\n            data: {\n                status: \"INTERVIEW_COMPLETED\" // Will be updated after actual interview\n            }\n        });\n\n        revalidatePath(\"/applicant/dashboard\");\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error booking interview slot:\", error);\n        throw new Error(error.message || \"Failed to book interview slot\");\n    }\n}\n\nexport async function getMyInterviewDetails(applicationId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    try {\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                interview: {\n                    include: {\n                        slot: {\n                            include: {\n                                interviewers: {\n                                    include: {\n                                        interviewer: {\n                                            select: {\n                                                firstName: true,\n                                                lastName: true,\n                                                title: true\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        return application?.interview || null;\n    } catch (error) {\n        console.error(\"Error fetching interview details:\", error);\n        return null;\n    }\n}\n\nexport async function updateInterviewScore(\n    interviewResultId: string,\n    data: { score: number; comments?: string; isPassed: boolean }\n) {\n    try {\n        await prisma.interviewResult.update({\n            where: { id: interviewResultId },\n            data: {\n                score: data.score,\n                comments: data.comments,\n                isPassed: data.isPassed,\n                checkedInAt: new Date() // Mark as checked in when scored\n            }\n        });\n\n        // Update application status to INTERVIEW_COMPLETED\n        const interviewResult = await prisma.interviewResult.findUnique({\n            where: { id: interviewResultId },\n            select: { applicationId: true }\n        });\n\n        if (interviewResult) {\n            await prisma.application.update({\n                where: { id: interviewResult.applicationId },\n                data: { status: \"INTERVIEW_COMPLETED\" }\n            });\n        }\n\n        revalidatePath(\"/admin/admissions/interviews\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error updating interview score:\", error);\n        throw new Error(\"Failed to update interview score\");\n    }\n}\n\nexport async function getInterviewSlotDetails(slotId: string) {\n    try {\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId },\n            include: {\n                program: {\n                    select: {\n                        nameEn: true,\n                        nameTh: true\n                    }\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                },\n                interviewResults: {\n                    include: {\n                        application: {\n                            include: {\n                                applicant: true,\n                                program: {\n                                    select: {\n                                        nameEn: true\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return slot;\n    } catch (error) {\n        console.error(\"Error fetching interview slot details:\", error);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAuLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/interview.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all interview slots for admin listing\nexport async function getInterviewSlots(filters?: {\n    programId?: string;\n    upcoming?: boolean;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.upcoming) {\n            where.startTime = { gte: new Date() };\n        }\n\n        const slots = await prisma.interviewSlot.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameEn: true,\n                        nameTh: true,\n                    },\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                id: true,\n                                firstName: true,\n                                lastName: true,\n                                title: true,\n                            },\n                        },\n                    },\n                },\n                interviewResults: {\n                    select: {\n                        id: true,\n                        confirmedAt: true,\n                        checkedInAt: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        interviewResults: true,\n                    },\n                },\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return slots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\n\nexport async function getAvailableInterviewSlots(programId: string) {\n    try {\n        const now = new Date();\n\n        const slots = await prisma.interviewSlot.findMany({\n            where: {\n                programId,\n                startTime: {\n                    gte: now // Only future slots\n                }\n            },\n            include: {\n                interviewResults: true,\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                }\n            },\n            orderBy: {\n                startTime: 'asc'\n            }\n        });\n\n        // Filter slots that still have capacity\n        const availableSlots = slots.filter(slot => {\n            // Assuming each slot can handle multiple interviews (or set a max capacity)\n            // For simplicity, we'll allow unlimited bookings per slot\n            // In production, you might want to add a capacity field\n            return true;\n        });\n\n        return availableSlots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\nexport async function bookInterviewSlot(applicationId: string, slotId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    try {\n        // Check if application exists and belongs to user\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                applicant: true,\n                interview: true\n            }\n        });\n\n        if (!application) {\n            throw new Error(\"Application not found\");\n        }\n\n        const userId = (session.user as any).id;\n        if (application.applicant.userId !== userId) {\n            throw new Error(\"Unauthorized: This application does not belong to you\");\n        }\n\n        // Check if already has interview scheduled\n        if (application.interview) {\n            throw new Error(\"You already have an interview scheduled for this application\");\n        }\n\n        // Check if slot exists and is in the future\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId }\n        });\n\n        if (!slot) {\n            throw new Error(\"Interview slot not found\");\n        }\n\n        if (new Date(slot.startTime) < new Date()) {\n            throw new Error(\"This interview slot has already passed\");\n        }\n\n        // Create interview result (booking)\n        await prisma.interviewResult.create({\n            data: {\n                applicationId,\n                slotId,\n                confirmedAt: new Date()\n            }\n        });\n\n        // Update application status\n        await prisma.application.update({\n            where: { id: applicationId },\n            data: {\n                status: \"INTERVIEW_COMPLETED\" // Will be updated after actual interview\n            }\n        });\n\n        revalidatePath(\"/applicant/dashboard\");\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error booking interview slot:\", error);\n        throw new Error(error.message || \"Failed to book interview slot\");\n    }\n}\n\nexport async function getMyInterviewDetails(applicationId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    try {\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                interview: {\n                    include: {\n                        slot: {\n                            include: {\n                                interviewers: {\n                                    include: {\n                                        interviewer: {\n                                            select: {\n                                                firstName: true,\n                                                lastName: true,\n                                                title: true\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        return application?.interview || null;\n    } catch (error) {\n        console.error(\"Error fetching interview details:\", error);\n        return null;\n    }\n}\n\nexport async function updateInterviewScore(\n    interviewResultId: string,\n    data: { score: number; comments?: string; isPassed: boolean }\n) {\n    try {\n        await prisma.interviewResult.update({\n            where: { id: interviewResultId },\n            data: {\n                score: data.score,\n                comments: data.comments,\n                isPassed: data.isPassed,\n                checkedInAt: new Date() // Mark as checked in when scored\n            }\n        });\n\n        // Update application status to INTERVIEW_COMPLETED\n        const interviewResult = await prisma.interviewResult.findUnique({\n            where: { id: interviewResultId },\n            select: { applicationId: true }\n        });\n\n        if (interviewResult) {\n            await prisma.application.update({\n                where: { id: interviewResult.applicationId },\n                data: { status: \"INTERVIEW_COMPLETED\" }\n            });\n        }\n\n        revalidatePath(\"/admin/admissions/interviews\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error updating interview score:\", error);\n        throw new Error(\"Failed to update interview score\");\n    }\n}\n\nexport async function getInterviewSlotDetails(slotId: string) {\n    try {\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId },\n            include: {\n                program: {\n                    select: {\n                        nameEn: true,\n                        nameTh: true\n                    }\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                },\n                interviewResults: {\n                    include: {\n                        application: {\n                            include: {\n                                applicant: true,\n                                program: {\n                                    select: {\n                                        nameEn: true\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return slot;\n    } catch (error) {\n        console.error(\"Error fetching interview slot details:\", error);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA+NsB,uBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/actions/interview.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@ums/lib\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { revalidatePath } from \"next/cache\";\n\n// Get all interview slots for admin listing\nexport async function getInterviewSlots(filters?: {\n    programId?: string;\n    upcoming?: boolean;\n}) {\n    try {\n        const where: any = {};\n\n        if (filters?.programId) {\n            where.programId = filters.programId;\n        }\n\n        if (filters?.upcoming) {\n            where.startTime = { gte: new Date() };\n        }\n\n        const slots = await prisma.interviewSlot.findMany({\n            where,\n            include: {\n                program: {\n                    select: {\n                        id: true,\n                        nameEn: true,\n                        nameTh: true,\n                    },\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                id: true,\n                                firstName: true,\n                                lastName: true,\n                                title: true,\n                            },\n                        },\n                    },\n                },\n                interviewResults: {\n                    select: {\n                        id: true,\n                        confirmedAt: true,\n                        checkedInAt: true,\n                    },\n                },\n                _count: {\n                    select: {\n                        interviewResults: true,\n                    },\n                },\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return slots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\n\nexport async function getAvailableInterviewSlots(programId: string) {\n    try {\n        const now = new Date();\n\n        const slots = await prisma.interviewSlot.findMany({\n            where: {\n                programId,\n                startTime: {\n                    gte: now // Only future slots\n                }\n            },\n            include: {\n                interviewResults: true,\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                }\n            },\n            orderBy: {\n                startTime: 'asc'\n            }\n        });\n\n        // Filter slots that still have capacity\n        const availableSlots = slots.filter(slot => {\n            // Assuming each slot can handle multiple interviews (or set a max capacity)\n            // For simplicity, we'll allow unlimited bookings per slot\n            // In production, you might want to add a capacity field\n            return true;\n        });\n\n        return availableSlots;\n    } catch (error) {\n        console.error(\"Error fetching interview slots:\", error);\n        return [];\n    }\n}\n\nexport async function bookInterviewSlot(applicationId: string, slotId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    try {\n        // Check if application exists and belongs to user\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                applicant: true,\n                interview: true\n            }\n        });\n\n        if (!application) {\n            throw new Error(\"Application not found\");\n        }\n\n        const userId = (session.user as any).id;\n        if (application.applicant.userId !== userId) {\n            throw new Error(\"Unauthorized: This application does not belong to you\");\n        }\n\n        // Check if already has interview scheduled\n        if (application.interview) {\n            throw new Error(\"You already have an interview scheduled for this application\");\n        }\n\n        // Check if slot exists and is in the future\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId }\n        });\n\n        if (!slot) {\n            throw new Error(\"Interview slot not found\");\n        }\n\n        if (new Date(slot.startTime) < new Date()) {\n            throw new Error(\"This interview slot has already passed\");\n        }\n\n        // Create interview result (booking)\n        await prisma.interviewResult.create({\n            data: {\n                applicationId,\n                slotId,\n                confirmedAt: new Date()\n            }\n        });\n\n        // Update application status\n        await prisma.application.update({\n            where: { id: applicationId },\n            data: {\n                status: \"INTERVIEW_COMPLETED\" // Will be updated after actual interview\n            }\n        });\n\n        revalidatePath(\"/applicant/dashboard\");\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error booking interview slot:\", error);\n        throw new Error(error.message || \"Failed to book interview slot\");\n    }\n}\n\nexport async function getMyInterviewDetails(applicationId: string) {\n    const session = await getServerSession(authOptions);\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    try {\n        const application = await prisma.application.findUnique({\n            where: { id: applicationId },\n            include: {\n                interview: {\n                    include: {\n                        slot: {\n                            include: {\n                                interviewers: {\n                                    include: {\n                                        interviewer: {\n                                            select: {\n                                                firstName: true,\n                                                lastName: true,\n                                                title: true\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        return application?.interview || null;\n    } catch (error) {\n        console.error(\"Error fetching interview details:\", error);\n        return null;\n    }\n}\n\nexport async function updateInterviewScore(\n    interviewResultId: string,\n    data: { score: number; comments?: string; isPassed: boolean }\n) {\n    try {\n        await prisma.interviewResult.update({\n            where: { id: interviewResultId },\n            data: {\n                score: data.score,\n                comments: data.comments,\n                isPassed: data.isPassed,\n                checkedInAt: new Date() // Mark as checked in when scored\n            }\n        });\n\n        // Update application status to INTERVIEW_COMPLETED\n        const interviewResult = await prisma.interviewResult.findUnique({\n            where: { id: interviewResultId },\n            select: { applicationId: true }\n        });\n\n        if (interviewResult) {\n            await prisma.application.update({\n                where: { id: interviewResult.applicationId },\n                data: { status: \"INTERVIEW_COMPLETED\" }\n            });\n        }\n\n        revalidatePath(\"/admin/admissions/interviews\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error updating interview score:\", error);\n        throw new Error(\"Failed to update interview score\");\n    }\n}\n\nexport async function getInterviewSlotDetails(slotId: string) {\n    try {\n        const slot = await prisma.interviewSlot.findUnique({\n            where: { id: slotId },\n            include: {\n                program: {\n                    select: {\n                        nameEn: true,\n                        nameTh: true\n                    }\n                },\n                interviewers: {\n                    include: {\n                        interviewer: {\n                            select: {\n                                firstName: true,\n                                lastName: true,\n                                title: true\n                            }\n                        }\n                    }\n                },\n                interviewResults: {\n                    include: {\n                        application: {\n                            include: {\n                                applicant: true,\n                                program: {\n                                    select: {\n                                        nameEn: true\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return slot;\n    } catch (error) {\n        console.error(\"Error fetching interview slot details:\", error);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAmQsB,0BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/components/ui/select.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useEffect } from \"react\";\nimport { ChevronDown, Check } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\"; // Assuming you have a utility for class merging, or I'll use simple string template\n\n// Simple class merger if not available\nfunction classNames(...classes: (string | undefined | null | false)[]) {\n    return classes.filter(Boolean).join(\" \");\n}\n\nexport interface SelectOption {\n    value: string;\n    label: string;\n    description?: string;\n    status?: \"success\" | \"warning\" | \"error\" | \"info\" | \"neutral\";\n}\n\ninterface SelectProps {\n    label?: string;\n    value: string;\n    onChange: (value: string) => void;\n    options: SelectOption[];\n    placeholder?: string;\n    disabled?: boolean;\n    required?: boolean;\n    error?: string;\n    className?: string;\n    showDescriptionInValue?: boolean;\n}\n\nexport function Select({\n    label,\n    value,\n    onChange,\n    options,\n    placeholder = \"Select an option\",\n    disabled = false,\n    required = false,\n    error,\n    className,\n    showDescriptionInValue = true,\n}: SelectProps) {\n    const [isOpen, setIsOpen] = useState(false);\n    const containerRef = useRef<HTMLDivElement>(null);\n\n    const selectedOption = options.find((opt) => opt.value === value);\n\n    useEffect(() => {\n        const handleClickOutside = (event: MouseEvent) => {\n            if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\n                setIsOpen(false);\n            }\n        };\n\n        document.addEventListener(\"mousedown\", handleClickOutside);\n        return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, []);\n\n    const handleSelect = (optionValue: string) => {\n        onChange(optionValue);\n        setIsOpen(false);\n    };\n\n    const getStatusColor = (status?: string) => {\n        switch (status) {\n            case \"success\": return \"bg-green-400\";\n            case \"warning\": return \"bg-yellow-400\";\n            case \"error\": return \"bg-red-400\";\n            case \"info\": return \"bg-blue-400\";\n            case \"neutral\": return \"bg-gray-400\";\n            default: return null;\n        }\n    };\n\n    return (\n        <div className={classNames(\"relative\", className)} ref={containerRef}>\n            {label && (\n                <label className=\"mb-1 block text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\">\n                    {label} {required && <span className=\"text-red-500\">*</span>}\n                </label>\n            )}\n\n            <button\n                type=\"button\"\n                onClick={() => !disabled && setIsOpen(!isOpen)}\n                disabled={disabled}\n                className={classNames(\n                    \"relative w-full cursor-default rounded-lg border bg-white py-2 pl-3 pr-10 text-left shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 sm:text-sm\",\n                    error ? \"border-red-500 focus:ring-red-500\" : \"border-gray-300\",\n                    disabled ? \"bg-gray-100 cursor-not-allowed opacity-50\" : \"hover:border-gray-400\"\n                )}\n            >\n                <span className=\"block truncate\">\n                    {selectedOption ? (\n                        <span className=\"flex items-center gap-2\">\n                            {selectedOption.status && (\n                                <span className={classNames(\"h-2 w-2 rounded-full\", getStatusColor(selectedOption.status))} />\n                            )}\n                            <span className=\"font-medium text-gray-900\">{selectedOption.label}</span>\n                            {showDescriptionInValue && selectedOption.description && (\n                                <span className=\"ml-2 truncate text-gray-500\">{selectedOption.description}</span>\n                            )}\n                        </span>\n                    ) : (\n                        <span className=\"text-gray-500\">{placeholder}</span>\n                    )}\n                </span>\n                <span className=\"pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2\">\n                    <ChevronDown className=\"h-4 w-4 text-gray-400\" aria-hidden=\"true\" />\n                </span>\n            </button>\n\n            {isOpen && (\n                <div className=\"absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm\">\n                    {options.length === 0 ? (\n                        <div className=\"relative cursor-default select-none py-2 pl-3 pr-9 text-gray-500\">\n                            No options available\n                        </div>\n                    ) : (\n                        options.map((option) => (\n                            <div\n                                key={option.value}\n                                onClick={() => handleSelect(option.value)}\n                                className={classNames(\n                                    \"relative cursor-default select-none py-2 pl-3 pr-9 hover:bg-blue-50 cursor-pointer\",\n                                    value === option.value ? \"bg-blue-50\" : \"text-gray-900\"\n                                )}\n                            >\n                                <div className=\"flex items-center\">\n                                    {option.status && (\n                                        <span className={classNames(\"mr-2 h-2 w-2 flex-shrink-0 rounded-full\", getStatusColor(option.status))} />\n                                    )}\n                                    <span className={classNames(\"block truncate\", value === option.value ? \"font-semibold\" : \"font-normal\")}>\n                                        {option.label}\n                                    </span>\n                                    {option.description && (\n                                        <span className=\"ml-2 truncate text-gray-500\">\n                                            - {option.description}\n                                        </span>\n                                    )}\n                                </div>\n\n                                {value === option.value && (\n                                    <span className=\"absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600\">\n                                        <Check className=\"h-4 w-4\" aria-hidden=\"true\" />\n                                    </span>\n                                )}\n                            </div>\n                        ))\n                    )}\n                </div>\n            )}\n            {error && <p className=\"mt-1 text-xs text-red-500\">{error}</p>}\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":["file:///Users/jira/UMS/apps/web/app/admin/admissions/interviews/create-slot-form.tsx"],"sourcesContent":["\"use client\";\n\nimport { createInterviewSlot } from \"@/actions/interview\";\nimport { Plus, X } from \"lucide-react\";\nimport { useState } from \"react\";\nimport { Select, SelectOption } from \"@/components/ui/select\";\nimport { useRouter } from \"next/navigation\";\n\nexport default function CreateSlotForm({\n    interviewers,\n    programs,\n    faculties,\n    isPage = false\n}: {\n    interviewers: any[],\n    programs: any[],\n    faculties: any[],\n    isPage?: boolean\n}) {\n    const router = useRouter();\n    const [isOpen, setIsOpen] = useState(false);\n    const [isLoading, setIsLoading] = useState(false);\n    const [selectedInterviewers, setSelectedInterviewers] = useState<string[]>([]);\n    const [selectedFaculty, setSelectedFaculty] = useState(\"\");\n    const [selectedProgram, setSelectedProgram] = useState(\"\");\n    const [searchQuery, setSearchQuery] = useState(\"\");\n    const [currentInterviewer, setCurrentInterviewer] = useState(\"\");\n\n    const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n        e.preventDefault();\n        setIsLoading(true);\n\n        const formData = new FormData(e.currentTarget);\n        const date = formData.get(\"date\") as string;\n        const startTimeStr = formData.get(\"startTime\") as string;\n        const endTimeStr = formData.get(\"endTime\") as string;\n        const location = formData.get(\"location\") as string;\n        const programId = formData.get(\"programId\") as string;\n        const coordinatorName = formData.get(\"coordinatorName\") as string;\n        const coordinatorPhone = formData.get(\"coordinatorPhone\") as string;\n        const description = formData.get(\"description\") as string;\n        const notifyEligibleApplicants = formData.get(\"notifyEligibleApplicants\") === \"on\";\n\n        const startDateTime = new Date(`${date}T${startTimeStr}`);\n        const endDateTime = new Date(`${date}T${endTimeStr}`);\n\n        if (selectedInterviewers.length === 0) {\n            alert(\"Please select at least one interviewer\");\n            setIsLoading(false);\n            return;\n        }\n\n        try {\n            await createInterviewSlot({\n                startTime: startDateTime,\n                endTime: endDateTime,\n                location,\n                interviewerIds: selectedInterviewers,\n                coordinatorName: coordinatorName || undefined,\n                coordinatorPhone: coordinatorPhone || undefined,\n                description: description || undefined,\n                programId: programId || undefined,\n                notifyEligibleApplicants,\n                autoAssignApplicants: formData.get(\"autoAssignApplicants\") === \"on\",\n            } as any);\n\n            if (isPage) {\n                router.push(\"/admin/admissions/interviews\");\n            } else {\n                setIsOpen(false);\n            }\n        } catch (error: any) {\n            console.error(error);\n            alert(error.message || \"Failed to create slot\");\n        } finally {\n            setIsLoading(false);\n        }\n    };\n\n    // Faculty options\n    const facultyOptions: SelectOption[] = [\n        { value: \"\", label: \"All Faculties\", status: \"neutral\" },\n        ...faculties.map((f) => ({\n            value: f.id,\n            label: f.nameEn,\n            description: f.nameTh,\n            status: \"info\" as const,\n        })),\n    ];\n\n    // Filter programs by selected faculty\n    const filteredPrograms = selectedFaculty\n        ? programs.filter(p => p.facultyId === selectedFaculty)\n        : programs;\n\n    const programOptions: SelectOption[] = [\n        { value: \"\", label: \"All Programs (Generic Slot)\", status: \"neutral\" },\n        ...filteredPrograms.map((p) => ({\n            value: p.id,\n            label: p.nameEn,\n            description: p.code,\n            status: \"info\" as const,\n        })),\n    ];\n\n    // Filter interviewers based on search query\n    const filteredInterviewers = interviewers.filter(interviewer => {\n        const fullName = `${interviewer.firstName} ${interviewer.lastName}`.toLowerCase();\n        const position = interviewer.position?.toLowerCase() || \"\";\n        const query = searchQuery.toLowerCase();\n        return fullName.includes(query) || position.includes(query);\n    });\n\n    const availableInterviewers = filteredInterviewers.filter(\n        i => !selectedInterviewers.includes(i.id)\n    );\n\n    const addInterviewer = () => {\n        if (currentInterviewer && !selectedInterviewers.includes(currentInterviewer)) {\n            setSelectedInterviewers([...selectedInterviewers, currentInterviewer]);\n            setCurrentInterviewer(\"\");\n            setSearchQuery(\"\");\n        }\n    };\n\n    const removeInterviewer = (id: string) => {\n        setSelectedInterviewers(selectedInterviewers.filter(i => i !== id));\n    };\n\n    const getInterviewerById = (id: string) => {\n        return interviewers.find(i => i.id === id);\n    };\n\n    // Page mode - render form directly\n    if (isPage) {\n        return (\n            <form onSubmit={handleSubmit} className=\"space-y-6\">\n                <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n                    <div>\n                        <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                            Date <span className=\"text-red-500\">*</span>\n                        </label>\n                        <input\n                            type=\"date\"\n                            name=\"date\"\n                            required\n                            className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                        />\n                    </div>\n                    <div className=\"grid grid-cols-2 gap-4\">\n                        <div>\n                            <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                Start Time <span className=\"text-red-500\">*</span>\n                            </label>\n                            <input\n                                type=\"time\"\n                                name=\"startTime\"\n                                required\n                                className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-500\"\n                            />\n                        </div>\n                        <div>\n                            <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                End Time <span className=\"text-red-500\">*</span>\n                            </label>\n                            <input\n                                type=\"time\"\n                                name=\"endTime\"\n                                required\n                                className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                            />\n                        </div>\n                    </div>\n                </div>\n\n                <div>\n                    <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                        Location / Link <span className=\"text-red-500\">*</span>\n                    </label>\n                    <input\n                        type=\"text\"\n                        name=\"location\"\n                        placeholder=\"e.g. Room 101 or Zoom Link\"\n                        required\n                        className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                    />\n                </div>\n\n                <div>\n                    <label className=\"mb-2 block text-sm font-medium text-gray-700\">\n                        Interviewers <span className=\"text-red-500\">*</span>\n                    </label>\n\n                    {/* Search and Add Section */}\n                    <div className=\"mb-3 flex gap-2\">\n                        <div className=\"flex-1 relative\">\n                            <input\n                                type=\"text\"\n                                placeholder=\"Search interviewer by name or position...\"\n                                value={searchQuery}\n                                onChange={(e) => setSearchQuery(e.target.value)}\n                                className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                            />\n                            {searchQuery && availableInterviewers.length > 0 && (\n                                <div className=\"absolute z-10 mt-1 w-full max-h-48 overflow-y-auto rounded-md border border-gray-300 bg-white shadow-lg\">\n                                    {availableInterviewers.map((interviewer) => (\n                                        <button\n                                            key={interviewer.id}\n                                            type=\"button\"\n                                            onClick={() => {\n                                                setSelectedInterviewers([...selectedInterviewers, interviewer.id]);\n                                                setSearchQuery(\"\");\n                                            }}\n                                            className=\"w-full px-3 py-2 text-left text-sm hover:bg-blue-50 flex flex-col\"\n                                        >\n                                            <span className=\"font-medium\">\n                                                {interviewer.firstName} {interviewer.lastName}\n                                            </span>\n                                            {interviewer.position && (\n                                                <span className=\"text-xs text-gray-500\">{interviewer.position}</span>\n                                            )}\n                                        </button>\n                                    ))}\n                                </div>\n                            )}\n                        </div>\n                    </div>\n\n                    {/* Selected Interviewers */}\n                    {selectedInterviewers.length > 0 && (\n                        <div className=\"space-y-2 rounded-md border border-gray-200 p-3 bg-gray-50\">\n                            <p className=\"text-xs font-medium text-gray-700\">\n                                Selected ({selectedInterviewers.length})\n                            </p>\n                            <div className=\"space-y-1\">\n                                {selectedInterviewers.map((id) => {\n                                    const interviewer = getInterviewerById(id);\n                                    if (!interviewer) return null;\n                                    return (\n                                        <div\n                                            key={id}\n                                            className=\"flex items-center justify-between bg-white rounded px-3 py-2 text-sm\"\n                                        >\n                                            <span>\n                                                {interviewer.firstName} {interviewer.lastName}\n                                                {interviewer.position && (\n                                                    <span className=\"text-gray-500 ml-1\">({interviewer.position})</span>\n                                                )}\n                                            </span>\n                                            <button\n                                                type=\"button\"\n                                                onClick={() => removeInterviewer(id)}\n                                                className=\"text-red-500 hover:text-red-700\"\n                                            >\n                                                <X className=\"h-4 w-4\" />\n                                            </button>\n                                        </div>\n                                    );\n                                })}\n                            </div>\n                        </div>\n                    )}\n                </div>\n\n                <div className=\"border-t border-gray-100 pt-6\">\n                    <h3 className=\"text-sm font-medium text-gray-900 mb-4\">Program Assignment (Optional)</h3>\n\n                    <div className=\"space-y-4\">\n                        <div>\n                            <Select\n                                label=\"Faculty\"\n                                value={selectedFaculty}\n                                onChange={(val) => {\n                                    setSelectedFaculty(val);\n                                    setSelectedProgram(\"\"); // Reset program when faculty changes\n                                }}\n                                options={facultyOptions}\n                            />\n                            <p className=\"mt-1 text-xs text-gray-500\">\n                                Select a faculty to filter programs, or leave empty for all faculties.\n                            </p>\n                        </div>\n\n                        <div>\n                            <Select\n                                label=\"Program\"\n                                value={selectedProgram}\n                                onChange={(val) => setSelectedProgram(val)}\n                                options={programOptions}\n                            />\n                            <input type=\"hidden\" name=\"programId\" value={selectedProgram} />\n                            <p className=\"mt-1 text-xs text-gray-500\">\n                                Leave empty for a generic slot available to all programs.\n                            </p>\n                        </div>\n                    </div>\n                </div>\n\n                <div className=\"border-t border-gray-100 pt-6\">\n                    <h3 className=\"text-sm font-medium text-gray-900 mb-4\">Coordinator Contact (Optional)</h3>\n                    <div className=\"space-y-4\">\n                        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                            <div>\n                                <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                    Coordinator Name\n                                </label>\n                                <input\n                                    type=\"text\"\n                                    name=\"coordinatorName\"\n                                    placeholder=\"e.g. John Doe\"\n                                    className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                />\n                            </div>\n                            <div>\n                                <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                    Contact Phone\n                                </label>\n                                <input\n                                    type=\"tel\"\n                                    name=\"coordinatorPhone\"\n                                    placeholder=\"e.g. 081-234-5678\"\n                                    className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                />\n                            </div>\n                        </div>\n                        <div>\n                            <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                Additional Information / Instructions\n                            </label>\n                            <textarea\n                                name=\"description\"\n                                rows={4}\n                                placeholder=\"e.g. Please bring your portfolio, Dress code: Business casual, etc.\"\n                                className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                            />\n                            <p className=\"mt-1 text-xs text-gray-500\">\n                                Provide any additional details or instructions for interviewees (e.g., what to bring, dress code, preparation tips).\n                            </p>\n                        </div>\n                    </div>\n                </div>\n\n                {selectedProgram && (\n                    <div className=\"space-y-3\">\n                        <div className=\"flex items-start gap-2\">\n                            <input\n                                type=\"checkbox\"\n                                id=\"autoAssignApplicants\"\n                                name=\"autoAssignApplicants\"\n                                className=\"mt-1 h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n                            />\n                            <div>\n                                <label htmlFor=\"autoAssignApplicants\" className=\"text-sm font-medium text-gray-700\">\n                                    Auto-assign eligible applicants\n                                </label>\n                                <p className=\"text-xs text-gray-500\">\n                                    Automatically book this slot for all applicants in this program who are \"Interview Ready\" and haven't been scheduled yet.\n                                </p>\n                            </div>\n                        </div>\n\n                        <div className=\"flex items-center gap-2\">\n                            <input\n                                type=\"checkbox\"\n                                id=\"notifyEligibleApplicants\"\n                                name=\"notifyEligibleApplicants\"\n                                className=\"h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n                            />\n                            <label htmlFor=\"notifyEligibleApplicants\" className=\"text-sm text-gray-700\">\n                                Notify eligible applicants via email (if not auto-assigned)\n                            </label>\n                        </div>\n                    </div>\n                )}\n\n                <div className=\"flex justify-end gap-3 border-t border-gray-100 pt-6\">\n                    <button\n                        type=\"button\"\n                        onClick={() => router.back()}\n                        className=\"rounded-md border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50\"\n                    >\n                        Cancel\n                    </button>\n                    <button\n                        type=\"submit\"\n                        disabled={isLoading}\n                        className=\"rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50\"\n                    >\n                        {isLoading ? \"Creating...\" : \"Create Slot\"}\n                    </button>\n                </div>\n            </form >\n        );\n    }\n\n    // Popup mode - original behavior\n    return (\n        <>\n            <button\n                onClick={() => setIsOpen(true)}\n                className=\"flex items-center gap-2 rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700\"\n            >\n                <Plus className=\"h-4 w-4\" />\n                Create Slot\n            </button>\n\n            {isOpen && (\n                <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4\">\n                    <div className=\"w-full max-w-2xl rounded-lg bg-white p-6 shadow-xl max-h-[90vh] overflow-y-auto\">\n                        <div className=\"mb-4 flex items-center justify-between\">\n                            <h3 className=\"text-lg font-bold text-gray-900\">\n                                New Interview Slot\n                            </h3>\n                            <button\n                                onClick={() => setIsOpen(false)}\n                                className=\"text-gray-400 hover:text-gray-600\"\n                            >\n                                <X className=\"h-5 w-5\" />\n                            </button>\n                        </div>\n\n                        <form onSubmit={handleSubmit} className=\"space-y-4\">\n                            <div>\n                                <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                    Date\n                                </label>\n                                <input\n                                    type=\"date\"\n                                    name=\"date\"\n                                    required\n                                    className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                />\n                            </div>\n                            <div className=\"grid grid-cols-2 gap-4\">\n                                <div>\n                                    <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                        Start Time\n                                    </label>\n                                    <input\n                                        type=\"time\"\n                                        name=\"startTime\"\n                                        required\n                                        className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                    />\n                                </div>\n                                <div>\n                                    <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                        End Time\n                                    </label>\n                                    <input\n                                        type=\"time\"\n                                        name=\"endTime\"\n                                        required\n                                        className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                    />\n                                </div>\n                            </div>\n                            <div>\n                                <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                    Location / Link\n                                </label>\n                                <input\n                                    type=\"text\"\n                                    name=\"location\"\n                                    placeholder=\"e.g. Room 101 or Zoom Link\"\n                                    required\n                                    className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                />\n                            </div>\n\n\n                            <div className=\"grid grid-cols-2 gap-3\">\n                                <div>\n                                    <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                        Coordinator Name\n                                    </label>\n                                    <input\n                                        type=\"text\"\n                                        name=\"coordinatorName\"\n                                        placeholder=\"Optional\"\n                                        className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                    />\n                                </div>\n                                <div>\n                                    <label className=\"mb-1 block text-sm font-medium text-gray-700\">\n                                        Contact Phone\n                                    </label>\n                                    <input\n                                        type=\"tel\"\n                                        name=\"coordinatorPhone\"\n                                        placeholder=\"Optional\"\n                                        className=\"w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                                    />\n                                </div>\n                            </div>\n\n                            <div className=\"border-t border-gray-100 pt-4\">\n                                <Select\n                                    label=\"Program (Optional)\"\n                                    value={selectedProgram}\n                                    onChange={(val) => setSelectedProgram(val)}\n                                    options={programOptions}\n                                />\n                                <input type=\"hidden\" name=\"programId\" value={selectedProgram} />\n                                <p className=\"mt-1 text-xs text-gray-500\">\n                                    Leave empty for a generic slot available to all programs.\n                                </p>\n                            </div>\n\n                            {selectedProgram && (\n                                <div className=\"space-y-3\">\n                                    <div className=\"flex items-start gap-2\">\n                                        <input\n                                            type=\"checkbox\"\n                                            id=\"autoAssignApplicants-popup\"\n                                            name=\"autoAssignApplicants\"\n                                            className=\"mt-1 h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n                                        />\n                                        <div>\n                                            <label htmlFor=\"autoAssignApplicants-popup\" className=\"text-sm font-medium text-gray-700\">\n                                                Auto-assign eligible applicants\n                                            </label>\n                                            <p className=\"text-xs text-gray-500\">\n                                                Automatically book this slot for all applicants in this program who are \"Interview Ready\" and haven't been scheduled yet.\n                                            </p>\n                                        </div>\n                                    </div>\n\n                                    <div className=\"flex items-center gap-2\">\n                                        <input\n                                            type=\"checkbox\"\n                                            id=\"notifyEligibleApplicants-popup\"\n                                            name=\"notifyEligibleApplicants\"\n                                            className=\"h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n                                        />\n                                        <label htmlFor=\"notifyEligibleApplicants-popup\" className=\"text-sm text-gray-700\">\n                                            Notify eligible applicants via email (if not auto-assigned)\n                                        </label>\n                                    </div>\n                                </div>\n                            )}\n\n                            <div className=\"mt-6 flex justify-end gap-3\">\n                                <button\n                                    type=\"button\"\n                                    onClick={() => setIsOpen(false)}\n                                    className=\"rounded-md border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50\"\n                                >\n                                    Cancel\n                                </button>\n                                <button\n                                    type=\"submit\"\n                                    disabled={isLoading}\n                                    className=\"rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50\"\n                                >\n                                    {isLoading ? \"Creating...\" : \"Create Slot\"}\n                                </button>\n                            </div>\n                        </form>\n                    </div>\n                </div>\n            )}\n        </>\n    );\n}\n"],"names":[],"mappings":"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"}}]
}